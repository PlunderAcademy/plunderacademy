---
id: framework-setup
module: testing-fundamentals
number: 2.3.1
title: Testing Framework Setup (Hardhat 3)
objective: >-
  Stand up a focused Hardhat 3 test environment that runs fast, produces useful diagnostics, and mirrors production assumptions for staking flows.
slug: framework-setup
---

## Set the stage

A shipwright tests every joint before launching. Staking contracts process millions in value; you'll run thousands of tests during development to catch bugs before real funds touch the code. A well-configured test framework turns "write test, wait 30 seconds, debug cryptic error" into "write test, see results in 2 seconds, fix precisely."

Hardhat 3 provides fast local chains, rich assertion libraries (Chai), network helpers (time manipulation, impersonation), and fixtures that snapshot state for instant resets. The difference between a slow, flaky test suite and a fast, reliable one often comes down to configuration: compiler settings, fixture patterns, and helper organization.

By setting up Hardhat correctly from the start—realistic compiler settings, efficient fixtures, clear file structure—you build a foundation that scales from 10 tests to 1,000 without becoming a maintenance burden. Every subsequent lesson in this module builds on this foundation.

## Conceptual foundations

### Production-aligned compiler settings

Tests that pass with different compiler settings than production deployments give false confidence. If you test with optimizer off but deploy with optimizer on, gas costs change, bytecode differs, and edge cases (like optimizer-triggered bugs) go undetected.

**Pattern**: Match `hardhat.config.ts` solidity settings to your deployment pipeline exactly—same version, same optimizer runs, same EVM version.

**When to use**: Always. Set this up once at project start; never diverge.

### Fixture pattern for speed and determinism

Deploying contracts is slow—compiling bytecode, creating transactions, mining blocks. Running 100 tests that each deploy from scratch takes minutes. Fixtures solve this: deploy once, snapshot the EVM state, and restore that snapshot before each test. Cost: milliseconds per test.

**How it works**: Hardhat's `loadFixture()` takes a deploy function, runs it once, saves the state, and resets to that state before every test that uses it.

**Benefit**: Tests run 10-100x faster. State is identical across tests—no order dependencies, no flakiness.

**When to use**: Every test suite. Create fixtures for common scenarios (fresh vault, vault with deposits, vault with rewards accrued).

### Test file organization

As test suites grow, organization matters. Group tests by contract, then by function. Use descriptive file names and `describe` blocks.

**Pattern**:
```
test/
  StakingVault.test.ts         → All vault tests
  StakingVault.deposit.ts      → Or split by function if huge
  RewardDistributor.test.ts
  fixtures/
    staking.ts                 → Shared fixtures
  helpers/
    assertions.ts              → Custom helpers
```

**Why**: Reviewers find tests quickly. CI can run subsets (e.g., only vault tests). File names match contract names—no guessing.

### Network helpers for time and impersonation

Staking contracts depend on `block.timestamp` and caller addresses. Tests must control both. Hardhat provides `time.increase()`, `time.latest()`, `impersonateAccount()`, and more.

**When to use**: Every test that checks time-locks, reward accruals, or role-based access.

**Benefit**: Deterministic behavior. No waiting for real time to pass; no dependency on specific accounts existing.

### Assertion libraries and custom matchers

Chai provides `.to.equal()`, `.to.emit()`, `.to.be.reverted` and more. Hardhat extends Chai with `.to.be.revertedWithCustomError()`, `.withArgs()`, `.to.changeTokenBalance()`.

**Pattern**: Use built-in matchers when possible; extract custom helpers for domain-specific assertions (e.g., `expectPosition(vault, user, expectedAmount)`).

**Why**: Built-in matchers are battle-tested and give clear error messages. Custom helpers reduce boilerplate for repeated checks.

## Guided code walk-throughs

These examples show Hardhat 3 setup for staking contract testing: compiler configuration, fixture patterns, and event assertions.

### 1) Production-aligned Hardhat config

Keep configuration small and explicit. Enable the optimizer with a realistic runs value matching your deployment settings.

```ts
// hardhat.config.ts (excerpt)
import { HardhatUserConfig } from "hardhat/config";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24",
    settings: { optimizer: { enabled: true, runs: 200 } }
  }
};

export default config;
```

Takeaway: match compiler settings to production to avoid drift between tests and deploys. If you deploy with 200 runs, test with 200 runs. If production uses Solidity 0.8.24, tests use 0.8.24. No exceptions—divergence causes false confidence.

### 2) Fixture pattern to speed up deployments

Use a fixture to deploy contracts once, snapshot, and restore quickly across tests.

```ts
// test/Token.test.ts (Hardhat 3 + viem pattern)
import assert from "node:assert/strict";
import { describe, it } from "node:test";
import { network } from "hardhat";

describe("ERC20 Token", async function () {
  const { viem } = await network.connect();
  const [owner, user] = await viem.getWalletClients();
  
  it("mints initial supply", async function () {
    const token = await viem.deployContract("TestToken", []);
    const supply = await token.read.totalSupply();
    const balance = await token.read.balanceOf([owner.account.address]);
    assert.equal(balance, supply);
  });
});
```

Takeaway: Hardhat 3's native test runner uses Node.js built-in test infrastructure. Each test gets a fresh deployment context, keeping tests isolated and deterministic. The async `describe` block connects to the network once, then all `it` blocks share that connection.

### 3) Testing events and reverts with helpful messages

Assert events with indexed subjects and use custom errors for structured reverts.

```ts
// test/Staking.events.test.ts (Hardhat 3 + viem pattern)
import assert from "node:assert/strict";
import { describe, it } from "node:test";
import { network } from "hardhat";

describe("Staking events", async function () {
  const { viem } = await network.connect();
  const [owner, user] = await viem.getWalletClients();
  
  it("emits Deposit(address,uint256)", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      owner.account.address,
      owner.account.address
    ]);

    const amount = 1000n * 10n**18n;
    await token.write.transfer([user.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user.account });
    
    const hash = await staking.write.deposit([amount, 1n], { account: user.account });
    const publicClient = await viem.getPublicClient();
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    // Transaction succeeded - event was emitted
    assert.equal(receipt.status, "success");
  });
});
```

Takeaway: event assertions double as documentation for integrators. This test proves `Deposit` emits with the correct user address and amount—frontend developers can rely on this event structure. If the event signature changes, this test breaks immediately.

## Practice and reflection

Apply these setup patterns to your staking test suite:

- **Config audit**: Review `hardhat.config.ts` and verify compiler version, optimizer runs, and EVM version match your deployment settings
- **Test structure**: Write tests using `describe(async function() { ... })` with `await network.connect()` to get viem access
- **Baseline assertions**: Assert initial invariants hold (vault balance = 0, totalStaked = 0, reward rate set correctly)
- **Event test**: Write a test that deposits to the vault and verifies the transaction succeeds
- **Revert test**: Test `deposit(0)` and assert it rejects with `assert.rejects()`
- **Time manipulation**: Write a test that deposits, advances time by 30 days with `networkHelpers.time.increase()`, then checks accrued rewards

{/* Timeline Builder */}
<TimelineBuilder events={[
  {"id":"t1","text":"Configure compiler + optimizer","correctPosition":0},
  {"id":"t2","text":"Write first fixture (deploy baseline)","correctPosition":1},
  {"id":"t3","text":"Assert events and custom errors","correctPosition":2},
  {"id":"t4","text":"Add CI task to run tests","correctPosition":3}
]}/>

## Security and pitfalls

Test framework configuration affects reliability. Follow these patterns to avoid common setup mistakes.

### Optimizer mismatch between tests and production

**Danger**: Testing with optimizer off, deploying with optimizer on. Optimizer changes bytecode, gas costs, and can trigger bugs (especially around low-level calls or assembly).

**Pattern**: Set `optimizer: { enabled: true, runs: 200 }` in `hardhat.config.ts` to match deployment. Document your production settings; keep tests aligned.

**Rule**: If compiler settings diverge, tests lie. Align them once at project start.

### Shared mutable state between tests

**Danger**: Creating one global contract instance and mutating it across tests. Test B assumes vault.totalStaked = 0 but Test A left it at 1000. Order dependencies breed flakiness.

**Pattern**: Deploy fresh contracts in each test. Hardhat 3's test runner handles isolation automatically.

**Rule**: Each test should deploy its own contracts or use helper functions that return fresh instances.

### Missing gas limit configuration

**Danger**: Local Hardhat network has default gas limits that might differ from mainnet/L2s. Tests pass locally but transactions fail on-chain due to block gas limits.

**Pattern**: Configure `hardhat: { blockGasLimit: 30_000_000 }` to match your target chain. For Ethereum mainnet, use ~30M; for L2s, check their docs.

**Why**: Catches gas-heavy operations in tests before they fail in production.

### Inadequate helper functions

**Danger**: Copy-pasting deployment code across tests. Tests for "vault with 10 users and rewards accrued" spend 80% of their code setting up state.

**Pattern**: Create helper functions for common scenarios: `deployFreshVault()`, `deployVaultWithDeposits()`, `deployVaultWithAccruedRewards()`. Call the most relevant one per test.

**Benefit**: Tests are more readable; setup intent is clearer; changes propagate easily.

## Security checklist

Before writing staking tests with your Hardhat setup:

- [ ] **Compiler version matches production**: `hardhat.config.ts` solidity version matches deployment (e.g., `0.8.24`)
- [ ] **Optimizer matches production**: `optimizer.enabled` and `optimizer.runs` match deployment settings exactly
- [ ] **Block gas limit configured**: `hardhat.blockGasLimit` matches target chain (30M for Ethereum, check L2 docs)
- [ ] **Test isolation**: Each test deploys fresh contracts; no shared mutable state between tests
- [ ] **Node.js test runner**: Tests use `import { describe, it } from "node:test"` and `import assert from "node:assert/strict"`
- [ ] **Network connection**: Tests use `await network.connect()` to get `viem` and `networkHelpers`
- [ ] **Test file organization**: Tests grouped by contract; clear naming (`Staking.test.ts`)
- [ ] **Baseline invariant checks**: Tests assert initial invariants (totalStaked = 0, balances correct, roles assigned)
- [ ] **No hardcoded addresses**: Test accounts obtained via `viem.getWalletClients()`; no dependency on specific addresses
- [ ] **Viem deployment pattern**: Use `viem.deployContract()` and `viem.getContractAt()` from the network connection
- [ ] **Assert-based testing**: Use `assert.equal()`, `assert.ok()`, `assert.rejects()` instead of Chai matchers
- [ ] **Fast feedback**: Unit tests run quickly with isolated contract deployments

## Wrap‑up and next steps

You now have a production-aligned Hardhat 3 setup using Node.js's built-in test runner, network helpers for time manipulation, and assert-based testing for clear failures. This foundation—realistic compiler settings, test isolation, organized file structure—scales from 10 tests to 1,000 without slowing down.

In the next lesson, you'll build on this setup by learning unit testing patterns: AAA structure, table-driven tests, custom helpers, and behavioral naming. The infrastructure is ready; now we'll focus on writing tests that are readable, maintainable, and comprehensive.

