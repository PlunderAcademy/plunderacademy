---
id: deployment-setup
module: staking-contract-practical
number: 2.5.3
title: Deploying Your Staking Contract
objective: >-
  Deploy your staking contract using Hardhat 3, test locally, deploy to Zilliqa testnet, and integrate claimant tracking for achievement verification.
slug: deployment-setup
---

## Deployment Overview

In this lesson, you'll deploy a production-ready staking contract to Zilliqa testnet. The deployment process includes:

1. **Project setup** with Hardhat 3 and OpenZeppelin
2. **Contract preparation** with claimant integration
3. **Local testing** with Hardhat node
4. **Deployment scripts** for automated deployment
5. **Zilliqa testnet deployment** with verification
6. **Achievement claiming** using your transaction hash

## Project Setup

### Create New Project

```bash
# Create project directory
mkdir my-staking-contract
cd my-staking-contract

# Initialize Node project
npm init -y

# Install Hardhat 3 and toolbox
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox-viem

# Initialize Hardhat
npx hardhat --init
# Choose: 
# "Hardhat 3"
# "use the default for relative or absolute path"
# "Create a TypeScript project (with Viem)"
# Accept all other defaults
```

### Install Dependencies

```bash
# OpenZeppelin contracts (security primitives)
npm install @openzeppelin/contracts

# Dotenv for environment variables
npm install dotenv

# TypeScript support
npm install --save-dev typescript @types/node

# Small change needed in the tsconfig.json file
"resolveJsonModule": true,
```

### Project Structure

Your project should look like this: (when we are done!)

```
my-staking-contract/
‚îú‚îÄ‚îÄ contracts/
‚îÇ   ‚îî‚îÄ‚îÄ Staking.sol          # Your staking contract
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ deploy-staking.ts    # Deployment script
‚îÇ   ‚îî‚îÄ‚îÄ interact.ts          # Interaction script
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ Staking.test.ts      # Tests (Module 2.5.4)
‚îú‚îÄ‚îÄ hardhat.config.ts        # Hardhat configuration
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .env                     # Environment variables (DO NOT COMMIT)
‚îî‚îÄ‚îÄ .gitignore
```

For now, we need to remove the default files that come with a new hardhat project
- Delete the file contracts/Counter.sol
- Delete the file contracts/Counter.t.sol
- Delete the entire ignition directory and all files (we wont use this deployment method)
- Delete the file scripts/send-op-tx.ts
- Delete the file test/Counter.ts

## Configuring Hardhat for Zilliqa

### Update hardhat.config.ts

```typescript
import type { HardhatUserConfig } from "hardhat/config";

import hardhatToolboxViemPlugin from "@nomicfoundation/hardhat-toolbox-viem";
import hardhatVerifyPlugin from "@nomicfoundation/hardhat-verify";
import hardhatNetworkHelpers from "@nomicfoundation/hardhat-network-helpers";
import { configVariable } from "hardhat/config";
import "dotenv/config";

const config: HardhatUserConfig = {
  plugins: [hardhatToolboxViemPlugin, hardhatVerifyPlugin, hardhatNetworkHelpers],
  solidity: {
    profiles: {
      default: {
        version: "0.8.28",
        settings: {
          evmVersion: "shanghai", // Required for Zilliqa 2.0 compatibility
        },
      },
      production: {
        version: "0.8.28",
        settings: {
          optimizer: {
            enabled: true,
            runs: 200,
          },
          evmVersion: "shanghai", // Required for Zilliqa 2.0 compatibility
        },
      },
    },
  },
  networks: {
    hardhatMainnet: {
      type: "edr-simulated",
      chainType: "l1",
    },
    hardhatOp: {
      type: "edr-simulated",
      chainType: "op",
    },
    zilliqaMainnet: {
      type: "http",
      chainType: "l1",
      chainId: 32769,
      url: "https://api.zilliqa.com",
      accounts: [configVariable("ZILLIQA_MAINNET_PRIVATE_KEY")]
    },
    zilliqaTestnet: {
      type: "http",
      chainType: "l1",
      chainId: 33101,
      url: "https://api.testnet.zilliqa.com",
      accounts: [configVariable("ZILLIQA_TESTNET_PRIVATE_KEY")]
    },
  },
  verify: {
    // Disable Etherscan since we're using Zilliqa networks
    etherscan: {
      enabled: false,
    },
    // Blockscout verification (no API key needed)
    blockscout: {
      enabled: true,
    },
  },
  // Add custom chain descriptors for Zilliqa networks
  chainDescriptors: {
    // Zilliqa Mainnet
    32769: {
      name: "Zilliqa",
      blockExplorers: {
        blockscout: {
          name: "Zilliqa Explorer",
          url: "https://zilliqa.blockscout.com",
          apiUrl: "https://zilliqa.blockscout.com/api",
        },
      },
    },
    // Zilliqa Testnet
    33101: {
      name: "Zilliqa Testnet",
      blockExplorers: {
        blockscout: {
          name: "Zilliqa Testnet Explorer",
          url: "https://testnet.zilliqa.blockscout.com",
          apiUrl: "https://testnet.zilliqa.blockscout.com/api",
        },
      },
    },
  },
};

export default config;
```

**Key settings:**
- **Compiler:** Solidity 0.8.28 with optimizer enabled
- **evmVersion:** "shanghai" - Required for Zilliqa 2.0 compatibility
- **Zilliqa networks:** Testnet and mainnet configurations
- **Private keys:** Loaded from environment variables

### Setup Environment Variables

**Create `.env` file:**

```bash
# Generate a fresh development wallet
openssl rand -hex 32 | sed 's/^/ZILLIQA_TESTNET_PRIVATE_KEY=0x/' > .env

# Add claimant and fee addresses
echo "CLAIMANT_ADDRESS=your_training_portal_wallet_here" >> .env
echo "FEE_ADDRESS=your_fee_collection_wallet_here" >> .env
echo "" >> .env
echo "# WARNING: Never commit this file!" >> .env
echo "# Add .env to .gitignore" >> .env
```

**Important wallet setup:**

**Development Wallet** (in `.env` as `ZILLIQA_TESTNET_PRIVATE_KEY`):
- Generated fresh for security
- Used to deploy contracts and pay gas
- Funded with testnet ZIL from faucet

**Claimant Wallet** (in `.env` as `CLAIMANT_ADDRESS`):
- Your **Plunder Academy training portal wallet**
- Used to verify you completed the module
- Set as `claimant` in the contract constructor

**Fee Wallet** (in `.env` as `FEE_ADDRESS`):
- Where withdrawal fees are sent
- Can be same as claimant, or different treasury address

### Update .gitignore

**Ensure `.env` is never committed:**

```bash
# Add to .gitignore
echo ".env" >> .gitignore
echo "node_modules/" >> .gitignore
echo "artifacts/" >> .gitignore
echo "cache/" >> .gitignore
echo "typechain-types/" >> .gitignore
```

## Creating the Staking Contract

### contracts/Staking.sol

Create your staking contract with claimant integration:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

contract Staking is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // Deposit Item
    struct DepositItem {
        uint256 apy;
        uint256 duration;
        uint256 amount;
        uint256 timestamp;
    }

    // Info of each user
    struct UserInfo {
        uint256 amount;
        DepositItem[] depositItems;
    }

    IERC20 public immutable stakingToken;
    IERC20 public immutable rewardToken;

    uint256 public startedTimestamp;
    address public feeAddress;
    address public claimant;  // For achievement verification
    uint256 public totalStaked;
    uint256 public apy1;
    uint256 public apy2;
    uint256 public apy3;
    uint256 public exitPenaltyPerc;
    uint256 public withdrawFee;

    mapping(address => UserInfo) private userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event ApyUpdated(uint256 newApy1, uint256 newApy2, uint256 newApy3);
    event FeeUpdated(address indexed newFeeAddress, uint256 newWithdrawFee);
    event ExitPenaltyUpdated(uint256 newPenaltyPerc);

    constructor(
        address tokenAddr,
        address feeAddr,
        address _claimant
    ) Ownable(msg.sender) {
        require(tokenAddr != address(0), "Invalid token address");
        require(feeAddr != address(0), "Invalid fee address");
        require(_claimant != address(0), "Invalid claimant address");
        
        stakingToken = IERC20(tokenAddr);
        rewardToken = stakingToken;
        feeAddress = feeAddr;
        claimant = _claimant;

        apy1 = 10;
        apy2 = 15;
        apy3 = 27;

        exitPenaltyPerc = 5;
        withdrawFee = 2;
        startedTimestamp = 0;
        totalStaked = 0;
    }

    function _calculateReward(address _user, uint256 _index) 
        internal view returns (uint256) 
    {
        UserInfo storage user = userInfo[_user];
        require(_index < user.depositItems.length, "Index out of bound");
        if (startedTimestamp == 0 || user.amount == 0)
            return 0;
        
        uint256 dt;
        if (startedTimestamp > user.depositItems[_index].timestamp)
            dt = block.timestamp - startedTimestamp;
        else
            dt = block.timestamp - user.depositItems[_index].timestamp;
        
        if (dt > user.depositItems[_index].duration)
            dt = user.depositItems[_index].duration;
        
        // Use mulDiv for overflow-safe calculation
        // Formula: (amount * apy * dt) / (365 days * 100)
        uint256 numerator = Math.mulDiv(
            user.depositItems[_index].amount,
            user.depositItems[_index].apy,
            100
        );
        return Math.mulDiv(numerator, dt, 365 days);
    }

    function startReward() external onlyOwner {
        require(startedTimestamp == 0, "Can only start rewards once");
        startedTimestamp = block.timestamp;
    }

    function stopReward() external onlyOwner {
        startedTimestamp = 0;
        apy1 = 0;
        apy2 = 0;
        apy3 = 0;
    }

    function deposit(uint256 _amount, uint256 _option) public nonReentrant {
        require(_amount > 0, "Invalid Amount");
        require(_option == 1 || _option == 2 || _option == 3, "Invalid Option");

        UserInfo storage user = userInfo[msg.sender];
        uint256 initialBalance = stakingToken.balanceOf(address(this));
        stakingToken.safeTransferFrom(address(msg.sender), address(this), _amount);

        uint256 amountTransferred = stakingToken.balanceOf(address(this)) - initialBalance;
        user.amount = user.amount + amountTransferred;
        totalStaked += amountTransferred;

        uint256 apy;
        uint256 duration;
        if (_option == 1) {
            apy = apy1;
            duration = 30 days;
        }
        else if (_option == 2) {
            apy = apy2;
            duration = 60 days;
        }
        else {
            apy = apy3;
            duration = 120 days;
        }

        user.depositItems.push(DepositItem({
            apy: apy,
            duration: duration,
            amount: amountTransferred,
            timestamp: block.timestamp
        }));

        emit Deposit(msg.sender, amountTransferred);
    }

    function withdraw(uint256 _index) public nonReentrant {
        UserInfo storage user = userInfo[msg.sender];
        require(_index < user.depositItems.length, "Index out of bound");
        uint256 amount = user.depositItems[_index].amount;
        
        // Calculate reward BEFORE modifying user.amount (needed for _calculateReward)
        uint256 reward = _calculateReward(msg.sender, _index);
        
        // Calculate available rewards BEFORE decrementing totalStaked
        uint256 totalBalance = stakingToken.balanceOf(address(this));
        uint256 availableRewards = totalBalance > totalStaked ? totalBalance - totalStaked : 0;
        
        // Now update state
        user.amount -= amount;
        totalStaked -= amount;

        uint256 dt;
        if (startedTimestamp > user.depositItems[_index].timestamp)
            dt = block.timestamp - startedTimestamp;
        else
            dt = block.timestamp - user.depositItems[_index].timestamp;
        
        if (dt < user.depositItems[_index].duration) {
            // Early withdrawal: apply penalty
            uint256 availableBalance = stakingToken.balanceOf(address(this));
            amount -= amount * exitPenaltyPerc / 100;
            
            require(amount <= availableBalance, "Insufficient contract balance");
            require(amount > 0, "Withdrawal amount is zero");
            
            stakingToken.safeTransfer(address(msg.sender), amount);
            emit EmergencyWithdraw(msg.sender, amount);
        }
        else {
            // Normal withdrawal: principal - fee + rewards
            uint256 fee = amount * withdrawFee / 100;
            
            // Cap reward to available reward pool (not including principal)
            if (reward > availableRewards) {
                reward = availableRewards;
            }
            
            // Transfer fee from principal (always possible since amount is from principal)
            if (fee > 0) {
                stakingToken.safeTransfer(feeAddress, fee);
            }
            
            // Calculate final withdrawal: principal - fee + capped rewards
            uint256 withdrawAmount = amount - fee + reward;
            
            // Final sanity check: ensure we have enough balance
            require(withdrawAmount <= totalBalance - fee, "Insufficient contract balance");
            require(withdrawAmount > 0, "Withdrawal amount is zero");
            
            stakingToken.safeTransfer(address(msg.sender), withdrawAmount);
            emit Withdraw(msg.sender, withdrawAmount);
        }

        // Gas optimization: swap-and-pop instead of linear shift
        uint256 lastIndex = user.depositItems.length - 1;
        if (_index != lastIndex) {
            user.depositItems[_index] = user.depositItems[lastIndex];
        }
        user.depositItems.pop();
    }

    // View functions for UI
    function getStakedTokens(address _user) external view returns (uint256) {
        return userInfo[_user].amount;
    }

    function getStakedItemLength(address _user) external view returns (uint256) {
        return userInfo[_user].depositItems.length;
    }

    function getStakedItemReward(address _user, uint256 _index) 
        external view returns (uint256) 
    {
        return _calculateReward(_user, _index);
    }

    function rewardsRemaining() public view returns (uint256) {
        uint256 reward = rewardToken.balanceOf(address(this));
        if (reward > totalStaked)
            reward -= totalStaked;
        else
            reward = 0;
        return reward;
    }

    // Admin functions
    function updateApy(uint256 newApy1, uint256 newApy2, uint256 newApy3) 
        external onlyOwner 
    {
        require(newApy1 <= 10000 && newApy2 <= 10000 && newApy3 <= 10000, 
                "APY must be below 10000%");
        apy1 = newApy1;
        apy2 = newApy2;
        apy3 = newApy3;
        emit ApyUpdated(newApy1, newApy2, newApy3);
    }

    function updateExitPenalty(uint256 newPenaltyPerc) external onlyOwner {
        require(newPenaltyPerc <= 20, "May not set higher than 20%");
        exitPenaltyPerc = newPenaltyPerc;
        emit ExitPenaltyUpdated(newPenaltyPerc);
    }

    function updateFee(address newFeeAddress, uint256 newWithdrawFee) 
        external onlyOwner 
    {
        require(newFeeAddress != address(0), "Invalid fee address");
        require(newWithdrawFee <= 10, "Fee cannot exceed 10%");
        feeAddress = newFeeAddress;
        withdrawFee = newWithdrawFee;
        emit FeeUpdated(newFeeAddress, newWithdrawFee);
    }
}
```

**Key additions for training:**
- `address public claimant` ‚Üí Your training portal wallet
- Constructor accepts `_claimant` parameter
- Used for achievement verification

### Compile the Contract

```bash
npx hardhat compile
```

**Expected output:**
```
Compiled 1 Solidity file with solc 0.8.28 (evm target: shanghai).
```

## Creating the Deployment Script

### scripts/deploy-staking.ts

Create a comprehensive deployment script with achievement integration:

```typescript
import { network } from "hardhat";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Deploying Staking contract to ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get parameters from environment
    const stakingTokenAddress = process.env.STAKING_TOKEN_ADDRESS as `0x${string}`;
    const feeAddress = (process.env.FEE_ADDRESS || walletClient.account.address) as `0x${string}`;
    const claimantAddress = process.env.CLAIMANT_ADDRESS as `0x${string}`;
    
    if (!stakingTokenAddress) {
      console.error("‚ùå STAKING_TOKEN_ADDRESS not set in .env");
      console.log("Please provide the address of your ERC20 token");
      process.exit(1);
    }
    
    if (!claimantAddress) {
      console.error("‚ùå CLAIMANT_ADDRESS not set in .env");
      console.log("Please set your training portal wallet address");
      process.exit(1);
    }
    
    console.log("Deploying from account:", walletClient.account.address);
    console.log("Staking token:", stakingTokenAddress);
    console.log("Fee address:", feeAddress);
    console.log("Claimant:", claimantAddress);
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Deploy Staking contract
    console.log("\nDeploying Staking contract...");
    
    const stakingArtifact = (await import("../artifacts/contracts/Staking.sol/Staking.json")).default;
    
    const deploymentTx = await walletClient.deployContract({
      abi: stakingArtifact.abi,
      bytecode: stakingArtifact.bytecode as `0x${string}`,
      args: [stakingTokenAddress, feeAddress, claimantAddress],
    });
    
    console.log("‚è≥ Deployment transaction submitted...");
    console.log("Transaction hash:", deploymentTx);
    
    // Wait for transaction receipt
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: deploymentTx 
    });
    
    const contractAddress = receipt.contractAddress!;
    console.log("‚úÖ Staking contract deployed to:", contractAddress);
    
    // Create contract instance
    const staking = await viem.getContractAt("Staking", contractAddress);
    
    // Display transaction ID for achievement submission
    console.log("\nüéØ Transaction ID for Achievement Submission:");
    console.log(deploymentTx);
    
    // Wait for contract activation
    console.log("\n‚è≥ Waiting for contract activation...");
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Verify deployment
    console.log("\nüìã Verifying deployment...");
    try {
      const stakingToken = await staking.read.stakingToken();
      const rewardToken = await staking.read.rewardToken();
      const feeAddr = await staking.read.feeAddress();
      const claimant = await staking.read.claimant();
      const apy1 = await staking.read.apy1();
      const apy2 = await staking.read.apy2();
      const apy3 = await staking.read.apy3();
      const penalty = await staking.read.exitPenaltyPerc();
      const fee = await staking.read.withdrawFee();
      const totalStaked = await staking.read.totalStaked();
      const started = await staking.read.startedTimestamp();
      
      console.log("Staking Token:", stakingToken);
      console.log("Reward Token:", rewardToken);
      console.log("Fee Address:", feeAddr);
      console.log("Claimant:", claimant);
      console.log("APY Tier 1 (30 days):", apy1.toString() + "%");
      console.log("APY Tier 2 (60 days):", apy2.toString() + "%");
      console.log("APY Tier 3 (120 days):", apy3.toString() + "%");
      console.log("Early Exit Penalty:", penalty.toString() + "%");
      console.log("Withdrawal Fee:", fee.toString() + "%");
      console.log("Total Staked:", totalStaked.toString());
      console.log("Rewards Started:", started.toString() === "0" ? "No" : "Yes");
      
      // Verification checks
      if (stakingToken.toLowerCase() !== stakingTokenAddress.toLowerCase()) {
        console.error("‚ö†Ô∏è  Warning: Staking token mismatch!");
      }
      if (claimant.toLowerCase() !== claimantAddress.toLowerCase()) {
        console.error("‚ö†Ô∏è  Warning: Claimant address mismatch!");
      }
      
      console.log("\n‚úÖ All verifications passed!");
      
    } catch (verificationError) {
      console.log("‚ö†Ô∏è  Contract verification failed (may need more time to activate)");
      console.log("Contract deployed successfully. Verify manually later.");
    }
    
    console.log("\nüéâ Deployment completed successfully!");
    console.log("Contract address:", contractAddress);
    console.log("Transaction ID:", deploymentTx);
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    console.log("Deployer:", walletClient.account.address);
    console.log("Claimant:", claimantAddress);
    
    console.log("\nüìã Next Steps:");
    console.log("1. Fund the contract with reward tokens");
    console.log("2. Call startReward() to begin accruing rewards");
    console.log("3. Submit deployment transaction for achievement verification");
    console.log("   https://plunderacademy.com/lessons/island2/staking-contract-practical");
    
  } catch (error) {
    console.error("‚ùå Deployment failed:", error);
    process.exit(1);
  }
}

main().catch(console.error);
```

### Update package.json Scripts

Add convenient npm scripts:

```json
{
  "scripts": {
    "compile": "npx hardhat compile",
    "test": "npx hardhat test",
    "deploy:local": "npx hardhat run scripts/deploy-staking.ts",
    "deploy:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/deploy-staking.ts --network zilliqaTestnet",
    "interact:local": "npx hardhat run scripts/interact.ts",
    "interact:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/interact.ts --network zilliqaTestnet"
  }
}
```

## Local Deployment Testing

### Start Local Hardhat Network

**Terminal 1:**
```bash
npx hardhat node
```

This starts a local blockchain with pre-funded test accounts.

### Deploy Locally

**Terminal 2:**

First, you need a token to stake. Either:
- Use an existing ERC20 token address, OR
- Deploy a simple test token:

**Quick test token (for local testing only):**

Create `contracts/TestToken.sol`:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor() ERC20("Test Token", "TEST") {
        _mint(msg.sender, 1000000 * 10**18);
    }
}
```
rerun 'npx hardhat compile'

Create `scripts/deploy-test-token.ts`:
```typescript
import { network } from "hardhat";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Deploying TestToken contract to ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    console.log("Deploying from account:", walletClient.account.address);
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Deploy TestToken contract
    console.log("\nDeploying TestToken contract...");
    
    const testTokenArtifact = (await import("../artifacts/contracts/TestToken.sol/TestToken.json")).default;
    
    const deploymentTx = await walletClient.deployContract({
      abi: testTokenArtifact.abi,
      bytecode: testTokenArtifact.bytecode as `0x${string}`,
      args: [],
    });
    
    console.log("‚è≥ Deployment transaction submitted...");
    console.log("Transaction hash:", deploymentTx);
    
    // Wait for transaction receipt
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: deploymentTx 
    });
    
    const contractAddress = receipt.contractAddress!;
    console.log("‚úÖ TestToken contract deployed to:", contractAddress);
    
    // Create contract instance
    const testToken = await viem.getContractAt("TestToken", contractAddress);
    
    // Wait for contract activation
    console.log("\n‚è≥ Waiting for contract activation...");
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Verify deployment
    console.log("\nüìã Verifying deployment...");
    try {
      const name = await testToken.read.name();
      const symbol = await testToken.read.symbol();
      const decimals = await testToken.read.decimals();
      const totalSupply = await testToken.read.totalSupply();
      const deployerBalance = await testToken.read.balanceOf([walletClient.account.address]);
      
      console.log("Token Name:", name);
      console.log("Token Symbol:", symbol);
      console.log("Decimals:", decimals.toString());
      console.log("Total Supply:", totalSupply.toString());
      console.log("Deployer Balance:", deployerBalance.toString());
      
      console.log("\n‚úÖ All verifications passed!");
      
    } catch (verificationError) {
      console.log("‚ö†Ô∏è  Contract verification failed (may need more time to activate)");
      console.log("Contract deployed successfully. Verify manually later.");
    }
    
    console.log("\nüéâ Deployment completed successfully!");
    console.log("Contract address:", contractAddress);
    console.log("Transaction ID:", deploymentTx);
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    console.log("Deployer:", walletClient.account.address);
    
    console.log("\nüìã Use this address as STAKING_TOKEN_ADDRESS in your .env file");
    
  } catch (error) {
    console.error("‚ùå Deployment failed:", error);
    process.exit(1);
  }
}

main().catch(console.error);
```


Deploy it first:
```bash
# In Terminal 2
export HARDHAT_NETWORK=hardhatMainnet
npx hardhat run scripts/deploy-test-token.ts
# Note the deployed token address
```

Then set environment variables and deploy staking:
```bash
export STAKING_TOKEN_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
export CLAIMANT_ADDRESS=0x70997970C51812dc3A010C7d01b50e0d17dc79C8
npm run deploy:local
```

**Expected output:**
```
Deploying Staking contract to localhost...
Deploying from account: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Staking token: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Fee address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Claimant: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
Network: localhost
Chain ID: 31337

Deploying Staking contract...
‚úÖ Staking contract deployed to: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512

üìã Verifying deployment...
APY Tier 1 (30 days): 10%
APY Tier 2 (60 days): 15%
APY Tier 3 (120 days): 27%
Early Exit Penalty: 5%
Withdrawal Fee: 2%
Total Staked: 0

üéâ Deployment completed successfully!
```

## Zilliqa Testnet Deployment

### Prerequisites

**1. Import wallet to MetaMask:**
- Copy private key from `.env`
- MetaMask ‚Üí Import Account ‚Üí Paste private key

**2. Add Zilliqa Testnet to MetaMask:**
- Network Name: `Zilliqa Testnet`
- RPC URL: `https://api.testnet.zilliqa.com`
- Chain ID: `33101`
- Currency Symbol: `ZIL`
- Block Explorer: `https://testnet.zilliqa.blockscout.com`

**3. Get testnet ZIL:**
- Visit https://faucet.testnet.zilliqa.com
- Enter your wallet address
- Request testnet ZIL

### Deploy Your Staking Token (if needed)

If you don't have an existing token:

```bash
# Deploy your ERC20 token from Island 1 Module 5
# Or deploy a new one specifically for staking
```

```bash
# In Terminal 2
export HARDHAT_NETWORK=zilliqaTestnet
npx hardhat run scripts/deploy-test-token.ts
# Note the deployed token address
```

Add the token address to `.env`:
```bash
echo "STAKING_TOKEN_ADDRESS=0xYourTokenAddressHere" >> .env
```

### Deploy Staking Contract to Testnet

**Update `.env` with all required values:**
```
ZILLIQA_TESTNET_PRIVATE_KEY=0x...
STAKING_TOKEN_ADDRESS=0x...
CLAIMANT_ADDRESS=0x...  # Your training portal wallet!
FEE_ADDRESS=0x...        # Optional, defaults to deployer
```

**Deploy:**
```bash
npm run deploy:testnet
```

**Expected testnet output:**
```
Deploying Staking contract to zilliqaTestnet...
Deploying from account: 0xYourDevelopmentWallet
Staking token: 0xYourTokenAddress
Fee address: 0xYourFeeAddress
Claimant: 0xYourTrainingPortalWallet
Network: zilliqaTestnet
Chain ID: 33101

‚è≥ Deployment transaction submitted...
Transaction hash: 0xabcd1234567890...

‚úÖ Staking contract deployed to: 0xNewStakingContractAddress

üéØ Transaction ID for Achievement Submission:
0xabcd1234567890...

üìã Verifying deployment...
Staking Token: 0xYourTokenAddress
Claimant: 0xYourTrainingPortalWallet
APY Tier 1 (30 days): 10%
APY Tier 2 (60 days): 15%
APY Tier 3 (120 days): 27%

‚úÖ All verifications passed!

üéâ Deployment completed successfully!

üìã Next Steps:
1. Fund the contract with reward tokens
2. Call startReward() to begin accruing rewards
3. Submit deployment transaction for achievement verification
```

Add the token address to `.env`:
```bash
echo "STAKING_CONTRACT_ADDRESS=0xYourStakingContractAddressHere" >> .env
```

### Fund the Staking Contract

Transfer reward tokens to your staking contract:

**Using MetaMask:**
1. Switch to your token in MetaMask
2. Send tokens to staking contract address
3. Recommended: 10-20% of total supply for rewards pool

**Or using a script** (`scripts/fund-staking.ts`):
```typescript
import { network } from "hardhat";
import { parseEther, getContract } from "viem";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Funding Staking contract on ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get parameters from environment
    const stakingTokenAddress = process.env.STAKING_TOKEN_ADDRESS as `0x${string}`;
    const stakingContractAddress = process.env.STAKING_CONTRACT_ADDRESS as `0x${string}`;
    const fundAmount = process.env.FUND_AMOUNT || "100000"; // Default 100,000 tokens
    
    if (!stakingTokenAddress) {
      console.error("‚ùå STAKING_TOKEN_ADDRESS not set in .env");
      process.exit(1);
    }
    
    if (!stakingContractAddress) {
      console.error("‚ùå STAKING_CONTRACT_ADDRESS not set in .env");
      console.log("Please provide the deployed staking contract address");
      process.exit(1);
    }
    
    console.log("Funding from account:", walletClient.account.address);
    console.log("Token address:", stakingTokenAddress);
    console.log("Staking contract:", stakingContractAddress);
    console.log("Amount to fund:", fundAmount, "tokens");
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Get token contract instance
    const token = getContract({
      address: stakingTokenAddress,
      abi: [
        {
          name: 'balanceOf',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: 'account', type: 'address' }],
          outputs: [{ name: '', type: 'uint256' }],
        },
        {
          name: 'transfer',
          type: 'function',
          stateMutability: 'nonpayable',
          inputs: [
            { name: 'to', type: 'address' },
            { name: 'amount', type: 'uint256' },
          ],
          outputs: [{ name: '', type: 'bool' }],
        },
      ] as const,
      client: { public: publicClient, wallet: walletClient },
    });
    
    // Check current balance
    console.log("\nüìä Checking balances...");
    const senderBalance = await token.read.balanceOf([walletClient.account.address]);
    const stakingBalance = await token.read.balanceOf([stakingContractAddress]);
    
    console.log("Your balance:", senderBalance.toString());
    console.log("Staking contract balance (before):", stakingBalance.toString());
    
    // Convert amount to wei (18 decimals)
    const amount = parseEther(fundAmount);
    
    // Check if sender has enough balance
    if (senderBalance < amount) {
      console.error("‚ùå Insufficient balance!");
      console.log("You need:", amount.toString());
      console.log("You have:", senderBalance.toString());
      process.exit(1);
    }
    
    // Transfer tokens to staking contract
    console.log("\nüí∏ Transferring reward tokens...");
    const hash = await token.write.transfer([stakingContractAddress, amount]);
    console.log("Transaction hash:", hash);
    
    // Wait for confirmation
    console.log("‚è≥ Waiting for confirmation...");
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    if (receipt.status === "success") {
      console.log("‚úÖ Transfer successful!");
      
      // Check new balances
      const newSenderBalance = await token.read.balanceOf([walletClient.account.address]);
      const newStakingBalance = await token.read.balanceOf([stakingContractAddress]);
      
      console.log("\nüìä New balances:");
      console.log("Your balance:", newSenderBalance.toString());
      console.log("Staking contract balance:", newStakingBalance.toString());
      
      // Get staking contract info
      const staking = await viem.getContractAt("Staking", stakingContractAddress);
      const totalStaked = await staking.read.totalStaked();
      const rewardsRemaining = await staking.read.rewardsRemaining();
      
      console.log("\nüìà Staking contract info:");
      console.log("Total staked:", totalStaked.toString());
      console.log("Rewards available:", rewardsRemaining.toString());
      
      console.log("\nüéâ Funding completed successfully!");
      console.log("Transaction ID:", hash);
      
      console.log("\nüìã Next Steps:");
      console.log("1. If not started, call startReward() on the staking contract");
      console.log("2. Users can now deposit and earn rewards");
      
    } else {
      console.error("‚ùå Transaction failed");
      process.exit(1);
    }
    
  } catch (error) {
    console.error("‚ùå Funding failed:", error);
    process.exit(1);
  }
}

main().catch(console.error);
```

Run it with
```bash
export HARDHAT_NETWORK=zilliqaTestnet
export STAKING_TOKEN_ADDRESS=0xYourTokenAddressHere
export STAKING_CONTRACT_ADDRESS=0xYourStakingContractAddressHere
npx hardhat run scripts/fund-staking.ts --network zilliqaTestnet
```

### Start Rewards

Call `startReward()` to begin reward accrual:

**Using Hardhat - Create** `scripts/start-rewards.ts`:
```typescript
import { network } from "hardhat";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Starting rewards on ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get parameters from environment
    const stakingContractAddress = process.env.STAKING_CONTRACT_ADDRESS as `0x${string}`;
    
    if (!stakingContractAddress) {
      console.error("‚ùå STAKING_CONTRACT_ADDRESS not set in .env");
      console.log("Please provide the deployed staking contract address");
      process.exit(1);
    }
    
    console.log("Calling from account:", walletClient.account.address);
    console.log("Staking contract:", stakingContractAddress);
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Get staking contract instance
    const staking = await viem.getContractAt("Staking", stakingContractAddress);
    
    // Check current status
    console.log("\nüìä Current staking contract status:");
    const startedTimestamp = await staking.read.startedTimestamp();
    const totalStaked = await staking.read.totalStaked();
    const rewardsRemaining = await staking.read.rewardsRemaining();
    const apy1 = await staking.read.apy1();
    const apy2 = await staking.read.apy2();
    const apy3 = await staking.read.apy3();
    
    console.log("Rewards started:", startedTimestamp.toString() === "0" ? "‚ùå No" : `‚úÖ Yes (at timestamp ${startedTimestamp})`);
    console.log("Total staked:", totalStaked.toString());
    console.log("Rewards available:", rewardsRemaining.toString());
    console.log("APY Tier 1 (30 days):", apy1.toString() + "%");
    console.log("APY Tier 2 (60 days):", apy2.toString() + "%");
    console.log("APY Tier 3 (120 days):", apy3.toString() + "%");
    
    // Check if already started
    if (startedTimestamp.toString() !== "0") {
      console.log("\n‚ö†Ô∏è  Rewards have already been started!");
      console.log("Started at timestamp:", startedTimestamp.toString());
      console.log("No action needed.");
      process.exit(0);
    }
    
    // Check if there are rewards available
    if (rewardsRemaining === 0n) {
      console.log("\n‚ö†Ô∏è  Warning: No rewards available in the contract!");
      console.log("Consider funding the contract with reward tokens first.");
      console.log("You can proceed, but users won't earn any rewards until the contract is funded.");
    }
    
    // Start rewards
    console.log("\nüöÄ Starting rewards...");
    const hash = await staking.write.startReward();
    console.log("Transaction hash:", hash);
    
    // Wait for confirmation
    console.log("‚è≥ Waiting for confirmation...");
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    if (receipt.status === "success") {
      console.log("‚úÖ Rewards started successfully!");
      
      // Check new status
      const newStartedTimestamp = await staking.read.startedTimestamp();
      const newRewardsRemaining = await staking.read.rewardsRemaining();
      
      console.log("\nüìä Updated staking contract status:");
      console.log("Started at timestamp:", newStartedTimestamp.toString());
      console.log("Started at block:", receipt.blockNumber.toString());
      console.log("Rewards available:", newRewardsRemaining.toString());
      console.log("Total staked:", totalStaked.toString());
      
      console.log("\nüéâ Reward distribution has begun!");
      console.log("Transaction ID:", hash);
      
      console.log("\nüìã Next Steps:");
      console.log("1. Users can now deposit tokens to start earning rewards");
      console.log("2. Rewards will accrue based on the configured APY tiers");
      console.log("3. Monitor the contract balance to ensure sufficient rewards");
      
    } else {
      console.error("‚ùå Transaction failed");
      process.exit(1);
    }
    
  } catch (error: any) {
    console.error("‚ùå Failed to start rewards:", error);
    
    // Provide helpful error messages
    if (error.message?.includes("Can only start rewards once")) {
      console.log("\nüí° Rewards have already been started for this contract.");
    } else if (error.message?.includes("OwnableUnauthorizedAccount")) {
      console.log("\nüí° Only the contract owner can start rewards.");
      console.log("Make sure you're using the deployer account.");
    }
    
    process.exit(1);
  }
}

main().catch(console.error);
```

Run it with
```bash
export HARDHAT_NETWORK=zilliqaTestnet
export STAKING_TOKEN_ADDRESS=0xYourTokenAddressHere
export STAKING_CONTRACT_ADDRESS=0xYourStakingContractAddressHere
npx hardhat run scripts/start-rewards.ts --network zilliqaTestnet
```

### Deposit a stake!

**Using Hardhat - Create** `scripts/deposit.ts`:
```typescript
import { network } from "hardhat";
import { parseEther, getContract } from "viem";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Depositing to Staking contract on ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get parameters from environment
    const stakingTokenAddress = process.env.STAKING_TOKEN_ADDRESS as `0x${string}`;
    const stakingContractAddress = process.env.STAKING_CONTRACT_ADDRESS as `0x${string}`;
    const depositAmount = process.env.DEPOSIT_AMOUNT || "1000"; // Default 1,000 tokens
    const depositOption = process.env.DEPOSIT_OPTION || "1"; // Default option 1 (30 days, lowest APY)
    
    if (!stakingTokenAddress) {
      console.error("‚ùå STAKING_TOKEN_ADDRESS not set in .env");
      process.exit(1);
    }
    
    if (!stakingContractAddress) {
      console.error("‚ùå STAKING_CONTRACT_ADDRESS not set in .env");
      console.log("Please provide the deployed staking contract address");
      process.exit(1);
    }
    
    const option = parseInt(depositOption);
    if (![1, 2, 3].includes(option)) {
      console.error("‚ùå Invalid DEPOSIT_OPTION. Must be 1, 2, or 3");
      process.exit(1);
    }
    
    console.log("Depositing from account:", walletClient.account.address);
    console.log("Token address:", stakingTokenAddress);
    console.log("Staking contract:", stakingContractAddress);
    console.log("Amount to deposit:", depositAmount, "tokens");
    console.log("Staking option:", option);
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Get contracts
    const token = getContract({
      address: stakingTokenAddress,
      abi: [
        {
          name: 'balanceOf',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: 'account', type: 'address' }],
          outputs: [{ name: '', type: 'uint256' }],
        },
        {
          name: 'allowance',
          type: 'function',
          stateMutability: 'view',
          inputs: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
          ],
          outputs: [{ name: '', type: 'uint256' }],
        },
        {
          name: 'approve',
          type: 'function',
          stateMutability: 'nonpayable',
          inputs: [
            { name: 'spender', type: 'address' },
            { name: 'amount', type: 'uint256' },
          ],
          outputs: [{ name: '', type: 'bool' }],
        },
      ] as const,
      client: { public: publicClient, wallet: walletClient },
    });
    
    const staking = await viem.getContractAt("Staking", stakingContractAddress);
    
    // Check staking contract status
    console.log("\nüìä Staking contract info:");
    const startedTimestamp = await staking.read.startedTimestamp();
    const apy1 = await staking.read.apy1();
    const apy2 = await staking.read.apy2();
    const apy3 = await staking.read.apy3();
    const totalStaked = await staking.read.totalStaked();
    const rewardsRemaining = await staking.read.rewardsRemaining();
    
    console.log("Rewards started:", startedTimestamp.toString() === "0" ? "‚ùå No" : "‚úÖ Yes");
    console.log("Total staked:", totalStaked.toString());
    console.log("Rewards available:", rewardsRemaining.toString());
    console.log("\nAPY Options:");
    console.log("  Option 1 (30 days):", apy1.toString() + "%");
    console.log("  Option 2 (60 days):", apy2.toString() + "%");
    console.log("  Option 3 (120 days):", apy3.toString() + "%");
    
    const selectedApy = option === 1 ? apy1 : option === 2 ? apy2 : apy3;
    const selectedDuration = option === 1 ? "30 days" : option === 2 ? "60 days" : "120 days";
    console.log("\n‚úÖ Selected: Option", option, "-", selectedApy.toString() + "% APY for", selectedDuration);
    
    if (startedTimestamp.toString() === "0") {
      console.log("\n‚ö†Ô∏è  Warning: Rewards haven't started yet!");
      console.log("You can still deposit, but rewards won't accrue until startReward() is called.");
    }
    
    // Check user's current stake
    const userStaked = await staking.read.getStakedTokens([walletClient.account.address]);
    const userDepositCount = await staking.read.getStakedItemLength([walletClient.account.address]);
    console.log("\nüë§ Your current position:");
    console.log("Total staked:", userStaked.toString());
    console.log("Number of deposits:", userDepositCount.toString());
    
    // Check balance
    console.log("\nüí∞ Checking your token balance...");
    const balance = await token.read.balanceOf([walletClient.account.address]);
    console.log("Your balance:", balance.toString());
    
    // Convert amount to wei (18 decimals)
    const amount = parseEther(depositAmount);
    
    // Check if user has enough balance
    if (balance < amount) {
      console.error("‚ùå Insufficient balance!");
      console.log("You need:", amount.toString());
      console.log("You have:", balance.toString());
      process.exit(1);
    }
    
    // Check allowance
    console.log("\nüîç Checking token allowance...");
    const currentAllowance = await token.read.allowance([
      walletClient.account.address,
      stakingContractAddress,
    ]);
    console.log("Current allowance:", currentAllowance.toString());
    
    // Approve if needed (approve 10x the amount to avoid edge cases)
    const approvalAmount = amount * 10n;
    if (currentAllowance < amount) {
      console.log("‚ö†Ô∏è  Insufficient allowance. Approving tokens...");
      console.log("Approving 10x the deposit amount for safety:", approvalAmount.toString());
      const approveHash = await token.write.approve([stakingContractAddress, approvalAmount]);
      console.log("Approval transaction hash:", approveHash);
      console.log("‚è≥ Waiting for approval confirmation...");
      const approveReceipt = await publicClient.waitForTransactionReceipt({ 
        hash: approveHash,
        confirmations: 2  // Wait for 2 confirmations
      });
      
      if (approveReceipt.status === "success") {
        console.log("‚úÖ Approval successful!");
        
        // Verify the allowance was updated
        console.log("üîç Verifying allowance...");
        await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 seconds
        const updatedAllowance = await token.read.allowance([
          walletClient.account.address,
          stakingContractAddress,
        ]);
        console.log("Updated allowance:", updatedAllowance.toString());
        console.log("Expected minimum:", amount.toString());
        
        if (updatedAllowance < amount) {
          console.error("‚ùå Allowance verification failed. Please try again.");
          console.log("Expected at least:", amount.toString());
          console.log("Got:", updatedAllowance.toString());
          process.exit(1);
        }
        console.log("‚úÖ Allowance verified successfully");
      } else {
        console.error("‚ùå Approval failed");
        process.exit(1);
      }
    } else {
      console.log("‚úÖ Sufficient allowance already exists");
    }
    
    // Final check right before deposit
    console.log("\nüîç Final verification before deposit...");
    const finalAllowance = await token.read.allowance([
      walletClient.account.address,
      stakingContractAddress,
    ]);
    console.log("Final allowance check:", finalAllowance.toString());
    console.log("Amount to deposit:", amount.toString());
    console.log("Spender (staking contract):", stakingContractAddress);
    console.log("Owner (your address):", walletClient.account.address);
    
    // Verify staking contract's token address matches
    const stakingTokenFromContract = await staking.read.stakingToken();
    console.log("Token in staking contract:", stakingTokenFromContract);
    console.log("Token we're using:", stakingTokenAddress);
    
    if (stakingTokenFromContract.toLowerCase() !== stakingTokenAddress.toLowerCase()) {
      console.error("‚ùå Token address mismatch!");
      console.log("The staking contract expects a different token!");
      process.exit(1);
    }
    
    if (finalAllowance < amount) {
      console.error("‚ùå Allowance is still insufficient!");
      console.log("This is a blockchain state propagation issue. Please wait and try again.");
      process.exit(1);
    }
    
    // Deposit to staking contract
    console.log("\nüì• Depositing to staking contract...");
    const hash = await staking.write.deposit([amount, BigInt(option)]);
    console.log("Transaction hash:", hash);
    
    // Wait for confirmation
    console.log("‚è≥ Waiting for confirmation...");
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    if (receipt.status === "success") {
      console.log("‚úÖ Deposit successful!");
      
      // Check updated position
      const newUserStaked = await staking.read.getStakedTokens([walletClient.account.address]);
      const newUserDepositCount = await staking.read.getStakedItemLength([walletClient.account.address]);
      const newBalance = await token.read.balanceOf([walletClient.account.address]);
      const newTotalStaked = await staking.read.totalStaked();
      
      console.log("\nüìä Updated position:");
      console.log("Your total staked:", newUserStaked.toString());
      console.log("Number of deposits:", newUserDepositCount.toString());
      console.log("Your token balance:", newBalance.toString());
      console.log("Contract total staked:", newTotalStaked.toString());
      
      console.log("\nüéâ Deposit completed successfully!");
      console.log("Transaction ID:", hash);
      console.log("APY:", selectedApy.toString() + "%");
      console.log("Lock duration:", selectedDuration);
      
      console.log("\nüìã Next Steps:");
      console.log("1. Your tokens are now earning rewards at", selectedApy.toString() + "% APY");
      console.log("2. Wait for the lock period to complete for full rewards");
      console.log("3. You can withdraw early but will incur a penalty");
      console.log("4. Use interact.ts to check your rewards");
      
    } else {
      console.error("‚ùå Transaction failed");
      process.exit(1);
    }
    
  } catch (error: any) {
    console.error("‚ùå Deposit failed:", error);
    
    // Provide helpful error messages
    if (error.message?.includes("Invalid Amount")) {
      console.log("\nüí° Deposit amount must be greater than 0");
    } else if (error.message?.includes("Invalid Option")) {
      console.log("\nüí° Deposit option must be 1, 2, or 3");
    } else if (error.message?.includes("insufficient allowance")) {
      console.log("\nüí° Token approval failed or insufficient");
    }
    
    process.exit(1);
  }
}

main().catch(console.error);
```

Run it with
```bash
export HARDHAT_NETWORK=zilliqaTestnet
export STAKING_TOKEN_ADDRESS=0xYourTokenAddressHere
export STAKING_CONTRACT_ADDRESS=0xYourStakingContractAddressHere
export DEPOSIT_AMOUNT=1000        # Optional, defaults to 1,000 tokens
export DEPOSIT_OPTION=1           # Optional: 1 (30d), 2 (60d), or 3 (120d)
npx hardhat run scripts/deposit.ts --network zilliqaTestnet
```

## Post-Deployment Verification

### Verify on Block Explorer

**Visit Zilliqa Blockscout:**
https://testnet.zilliqa.blockscout.com

**Search for your contract address:**
- View deployment transaction
- Check contract balance
- Verify claimant address is correct

### Interact With Your Contract

Create `scripts/interact.ts`:

```typescript
import { network } from "hardhat";

const stakingAddress = process.env.STAKING_CONTRACT_ADDRESS as `0x${string}`;
const networkName = process.env.HARDHAT_NETWORK || "localhost";

if (!stakingAddress) {
  console.error("Set STAKING_CONTRACT_ADDRESS in .env");
  process.exit(1);
}

const { viem } = await network.connect({ network: networkName });
const publicClient = await viem.getPublicClient();
const [walletClient] = await viem.getWalletClients();

async function main() {
  console.log(`Interacting with Staking contract on ${networkName}...`);
  console.log("Contract address:", stakingAddress);
  console.log("Using account:", walletClient.account.address);
  
  const staking = await viem.getContractAt("Staking", stakingAddress);
  
  // Get contract info
  console.log("\n=== Staking Contract Information ===");
  const stakingToken = await staking.read.stakingToken();
  const claimant = await staking.read.claimant();
  const apy1 = await staking.read.apy1();
  const apy2 = await staking.read.apy2();
  const apy3 = await staking.read.apy3();
  const totalStaked = await staking.read.totalStaked();
  const rewardsRemaining = await staking.read.rewardsRemaining();
  const started = await staking.read.startedTimestamp();
  
  console.log("Staking Token:", stakingToken);
  console.log("Claimant:", claimant);
  console.log("APY Tiers:", apy1.toString() + "% / " + apy2.toString() + "% / " + apy3.toString() + "%");
  console.log("Total Staked:", totalStaked.toString());
  console.log("Rewards Pool:", rewardsRemaining.toString());
  console.log("Rewards Active:", started.toString() !== "0" ? "Yes" : "No");
  
  // Get user info
  console.log("\n=== Your Staking Info ===");
  const userStaked = await staking.read.getStakedTokens([walletClient.account.address]);
  const depositCount = await staking.read.getStakedItemLength([walletClient.account.address]);
  
  console.log("Your Total Staked:", userStaked.toString());
  console.log("Number of Deposits:", depositCount.toString());
  
  if (depositCount > 0n) {
    for (let i = 0; i < Number(depositCount); i++) {
      const reward = await staking.read.getStakedItemReward([walletClient.account.address, BigInt(i)]);
      console.log(`Deposit ${i} Pending Rewards:`, reward.toString());
    }
  }
  
  console.log("\n‚úÖ Interaction completed successfully!");
}

main().catch(console.error);
```

**Run it:**
```bash
export STAKING_CONTRACT_ADDRESS=0xYourStakingAddress
npm run interact:testnet
```

## Claim Your Achievement

### Achievement Submission

**You've successfully deployed your staking contract!**

**To claim your achievement:**

1. **Copy your deployment transaction hash** (from deployment output)
2. **Visit the training portal:** https://plunderacademy.com/lessons/island2/staking-contract-practical
3. **Connect your wallet** (the one set as `CLAIMANT_ADDRESS`)
4. **Submit the transaction hash**
5. **Verification happens automatically:**
   - Checks transaction created a contract
   - Verifies it's a Staking contract
   - Confirms claimant matches your wallet
6. **Receive your achievement NFT!**

## Common Issues and Solutions

### Issue: "Insufficient funds for gas"

**Solution:**
```bash
# Get more testnet ZIL from faucet
https://faucet.testnet.zilliqa.com
```

### Issue: "Contract verification failed"

**Solution:**
```bash
# Contract may need more time to activate on Zilliqa
# Wait 10-30 seconds, then run interact script
npm run interact:testnet
```

### Issue: "Invalid claimant address"

**Solution:**
```bash
# Ensure CLAIMANT_ADDRESS is your training portal wallet
# Check .env file
cat .env | grep CLAIMANT_ADDRESS
```

### Issue: "Token transfer failed"

**Solution:**
```bash
# Ensure staking token address is correct
# Verify token exists and has supply
# Check you approved the staking contract to spend tokens
```

## Deployment Checklist

Before deploying to mainnet (when ready):

- [ ] **Security audit completed** (for significant value)
- [ ] **All tests passing** (Module 2.5.4)
- [ ] **Testnet deployed and tested** thoroughly
- [ ] **Reward pool calculated** and funded
- [ ] **APY rates finalized** and documented
- [ ] **Fee addresses set** (multisig recommended)
- [ ] **Emergency procedures** documented
- [ ] **Team trained** on admin functions
- [ ] **Monitoring set up** (contract balance, total staked)
- [ ] **Community notified** of launch

## Wrap-Up

You've successfully:

‚úÖ **Set up Hardhat 3** with Zilliqa network configurations  
‚úÖ **Created the Staking contract** with claimant integration  
‚úÖ **Written deployment scripts** with comprehensive verification  
‚úÖ **Tested locally** with Hardhat node  
‚úÖ **Deployed to Zilliqa testnet** with proper configuration  
‚úÖ **Verified deployment** on block explorer  
‚úÖ **Funded the reward pool** with tokens  
‚úÖ **Started reward accrual** as contract owner  
‚úÖ **Made test deposits** and tracked staking positions  
‚úÖ **Queried contract information** for monitoring  

**Next up:** Module 2.5.4 will cover comprehensive testing with time manipulation, edge cases, and security validation. You'll write tests that prove your contract handles all scenarios correctly!

Ready to test? Let's go! üöÄ

