---
id: deployment-setup
module: staking-contract-practical
number: 2.5.3
title: Deploying Your Staking Contract
objective: >-
  Deploy your staking contract using Hardhat 3, test locally, deploy to Zilliqa testnet, and integrate claimant tracking for achievement verification.
slug: deployment-setup
---

## Deployment Overview

In this lesson, you'll deploy a production-ready staking contract to Zilliqa testnet. The deployment process includes:

1. **Project setup** with Hardhat 3 and OpenZeppelin
2. **Contract preparation** with claimant integration
3. **Local testing** with Hardhat node
4. **Deployment scripts** for automated deployment
5. **Zilliqa testnet deployment** with verification
6. **Achievement claiming** using your transaction hash

## Project Setup

### Quick Setup Reference

**If you already completed Module 2.3 (Testing Fundamentals)**, your Hardhat environment should be ready. Just install OpenZeppelin:

```bash
npm install @openzeppelin/contracts
```

**If starting fresh**, follow these steps:

### Create New Project

```bash
# Create project directory
mkdir my-staking-contract
cd my-staking-contract

# Initialize Node project
npm init -y

# Install Hardhat 3 and toolbox
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox-viem

# Initialize Hardhat
npx hardhat init
# Choose: "Create a TypeScript project (with Viem)"
# Accept all defaults
```

### Install Dependencies

```bash
# OpenZeppelin contracts (security primitives)
npm install @openzeppelin/contracts

# Dotenv for environment variables
npm install dotenv

# TypeScript support
npm install --save-dev typescript @types/node
```

### Project Structure

Your project should look like this:

```
my-staking-contract/
â”œâ”€â”€ contracts/
â”‚   â””â”€â”€ Staking.sol          # Your staking contract
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ deploy-staking.ts    # Deployment script
â”‚   â””â”€â”€ interact.ts          # Interaction script
â”œâ”€â”€ test/
â”‚   â””â”€â”€ Staking.test.ts      # Tests (Module 2.5.4)
â”œâ”€â”€ hardhat.config.ts        # Hardhat configuration
â”œâ”€â”€ package.json
â”œâ”€â”€ .env                     # Environment variables (DO NOT COMMIT)
â””â”€â”€ .gitignore
```

## Configuring Hardhat for Zilliqa

### Update hardhat.config.ts

```typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox-viem";
import * as dotenv from "dotenv";

dotenv.config();

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    hardhat: {
      chainId: 31337,
    },
    zilliqaTestnet: {
      url: "https://api.testnet.zilliqa.com",
      chainId: 33101,
      accounts: process.env.ZILLIQA_TESTNET_PRIVATE_KEY 
        ? [process.env.ZILLIQA_TESTNET_PRIVATE_KEY] 
        : [],
    },
    zilliqaMainnet: {
      url: "https://api.zilliqa.com",
      chainId: 32769,
      accounts: process.env.ZILLIQA_MAINNET_PRIVATE_KEY 
        ? [process.env.ZILLIQA_MAINNET_PRIVATE_KEY] 
        : [],
    },
  },
  defaultNetwork: "hardhat",
};

export default config;
```

**Key settings:**
- **Compiler:** Solidity 0.8.24 with optimizer enabled
- **Zilliqa networks:** Testnet and mainnet configurations
- **Private keys:** Loaded from environment variables

### Setup Environment Variables

**Create `.env` file:**

```bash
# Generate a fresh development wallet
openssl rand -hex 32 | sed 's/^/ZILLIQA_TESTNET_PRIVATE_KEY=0x/' > .env

# Add claimant and fee addresses
echo "CLAIMANT_ADDRESS=your_training_portal_wallet_here" >> .env
echo "FEE_ADDRESS=your_fee_collection_wallet_here" >> .env
echo "" >> .env
echo "# WARNING: Never commit this file!" >> .env
echo "# Add .env to .gitignore" >> .env
```

**Important wallet setup:**

**Development Wallet** (in `.env` as `ZILLIQA_TESTNET_PRIVATE_KEY`):
- Generated fresh for security
- Used to deploy contracts and pay gas
- Funded with testnet ZIL from faucet

**Claimant Wallet** (in `.env` as `CLAIMANT_ADDRESS`):
- Your **Plunder Academy training portal wallet**
- Used to verify you completed the module
- Set as `claimant` in the contract constructor

**Fee Wallet** (in `.env` as `FEE_ADDRESS`):
- Where withdrawal fees are sent
- Can be same as claimant, or different treasury address

### Update .gitignore

**Ensure `.env` is never committed:**

```bash
# Add to .gitignore
echo ".env" >> .gitignore
echo "node_modules/" >> .gitignore
echo "artifacts/" >> .gitignore
echo "cache/" >> .gitignore
echo "typechain-types/" >> .gitignore
```

## Creating the Staking Contract

### contracts/Staking.sol

Create your staking contract with claimant integration:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Staking is Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Deposit Item
    struct DepositItem {
        uint256 apy;
        uint256 duration;
        uint256 amount;
        uint256 timestamp;
    }

    // Info of each user
    struct UserInfo {
        uint256 amount;
        DepositItem[] depositItems;
    }

    IERC20 public immutable stakingToken;
    IERC20 public immutable rewardToken;

    uint256 public startedTimestamp;
    address public feeAddress;
    address public claimant;  // For achievement verification
    uint256 public totalStaked;
    uint256 public apy1;
    uint256 public apy2;
    uint256 public apy3;
    uint256 public exitPenaltyPerc;
    uint256 public withdrawFee;

    mapping(address => UserInfo) private userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);

    constructor(
        address tokenAddr,
        address feeAddr,
        address _claimant
    ) Ownable(msg.sender) {
        stakingToken = IERC20(tokenAddr);
        rewardToken = stakingToken;
        feeAddress = feeAddr;
        claimant = _claimant;

        apy1 = 10;
        apy2 = 15;
        apy3 = 27;

        exitPenaltyPerc = 5;
        withdrawFee = 2;
        startedTimestamp = 0;
        totalStaked = 0;
    }

    function _calculateReward(address _user, uint256 _index) 
        internal view returns (uint256) 
    {
        UserInfo storage user = userInfo[_user];
        require(_index < user.depositItems.length, "Index out of bound");
        if (startedTimestamp == 0 || user.amount == 0)
            return 0;
        
        uint256 dt;
        if (startedTimestamp > user.depositItems[_index].timestamp)
            dt = block.timestamp - startedTimestamp;
        else
            dt = block.timestamp - user.depositItems[_index].timestamp;
        
        if (dt > user.depositItems[_index].duration)
            dt = user.depositItems[_index].duration;
        
        return (user.depositItems[_index].amount * dt) 
               * user.depositItems[_index].apy / 100 / 365 days;
    }

    function startReward() external onlyOwner {
        require(startedTimestamp == 0, "Can only start rewards once");
        startedTimestamp = block.timestamp;
    }

    function stopReward() external onlyOwner {
        startedTimestamp = 0;
        apy1 = 0;
        apy2 = 0;
        apy3 = 0;
    }

    function deposit(uint256 _amount, uint256 _option) public nonReentrant {
        require(_amount > 0, "Invalid Amount");
        require(_option == 1 || _option == 2 || _option == 3, "Invalid Option");

        UserInfo storage user = userInfo[msg.sender];
        uint256 initialBalance = stakingToken.balanceOf(address(this));
        stakingToken.safeTransferFrom(address(msg.sender), address(this), _amount);

        uint256 amountTransferred = stakingToken.balanceOf(address(this)) - initialBalance;
        user.amount = user.amount.add(amountTransferred);
        totalStaked += amountTransferred;

        uint256 apy;
        uint256 duration;
        if (_option == 1) {
            apy = apy1;
            duration = 30 days;
        }
        else if (_option == 2) {
            apy = apy2;
            duration = 60 days;
        }
        else {
            apy = apy3;
            duration = 120 days;
        }

        user.depositItems.push(DepositItem({
            apy: apy,
            duration: duration,
            amount: _amount,
            timestamp: block.timestamp
        }));

        emit Deposit(msg.sender, _amount);
    }

    function withdraw(uint256 _index) public nonReentrant {
        require(startedTimestamp > 0, "Not started yet");
        
        UserInfo storage user = userInfo[msg.sender];
        require(_index < user.depositItems.length, "Index out of bound");
        uint256 amount = user.depositItems[_index].amount;
        user.amount -= amount;
        totalStaked -= amount;

        uint256 dt;
        if (startedTimestamp > user.depositItems[_index].timestamp)
            dt = block.timestamp - startedTimestamp;
        else
            dt = block.timestamp - user.depositItems[_index].timestamp;
        
        if (dt < user.depositItems[_index].duration) {
            uint256 total = rewardToken.balanceOf(address(this));
            amount -= amount * exitPenaltyPerc / 100;
            if (amount > total)
                amount = total;
            if (amount > 0) {
                stakingToken.safeTransfer(address(msg.sender), amount);
                emit EmergencyWithdraw(msg.sender, amount);
            }
        }
        else {
            uint256 total = rewardToken.balanceOf(address(this));
            uint256 fee = amount * withdrawFee / 100;
            if (fee > total)
                fee = total;
            if (fee > 0)
                stakingToken.safeTransfer(feeAddress, fee);

            total -= fee;
            amount -= fee;
            amount += _calculateReward(msg.sender, _index);
            if (amount > total)
                amount = total;
            if (amount > 0) {
                stakingToken.safeTransfer(address(msg.sender), amount);
                emit Withdraw(msg.sender, amount);
            }
        }

        for (uint256 i = _index; i < user.depositItems.length - 1; i++)
            user.depositItems[i] = user.depositItems[i + 1];
        user.depositItems.pop();
    }

    // View functions for UI
    function getStakedTokens(address _user) external view returns (uint256) {
        return userInfo[_user].amount;
    }

    function getStakedItemLength(address _user) external view returns (uint256) {
        return userInfo[_user].depositItems.length;
    }

    function getStakedItemReward(address _user, uint256 _index) 
        external view returns (uint256) 
    {
        return _calculateReward(_user, _index);
    }

    function rewardsRemaining() public view returns (uint256) {
        uint256 reward = rewardToken.balanceOf(address(this));
        if (reward > totalStaked)
            reward -= totalStaked;
        else
            reward = 0;
        return reward;
    }

    // Admin functions
    function updateApy(uint256 newApy1, uint256 newApy2, uint256 newApy3) 
        external onlyOwner 
    {
        require(newApy1 <= 10000 && newApy2 <= 10000 && newApy3 <= 10000, 
                "APY must be below 10000%");
        apy1 = newApy1;
        apy2 = newApy2;
        apy3 = newApy3;
    }

    function updateExitPenalty(uint256 newPenaltyPerc) external onlyOwner {
        require(newPenaltyPerc <= 20, "May not set higher than 20%");
        exitPenaltyPerc = newPenaltyPerc;
    }

    function updateFee(address newFeeAddress, uint256 newWithdrawFee) 
        external onlyOwner 
    {
        feeAddress = newFeeAddress;
        withdrawFee = newWithdrawFee;
    }

    function withdrawEmergencyReward(uint256 _amount) external onlyOwner {
        require(_amount <= rewardToken.balanceOf(address(this)) - totalStaked,
                'not enough tokens to take out');
        rewardToken.safeTransfer(address(msg.sender), _amount);
    }
}
```

**Key additions for training:**
- `address public claimant` â†’ Your training portal wallet
- Constructor accepts `_claimant` parameter
- Used for achievement verification

### Compile the Contract

```bash
npx hardhat compile
```

**Expected output:**
```
Compiled 1 Solidity file successfully (evm target: paris).
```

## Creating the Deployment Script

### scripts/deploy-staking.ts

Create a comprehensive deployment script with achievement integration:

```typescript
import { network } from "hardhat";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Deploying Staking contract to ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get parameters from environment
    const stakingTokenAddress = process.env.STAKING_TOKEN_ADDRESS as `0x${string}`;
    const feeAddress = (process.env.FEE_ADDRESS || walletClient.account.address) as `0x${string}`;
    const claimantAddress = process.env.CLAIMANT_ADDRESS as `0x${string}`;
    
    if (!stakingTokenAddress) {
      console.error("âŒ STAKING_TOKEN_ADDRESS not set in .env");
      console.log("Please provide the address of your ERC20 token");
      process.exit(1);
    }
    
    if (!claimantAddress) {
      console.error("âŒ CLAIMANT_ADDRESS not set in .env");
      console.log("Please set your training portal wallet address");
      process.exit(1);
    }
    
    console.log("Deploying from account:", walletClient.account.address);
    console.log("Staking token:", stakingTokenAddress);
    console.log("Fee address:", feeAddress);
    console.log("Claimant:", claimantAddress);
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Deploy Staking contract
    console.log("\nDeploying Staking contract...");
    
    const deploymentTx = await walletClient.deployContract({
      abi: (await import("../artifacts/contracts/Staking.sol/Staking.json")).abi,
      bytecode: (await import("../artifacts/contracts/Staking.sol/Staking.json")).bytecode as `0x${string}`,
      args: [stakingTokenAddress, feeAddress, claimantAddress],
    });
    
    console.log("â³ Deployment transaction submitted...");
    console.log("Transaction hash:", deploymentTx);
    
    // Wait for transaction receipt
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: deploymentTx 
    });
    
    const contractAddress = receipt.contractAddress!;
    console.log("âœ… Staking contract deployed to:", contractAddress);
    
    // Create contract instance
    const staking = await viem.getContractAt("Staking", contractAddress);
    
    // Display transaction ID for achievement submission
    console.log("\nðŸŽ¯ Transaction ID for Achievement Submission:");
    console.log(deploymentTx);
    
    // Wait for contract activation
    console.log("\nâ³ Waiting for contract activation...");
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Verify deployment
    console.log("\nðŸ“‹ Verifying deployment...");
    try {
      const stakingToken = await staking.read.stakingToken();
      const rewardToken = await staking.read.rewardToken();
      const feeAddr = await staking.read.feeAddress();
      const claimant = await staking.read.claimant();
      const apy1 = await staking.read.apy1();
      const apy2 = await staking.read.apy2();
      const apy3 = await staking.read.apy3();
      const penalty = await staking.read.exitPenaltyPerc();
      const fee = await staking.read.withdrawFee();
      const totalStaked = await staking.read.totalStaked();
      const started = await staking.read.startedTimestamp();
      
      console.log("Staking Token:", stakingToken);
      console.log("Reward Token:", rewardToken);
      console.log("Fee Address:", feeAddr);
      console.log("Claimant:", claimant);
      console.log("APY Tier 1 (30 days):", apy1.toString() + "%");
      console.log("APY Tier 2 (60 days):", apy2.toString() + "%");
      console.log("APY Tier 3 (120 days):", apy3.toString() + "%");
      console.log("Early Exit Penalty:", penalty.toString() + "%");
      console.log("Withdrawal Fee:", fee.toString() + "%");
      console.log("Total Staked:", totalStaked.toString());
      console.log("Rewards Started:", started.toString() === "0" ? "No" : "Yes");
      
      // Verification checks
      if (stakingToken.toLowerCase() !== stakingTokenAddress.toLowerCase()) {
        console.error("âš ï¸  Warning: Staking token mismatch!");
      }
      if (claimant.toLowerCase() !== claimantAddress.toLowerCase()) {
        console.error("âš ï¸  Warning: Claimant address mismatch!");
      }
      
      console.log("\nâœ… All verifications passed!");
      
    } catch (verificationError) {
      console.log("âš ï¸  Contract verification failed (may need more time to activate)");
      console.log("Contract deployed successfully. Verify manually later.");
    }
    
    console.log("\nðŸŽ‰ Deployment completed successfully!");
    console.log("Contract address:", contractAddress);
    console.log("Transaction ID:", deploymentTx);
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    console.log("Deployer:", walletClient.account.address);
    console.log("Claimant:", claimantAddress);
    
    console.log("\nðŸ“‹ Next Steps:");
    console.log("1. Fund the contract with reward tokens");
    console.log("2. Call startReward() to begin accruing rewards");
    console.log("3. Submit deployment transaction for achievement verification");
    console.log("   https://plunderacademy.com/lessons/island2/staking-contract-practical");
    
  } catch (error) {
    console.error("âŒ Deployment failed:", error);
    process.exit(1);
  }
}

main().catch(console.error);
```

### Update package.json Scripts

Add convenient npm scripts:

```json
{
  "scripts": {
    "compile": "npx hardhat compile",
    "test": "npx hardhat test",
    "deploy:local": "npx hardhat run scripts/deploy-staking.ts",
    "deploy:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/deploy-staking.ts --network zilliqaTestnet",
    "interact:local": "npx hardhat run scripts/interact.ts",
    "interact:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/interact.ts --network zilliqaTestnet"
  }
}
```

## Local Deployment Testing

### Start Local Hardhat Network

**Terminal 1:**
```bash
npx hardhat node
```

This starts a local blockchain with pre-funded test accounts.

### Deploy Locally

**Terminal 2:**

First, you need a token to stake. Either:
- Use an existing ERC20 token address, OR
- Deploy a simple test token:

**Quick test token (for local testing only):**

Create `contracts/TestToken.sol`:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor() ERC20("Test Token", "TEST") {
        _mint(msg.sender, 1000000 * 10**18);
    }
}
```

Deploy it first:
```bash
# In Terminal 2
npx hardhat run scripts/deploy-test-token.ts
# Note the deployed token address
```

Then set environment variables and deploy staking:
```bash
export STAKING_TOKEN_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
export CLAIMANT_ADDRESS=0x70997970C51812dc3A010C7d01b50e0d17dc79C8
npm run deploy:local
```

**Expected output:**
```
Deploying Staking contract to localhost...
Deploying from account: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Staking token: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Fee address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Claimant: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
Network: localhost
Chain ID: 31337

Deploying Staking contract...
âœ… Staking contract deployed to: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512

ðŸ“‹ Verifying deployment...
APY Tier 1 (30 days): 10%
APY Tier 2 (60 days): 15%
APY Tier 3 (120 days): 27%
Early Exit Penalty: 5%
Withdrawal Fee: 2%
Total Staked: 0

ðŸŽ‰ Deployment completed successfully!
```

## Zilliqa Testnet Deployment

### Prerequisites

**1. Generate development wallet:**
```bash
openssl rand -hex 32 | sed 's/^/ZILLIQA_TESTNET_PRIVATE_KEY=0x/' >> .env
```

**2. Import wallet to MetaMask:**
- Copy private key from `.env`
- MetaMask â†’ Import Account â†’ Paste private key

**3. Add Zilliqa Testnet to MetaMask:**
- Network Name: `Zilliqa Testnet`
- RPC URL: `https://api.testnet.zilliqa.com`
- Chain ID: `33101`
- Currency Symbol: `ZIL`
- Block Explorer: `https://testnet.zilliqa.blockscout.com`

**4. Get testnet ZIL:**
- Visit https://faucet.testnet.zilliqa.com
- Enter your wallet address
- Request testnet ZIL

### Deploy Your Staking Token (if needed)

If you don't have an existing token:

```bash
# Deploy your ERC20 token from Island 1 Module 5
# Or deploy a new one specifically for staking
```

Add the token address to `.env`:
```bash
echo "STAKING_TOKEN_ADDRESS=0xYourTokenAddressHere" >> .env
```

### Deploy Staking Contract to Testnet

**Update `.env` with all required values:**
```
ZILLIQA_TESTNET_PRIVATE_KEY=0x...
STAKING_TOKEN_ADDRESS=0x...
CLAIMANT_ADDRESS=0x...  # Your training portal wallet!
FEE_ADDRESS=0x...        # Optional, defaults to deployer
```

**Deploy:**
```bash
npm run deploy:testnet
```

**Expected testnet output:**
```
Deploying Staking contract to zilliqaTestnet...
Deploying from account: 0xYourDevelopmentWallet
Staking token: 0xYourTokenAddress
Fee address: 0xYourFeeAddress
Claimant: 0xYourTrainingPortalWallet
Network: zilliqaTestnet
Chain ID: 33101

â³ Deployment transaction submitted...
Transaction hash: 0xabcd1234567890...

âœ… Staking contract deployed to: 0xNewStakingContractAddress

ðŸŽ¯ Transaction ID for Achievement Submission:
0xabcd1234567890...

ðŸ“‹ Verifying deployment...
Staking Token: 0xYourTokenAddress
Claimant: 0xYourTrainingPortalWallet
APY Tier 1 (30 days): 10%
APY Tier 2 (60 days): 15%
APY Tier 3 (120 days): 27%

âœ… All verifications passed!

ðŸŽ‰ Deployment completed successfully!

ðŸ“‹ Next Steps:
1. Fund the contract with reward tokens
2. Call startReward() to begin accruing rewards
3. Submit deployment transaction for achievement verification
```

### Fund the Staking Contract

Transfer reward tokens to your staking contract:

**Using MetaMask:**
1. Switch to your token in MetaMask
2. Send tokens to staking contract address
3. Recommended: 10-20% of total supply for rewards pool

**Or using a script** (`scripts/fund-staking.ts`):
```typescript
// Fund staking contract with reward tokens
const token = await viem.getContractAt("IERC20", stakingTokenAddress);
const stakingAddress = "0xYourStakingContractAddress";
const amount = 100000n * 10n**18n; // 100,000 tokens

await token.write.transfer([stakingAddress, amount]);
console.log("Funded staking contract with", amount.toString(), "tokens");
```

### Start Rewards

Call `startReward()` to begin reward accrual:

**Using Hardhat:**
```bash
npx hardhat console --network zilliqaTestnet

> const Staking = await ethers.getContractFactory("Staking");
> const staking = Staking.attach("0xYourStakingContractAddress");
> await staking.startReward();
> console.log("Rewards started!");
```

**Or create** `scripts/start-rewards.ts`:
```typescript
const staking = await viem.getContractAt("Staking", stakingAddress);
const tx = await staking.write.startReward();
console.log("Started rewards. Tx:", tx);
```

## Post-Deployment Verification

### Verify on Block Explorer

**Visit Zilliqa Blockscout:**
https://testnet.zilliqa.blockscout.com

**Search for your contract address:**
- View deployment transaction
- Check contract balance
- Verify claimant address is correct

### Interact With Your Contract

Create `scripts/interact.ts`:

```typescript
import { network } from "hardhat";

const stakingAddress = process.env.STAKING_CONTRACT_ADDRESS as `0x${string}`;
const networkName = process.env.HARDHAT_NETWORK || "localhost";

if (!stakingAddress) {
  console.error("Set STAKING_CONTRACT_ADDRESS in .env");
  process.exit(1);
}

const { viem } = await network.connect({ network: networkName });
const publicClient = await viem.getPublicClient();
const [walletClient] = await viem.getWalletClients();

async function main() {
  console.log(`Interacting with Staking contract on ${networkName}...`);
  console.log("Contract address:", stakingAddress);
  console.log("Using account:", walletClient.account.address);
  
  const staking = await viem.getContractAt("Staking", stakingAddress);
  
  // Get contract info
  console.log("\n=== Staking Contract Information ===");
  const stakingToken = await staking.read.stakingToken();
  const claimant = await staking.read.claimant();
  const apy1 = await staking.read.apy1();
  const apy2 = await staking.read.apy2();
  const apy3 = await staking.read.apy3();
  const totalStaked = await staking.read.totalStaked();
  const rewardsRemaining = await staking.read.rewardsRemaining();
  const started = await staking.read.startedTimestamp();
  
  console.log("Staking Token:", stakingToken);
  console.log("Claimant:", claimant);
  console.log("APY Tiers:", apy1.toString() + "% / " + apy2.toString() + "% / " + apy3.toString() + "%");
  console.log("Total Staked:", totalStaked.toString());
  console.log("Rewards Pool:", rewardsRemaining.toString());
  console.log("Rewards Active:", started.toString() !== "0" ? "Yes" : "No");
  
  // Get user info
  console.log("\n=== Your Staking Info ===");
  const userStaked = await staking.read.getStakedTokens([walletClient.account.address]);
  const depositCount = await staking.read.getStakedItemLength([walletClient.account.address]);
  
  console.log("Your Total Staked:", userStaked.toString());
  console.log("Number of Deposits:", depositCount.toString());
  
  if (depositCount > 0n) {
    for (let i = 0; i < Number(depositCount); i++) {
      const reward = await staking.read.getStakedItemReward([walletClient.account.address, BigInt(i)]);
      console.log(`Deposit ${i} Pending Rewards:`, reward.toString());
    }
  }
  
  console.log("\nâœ… Interaction completed successfully!");
}

main().catch(console.error);
```

**Run it:**
```bash
export STAKING_CONTRACT_ADDRESS=0xYourStakingAddress
npm run interact:testnet
```

## Claim Your Achievement

### Achievement Submission

**You've successfully deployed your staking contract!**

**To claim your achievement:**

1. **Copy your deployment transaction hash** (from deployment output)
2. **Visit the training portal:** https://plunderacademy.com/lessons/island2/staking-contract-practical
3. **Connect your wallet** (the one set as `CLAIMANT_ADDRESS`)
4. **Submit the transaction hash**
5. **Verification happens automatically:**
   - Checks transaction created a contract
   - Verifies it's a Staking contract
   - Confirms claimant matches your wallet
6. **Receive your achievement NFT!**

## Common Issues and Solutions

### Issue: "Insufficient funds for gas"

**Solution:**
```bash
# Get more testnet ZIL from faucet
https://faucet.testnet.zilliqa.com
```

### Issue: "Contract verification failed"

**Solution:**
```bash
# Contract may need more time to activate on Zilliqa
# Wait 10-30 seconds, then run interact script
npm run interact:testnet
```

### Issue: "Invalid claimant address"

**Solution:**
```bash
# Ensure CLAIMANT_ADDRESS is your training portal wallet
# Check .env file
cat .env | grep CLAIMANT_ADDRESS
```

### Issue: "Token transfer failed"

**Solution:**
```bash
# Ensure staking token address is correct
# Verify token exists and has supply
# Check you approved the staking contract to spend tokens
```

## Deployment Checklist

Before deploying to mainnet (when ready):

- [ ] **Security audit completed** (for significant value)
- [ ] **All tests passing** (Module 2.5.4)
- [ ] **Testnet deployed and tested** thoroughly
- [ ] **Reward pool calculated** and funded
- [ ] **APY rates finalized** and documented
- [ ] **Fee addresses set** (multisig recommended)
- [ ] **Emergency procedures** documented
- [ ] **Team trained** on admin functions
- [ ] **Monitoring set up** (contract balance, total staked)
- [ ] **Community notified** of launch

## Wrap-Up

You've successfully:

âœ… **Set up Hardhat 3** with Zilliqa network configurations  
âœ… **Created the Staking contract** with claimant integration  
âœ… **Written deployment scripts** with comprehensive verification  
âœ… **Tested locally** with Hardhat node  
âœ… **Deployed to Zilliqa testnet** with proper configuration  
âœ… **Verified deployment** on block explorer  
âœ… **Ready to claim achievement** with your transaction hash

**Next up:** Module 2.5.4 will cover comprehensive testing with time manipulation, edge cases, and security validation. You'll write tests that prove your contract handles all scenarios correctly!

Ready to test? Let's go! ðŸš€

