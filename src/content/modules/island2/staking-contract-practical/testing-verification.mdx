---
id: testing-verification
module: staking-contract-practical
number: 2.5.4
title: Testing and Verification
objective: >-
  Write comprehensive tests for your staking contract using Hardhat 3, including time manipulation, edge cases, security scenarios, and block explorer verification.
slug: testing-verification
---

## Testing Strategy

Your staking contract handles real value and complex time-based logic. Before deploying to mainnet, you need tests that prove:

- ‚úÖ **Deposits work** for all duration tiers
- ‚úÖ **Rewards calculate correctly** over time
- ‚úÖ **Withdrawals handle** early vs normal cases properly
- ‚úÖ **Penalties and fees** apply correctly
- ‚úÖ **Edge cases** don't break the contract
- ‚úÖ **Security** against reentrancy and other attacks

This lesson provides a complete test suite you can run with:
```bash
npx hardhat test
```

## Test Environment Setup

### Install Testing Dependencies

**Already installed from Module 2.3:**
- Hardhat Toolbox (includes Chai assertions, time helpers)
- TypeScript support

### Create Test File Structure

For this module, we'll use a single comprehensive file: `test/Staking.test.ts`

## Complete Test Suite

### test/Staking.test.ts

```typescript
import assert from "node:assert/strict";
import { describe, it } from "node:test";
import { parseEther, getAddress } from "viem";
import { network } from "hardhat";

describe("Staking Contract", async function () {
  const { viem, networkHelpers } = await network.connect();
  const [owner, user1, user2, feeCollector] = await viem.getWalletClients();
  
  it("Should deploy TestToken successfully", async function () {
    const token = await viem.deployContract("TestToken", []);
    
    assert.equal(await token.read.name(), "Test Token");
    assert.equal(await token.read.symbol(), "TEST");
    assert.equal(await token.read.totalSupply(), 1000000n * 10n**18n);
  });
  
  it("Should deploy Staking contract with correct initial state", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    assert.equal(getAddress(await staking.read.stakingToken()), getAddress(token.address));
    assert.equal(getAddress(await staking.read.claimant()), getAddress(owner.account.address));
    assert.equal(await staking.read.apy1(), 10n);
    assert.equal(await staking.read.apy2(), 15n);
    assert.equal(await staking.read.apy3(), 27n);
    assert.equal(await staking.read.exitPenaltyPerc(), 5n);
    assert.equal(await staking.read.withdrawFee(), 2n);
    assert.equal(await staking.read.totalStaked(), 0n);
    assert.equal(await staking.read.startedTimestamp(), 0n);
  });
  
  it("Should allow owner to start rewards", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await staking.write.startReward();
    const started = await staking.read.startedTimestamp();
    assert.ok(started > 0n);
  });
  
  it("Should not allow starting rewards twice", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await staking.write.startReward();
    await assert.rejects(
      async () => await staking.write.startReward(),
      /Can only start rewards once/
    );
  });
  
  it("Should allow user to deposit", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    const userStaked = await staking.read.getStakedTokens([user1.account.address]);
    assert.equal(userStaked, amount);
    
    const depositCount = await staking.read.getStakedItemLength([user1.account.address]);
    assert.equal(depositCount, 1n);
    
    const totalStaked = await staking.read.totalStaked();
    assert.equal(totalStaked, amount);
  });
  
  it("Should reject deposit with invalid option", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    
    await assert.rejects(
      async () => await staking.write.deposit([amount, 4n], { account: user1.account }),
      /Invalid Option/
    );
  });
  
  it("Should reject deposit with zero amount", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await assert.rejects(
      async () => await staking.write.deposit([0n, 1n], { account: user1.account }),
      /Invalid Amount/
    );
  });
  
  it("Should allow withdrawal after deposit", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.transfer([staking.address, parseEther("100000")]); // Fund contract
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    await staking.write.startReward();
    
    // Withdraw
    await staking.write.withdraw([0n], { account: user1.account });
    
    const depositCount = await staking.read.getStakedItemLength([user1.account.address]);
    assert.equal(depositCount, 0n);
  });
  
  it("Should update APY correctly", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await staking.write.updateApy([12n, 18n, 30n]);
    
    assert.equal(await staking.read.apy1(), 12n);
    assert.equal(await staking.read.apy2(), 18n);
    assert.equal(await staking.read.apy3(), 30n);
  });
  
  it("Should reject APY above 10000%", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await assert.rejects(
      async () => await staking.write.updateApy([10001n, 15n, 27n]),
      /APY must be below 10000%/
    );
  });
  
  it("Should handle multiple deposits correctly", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount * 3n]);
    await token.write.approve([staking.address, amount * 3n], { account: user1.account });
    
    // Make 3 deposits
    await staking.write.deposit([amount, 1n], { account: user1.account });
    await staking.write.deposit([amount, 2n], { account: user1.account });
    await staking.write.deposit([amount, 3n], { account: user1.account });
    
    const totalStaked = await staking.read.getStakedTokens([user1.account.address]);
    assert.equal(totalStaked, amount * 3n);
    
    const depositCount = await staking.read.getStakedItemLength([user1.account.address]);
    assert.equal(depositCount, 3n);
  });
  
  it("Should calculate rewards correctly after 30 days", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    // Start rewards
    await staking.write.startReward();
    
    // Fast forward 30 days
    await networkHelpers.time.increase(30 * 24 * 60 * 60);
    
    const reward = await staking.read.getStakedItemReward([user1.account.address, 0n]);
    
    // Expected: (1000 * 10% APY * 30 days) / 365 days
    const expected = (amount * 10n * 30n * 86400n) / 100n / (365n * 86400n);
    
    // Allow small rounding difference (within 0.01%)
    const diff = reward > expected ? reward - expected : expected - reward;
    const tolerance = amount / 10000n; // 0.01% of deposit
    assert.ok(diff < tolerance, `Reward ${reward} should be close to expected ${expected}, diff: ${diff}`);
  });
  
  it("Should cap rewards at lock duration", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account }); // 30 day lock
    
    await staking.write.startReward();
    
    // Fast forward 60 days (double the lock period)
    await networkHelpers.time.increase(60 * 24 * 60 * 60);
    
    const reward = await staking.read.getStakedItemReward([user1.account.address, 0n]);
    
    // Should only accrue for 30 days, not 60
    const expected30 = (amount * 10n * 30n * 86400n) / 100n / (365n * 86400n);
    
    const diff = reward > expected30 ? reward - expected30 : expected30 - reward;
    const tolerance = amount / 10000n;
    assert.ok(diff < tolerance, `Reward should be capped at 30 days worth: ${reward} vs ${expected30}`);
  });
  
  it("Should apply penalty on early withdrawal", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.transfer([staking.address, parseEther("100000")]); // Fund contract
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    await staking.write.startReward();
    
    // Wait only 10 days (less than 30-day lock)
    await networkHelpers.time.increase(10 * 24 * 60 * 60);
    
    const tokenBalanceBefore = await token.read.balanceOf([user1.account.address]);
    
    // Withdraw early
    await staking.write.withdraw([0n], { account: user1.account });
    
    const tokenBalanceAfter = await token.read.balanceOf([user1.account.address]);
    const received = tokenBalanceAfter - tokenBalanceBefore;
    
    // Should receive principal minus 5% penalty, no rewards
    const expected = amount - (amount * 5n / 100n);
    assert.equal(received, expected, "Should receive 95% of deposit on early withdrawal");
  });
  
  it("Should pay rewards on normal withdrawal after maturity", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    // Fund AFTER deposit so totalStaked is correct
    await token.write.transfer([staking.address, parseEther("100000")]); // Fund contract with rewards
    
    await staking.write.startReward();
    
    // Wait full 30 days
    await networkHelpers.time.increase(30 * 24 * 60 * 60);
    
    const tokenBalanceBefore = await token.read.balanceOf([user1.account.address]);
    
    // Withdraw after maturity
    await staking.write.withdraw([0n], { account: user1.account });
    
    const tokenBalanceAfter = await token.read.balanceOf([user1.account.address]);
    const received = tokenBalanceAfter - tokenBalanceBefore;
    
    // Expected: principal - 2% fee + rewards
    const fee = amount * 2n / 100n;
    const expectedReward = (amount * 10n * 30n * 86400n) / 100n / (365n * 86400n);
    const expected = amount - fee + expectedReward;
    
    // Allow some tolerance for rounding
    const diff = received > expected ? received - expected : expected - received;
    const tolerance = amount / 1000n; // 0.1% tolerance
    assert.ok(diff < tolerance, `Received ${received} should be close to ${expected}, diff: ${diff}`);
  });
  
  it("Should send withdrawal fee to fee address", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.transfer([staking.address, parseEther("100000")]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    await staking.write.startReward();
    await networkHelpers.time.increase(30 * 24 * 60 * 60);
    
    const feeBalanceBefore = await token.read.balanceOf([feeCollector.account.address]);
    
    // Withdraw
    await staking.write.withdraw([0n], { account: user1.account });
    
    const feeBalanceAfter = await token.read.balanceOf([feeCollector.account.address]);
    const feeReceived = feeBalanceAfter - feeBalanceBefore;
    
    // Expected fee: 2% of deposit
    const expectedFee = amount * 2n / 100n;
    assert.equal(feeReceived, expectedFee, "Fee collector should receive 2% withdrawal fee");
  });
  
  it("Should handle rewards starting after deposit", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    // Wait 10 days before starting rewards
    await networkHelpers.time.increase(10 * 24 * 60 * 60);
    
    // Now start rewards
    await staking.write.startReward();
    
    // Wait another 10 days
    await networkHelpers.time.increase(10 * 24 * 60 * 60);
    
    const reward = await staking.read.getStakedItemReward([user1.account.address, 0n]);
    
    // Should only count the 10 days AFTER rewards started, not the 10 before
    const expected10 = (amount * 10n * 10n * 86400n) / 100n / (365n * 86400n);
    
    const diff = reward > expected10 ? reward - expected10 : expected10 - reward;
    const tolerance = amount / 10000n;
    assert.ok(diff < tolerance, `Reward should only count days after startReward: ${reward} vs ${expected10}`);
  });
  
  it("Should handle withdrawal with swap-and-pop correctly", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount * 3n]);
    await token.write.transfer([staking.address, parseEther("100000")]);
    await token.write.approve([staking.address, amount * 3n], { account: user1.account });
    
    // Make 3 deposits
    await staking.write.deposit([amount, 1n], { account: user1.account }); // index 0
    await staking.write.deposit([amount, 2n], { account: user1.account }); // index 1
    await staking.write.deposit([amount, 3n], { account: user1.account }); // index 2
    
    await staking.write.startReward();
    await networkHelpers.time.increase(35 * 24 * 60 * 60); // Mature first deposit
    
    // Withdraw first deposit (index 0) - should use swap-and-pop
    await staking.write.withdraw([0n], { account: user1.account });
    
    // Should have 2 deposits remaining
    const depositCount = await staking.read.getStakedItemLength([user1.account.address]);
    assert.equal(depositCount, 2n);
    
    // Total staked should be 2000
    const totalStaked = await staking.read.getStakedTokens([user1.account.address]);
    assert.equal(totalStaked, amount * 2n);
  });

  it("Should allow owner to stop rewards", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await staking.write.startReward();
    const startedBefore = await staking.read.startedTimestamp();
    assert.ok(startedBefore > 0n, "Rewards should be started");
    
    await staking.write.stopReward();
    
    const startedAfter = await staking.read.startedTimestamp();
    assert.equal(startedAfter, 0n, "Rewards should be stopped");
    
    // Check APYs are reset
    const apy1 = await staking.read.apy1();
    const apy2 = await staking.read.apy2();
    const apy3 = await staking.read.apy3();
    assert.equal(apy1, 0n);
    assert.equal(apy2, 0n);
    assert.equal(apy3, 0n);
  });

  it("Should calculate rewardsRemaining correctly", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const depositAmount = parseEther("1000");
    await token.write.transfer([user1.account.address, depositAmount]);
    await token.write.approve([staking.address, depositAmount], { account: user1.account });
    await staking.write.deposit([depositAmount, 1n], { account: user1.account });
    
    // Before funding: rewardsRemaining should be 0
    const rewardsBefore = await staking.read.rewardsRemaining();
    assert.equal(rewardsBefore, 0n);
    
    // Fund with rewards
    const rewardAmount = parseEther("10000");
    await token.write.transfer([staking.address, rewardAmount]);
    
    // After funding: should show available rewards
    const rewardsAfter = await staking.read.rewardsRemaining();
    assert.equal(rewardsAfter, rewardAmount, "Should show correct available rewards");
  });

  it("Should allow owner to update exit penalty", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const newPenalty = 10n;
    await staking.write.updateExitPenalty([newPenalty]);
    
    const penalty = await staking.read.exitPenaltyPerc();
    assert.equal(penalty, newPenalty);
  });

  it("Should reject exit penalty above 20%", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    try {
      await staking.write.updateExitPenalty([21n]);
      assert.fail("Should have reverted");
    } catch (error: any) {
      assert.ok(error.message.includes("May not set higher than 20%"));
    }
  });

  it("Should reject updateFee with zero address", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    try {
      await staking.write.updateFee(["0x0000000000000000000000000000000000000000", 2n]);
      assert.fail("Should have reverted");
    } catch (error: any) {
      assert.ok(error.message.includes("Invalid fee address"));
    }
  });

  it("Should reject updateFee above 10%", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    try {
      await staking.write.updateFee([user2.account.address, 11n]);
      assert.fail("Should have reverted");
    } catch (error: any) {
      assert.ok(error.message.includes("Fee cannot exceed 10%"));
    }
  });

  it("Should handle rewardsRemaining when totalStaked exceeds balance", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const depositAmount = parseEther("1000");
    await token.write.transfer([user1.account.address, depositAmount]);
    await token.write.approve([staking.address, depositAmount], { account: user1.account });
    await staking.write.deposit([depositAmount, 1n], { account: user1.account });
    
    // Don't fund rewards - totalStaked > balance
    const rewards = await staking.read.rewardsRemaining();
    assert.equal(rewards, 0n, "Should return 0 when no rewards available");
  });

  it("Should successfully update fee address and percentage", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const newFeeAddr = user2.account.address;
    const newFee = 5n;
    await staking.write.updateFee([newFeeAddr, newFee]);
    
    const feeAddress = await staking.read.feeAddress();
    const withdrawFee = await staking.read.withdrawFee();
    
    assert.equal(getAddress(feeAddress), getAddress(newFeeAddr));
    assert.equal(withdrawFee, newFee);
  });

  it("Should cap rewards when reward pool is insufficient", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("10000"); // Large deposit
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    // Fund with only 10 tokens (much less than expected rewards)
    await token.write.transfer([staking.address, parseEther("10")]);
    
    await staking.write.startReward();
    await networkHelpers.time.increase(30 * 24 * 60 * 60);
    
    const tokenBalanceBefore = await token.read.balanceOf([user1.account.address]);
    await staking.write.withdraw([0n], { account: user1.account });
    const tokenBalanceAfter = await token.read.balanceOf([user1.account.address]);
    
    const received = tokenBalanceAfter - tokenBalanceBefore;
    
    // Should receive principal - fee + capped rewards (only 10 tokens)
    const fee = amount * 2n / 100n;
    const maxPossible = amount - fee + parseEther("10");
    
    // Received should be close to maxPossible (rewards were capped)
    const diff = received > maxPossible ? received - maxPossible : maxPossible - received;
    assert.ok(diff < parseEther("0.01"), "Rewards should be capped to available pool");
  });

  it("Should return 0 reward when deposit made after rewards started but immediately checked", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    await staking.write.startReward();
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    // Check reward immediately (dt = 0 or very small)
    const reward = await staking.read.getStakedItemReward([user1.account.address, 0n]);
    
    // Reward should be 0 or very close to 0 since no time has passed
    assert.ok(reward < parseEther("0.01"), "Reward should be negligible with no time elapsed");
  });

  it("Should handle deposit time before reward start time", async function () {
    const token = await viem.deployContract("TestToken", []);
    const staking = await viem.deployContract("Staking", [
      token.address,
      feeCollector.account.address,
      owner.account.address
    ]);
    
    const amount = parseEther("1000");
    await token.write.transfer([user1.account.address, amount]);
    await token.write.approve([staking.address, amount], { account: user1.account });
    
    // Deposit BEFORE starting rewards
    await staking.write.deposit([amount, 1n], { account: user1.account });
    
    // Wait 5 days, then start rewards
    await networkHelpers.time.increase(5 * 24 * 60 * 60);
    await staking.write.startReward();
    
    // Wait another 15 days
    await networkHelpers.time.increase(15 * 24 * 60 * 60);
    
    const reward = await staking.read.getStakedItemReward([user1.account.address, 0n]);
    
    // Reward should only count 15 days (after start), not the 5 days before
    const expected15Days = (amount * 10n * 15n * 86400n) / 100n / (365n * 86400n);
    const diff = reward > expected15Days ? reward - expected15Days : expected15Days - reward;
    
    assert.ok(diff < amount / 10000n, "Should only accrue rewards after startReward was called");
  });
});
```

## Running the Tests

### Run Full Test Suite

NOTE: ensure you have hardhat running locally on another terminal with  'npx hardhat node'

```bash
EXPORT HARDHAT_NETWORK=hardhatMainnet
npx hardhat test
```

**Expected output:**
```
  Staking Contract
    ‚úî Should deploy TestToken successfully (333ms)
    ‚úî Should deploy Staking contract with correct initial state (571ms)
    ‚úî Should allow owner to start rewards (363ms)
    ‚úî Should not allow starting rewards twice (511ms)
    ‚úî Should allow user to deposit (756ms)
    ‚úî Should reject deposit with invalid option (501ms)
    ‚úî Should reject deposit with zero amount (425ms)
    ‚úî Should allow withdrawal after deposit (828ms)
    ‚úî Should update APY correctly (393ms)
    ‚úî Should reject APY above 10000% (341ms)
    ‚úî Should handle multiple deposits correctly (756ms)
    ‚úî Should calculate rewards correctly after 30 days (848ms)
    ‚úî Should cap rewards at lock duration (751ms)
    ‚úî Should apply penalty on early withdrawal (1055ms)
    ‚úî Should pay rewards on normal withdrawal after maturity (1130ms)
    ‚úî Should send withdrawal fee to fee address (1110ms)
    ‚úî Should handle rewards starting after deposit (1127ms)
    ‚úî Should handle withdrawal with swap-and-pop correctly (1252ms)
    ‚úî Should allow owner to stop rewards (584ms)
    ‚úî Should calculate rewardsRemaining correctly (769ms)
    ‚úî Should allow owner to update exit penalty (406ms)
    ‚úî Should reject exit penalty above 20% (378ms)
    ‚úî Should reject updateFee with zero address (351ms)
    ‚úî Should reject updateFee above 10% (410ms)
    ‚úî Should handle rewardsRemaining when totalStaked exceeds balance (653ms)
    ‚úî Should successfully update fee address and percentage (393ms)
    ‚úî Should cap rewards when reward pool is insufficient (1023ms)
    ‚úî Should return 0 reward when deposit made after rewards started but immediately checked (749ms)
    ‚úî Should handle deposit time before reward start time (882ms)


  29 passing (61661ms)
```

## Test Coverage

### Run Coverage Report

```bash
npx hardhat test --coverage
```

**Expected output:**
```
| File Path üì¶            | Line % üìà | Statement % üìà | Uncovered Lines üîç | Partially Covered Lines üîç |
| ----------------------- | --------- | -------------- | ------------------ | -------------------------- |
| contracts/Staking.sol   | 100.00    | 98.25          | -                  | 79, 169                    |
| contracts/TestToken.sol | 100.00    | 100.00         | -                  | -                          |
| ----------------------- | --------- | -------------- | ------------------ | -------------------------- |
| Total                   | 100.00    | 98.26          |                    |                            |
```

**Target:**
- Statement coverage: > 95%
- Line coverage: > 95%

## Pre-Mainnet Checklist

Before deploying to mainnet, ensure:

- [ ] **All tests passing** with 100% success rate (29 tests)
- [ ] **Coverage >95%** for statements and branches
- [ ] **Critical bug fixes verified:** Reward calculation before state updates, availableRewards before totalStaked decrement
- [ ] **Gas optimization** reviewed (deploy cost, swap-and-pop array removal)
- [ ] **Time calculations verified** manually with calculator
- [ ] **Edge cases tested:** zero amounts, max values, boundary conditions, reward pool insufficiency
- [ ] **Security validations:** ReentrancyGuard, SafeERC20, fee/penalty caps, zero address checks
- [ ] **Testnet deployed** and tested with real users
- [ ] **Admin functions** tested and documented (startReward, stopReward, updateApy, updateFee, updateExitPenalty)
- [ ] **Emergency procedures** in runbook
- [ ] **Block explorer** verification successful
- [ ] **Centralization risks** documented and communicated to users

## Wrap-Up

You've completed comprehensive testing of your staking contract with **29 passing tests**:

‚úÖ **Deployment tests** verify initialization with proper validation  
‚úÖ **Deposit tests** cover all tiers (30/60/120 days) and edge cases  
‚úÖ **Reward calculations** tested with time manipulation and capping logic  
‚úÖ **Withdrawal tests** for early (penalty) and normal (rewards + fees) scenarios  
‚úÖ **Multiple deposits** handled correctly with swap-and-pop optimization  
‚úÖ **Admin functions** protected and validated (APY caps, fee caps, penalty caps)  
‚úÖ **Security** against reentrancy, overflow, and reward pool exhaustion  
‚úÖ **Edge cases** covered: rewards starting before/after deposits, insufficient reward pools, zero amounts  
‚úÖ **Critical bug fixes** validated: calculation order dependencies

**What You've Achieved:**  
üîí **Battle-Tested Security** - Comprehensive tests prove security measures work  
‚ö° **Gas-Optimized** - Swap-and-pop array removal saves gas on withdrawals  
üìä **Full Coverage** - 98%+ coverage ensures no blind spots  
üõ°Ô∏è **Fail-Safe Design** - Users always get their principal back, rewards are capped to available pool

**Congratulations!** You've built, tested, and deployed a staking contract on Zilliqa! üéâ

**Module Complete:** Submit your deployment transaction hash to claim your Island 2 achievement and showcase your advanced Solidity skills!

