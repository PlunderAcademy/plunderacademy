---
id: intro-to-staking-contracts
module: staking-contract-practical
number: 2.5.1
title: Introduction to Staking Contracts
objective: >-
  Understand staking mechanics, plan your staking token strategy, and prepare to build a production-ready staking contract with duration tiers and reward calculations.
slug: intro-to-staking-contracts
---

## What Is Token Staking?

### The Core Concept

**Real-world analogy:** Think of staking like a Certificate of Deposit (CD) at a bank. You lock money for 6 months, 1 year, or 2 years, and earn interest based on how long you commit. The bank pays higher rates for longer commitments because they can plan around having your funds available.

**In crypto, staking works similarly:**
- Users **lock tokens** for a fixed period (30, 60, or 120 days)
- They **earn rewards** proportional to:
  - Amount staked
  - Duration of the lock
  - APY (Annual Percentage Yield) for that duration tier
- **Early withdrawal** incurs a penalty
- **Normal withdrawal** (after lock period) returns principal + rewards

### Why Build a Staking Contract?

**Common use cases:**
- **Community engagement:** Reward long-term holders
- **Liquidity locking:** Reduce circulating supply during launches
- **Governance alignment:** Longer stakers = more committed voters
- **Yield generation:** Provide passive income to token holders
- **Protocol TVL:** Total Value Locked attracts attention and trust

**Real examples:**
- **Zilliqa  2.0:** Stake ZIL to secure the network, earn ~12% APY
- **Kalijo (https://stake.kalijo.io/):** Lock SEED for 30/90/365 days for 2/5/12% apy PLUS additional $kUSD rewards
- Many other examples like ETH staking, Curve, etc.


## The Staking Contract We'll Build

### Key Features

**Your production-ready staking contract will include:**

âœ… **Multiple duration tiers:**
- 30-day lock â†’ 10% APY
- 60-day lock â†’ 15% APY  
- 120-day lock â†’ 27% APY

âœ… **Multiple deposits per user:**
- Alice can stake 1000 tokens for 30 days on Jan 1st
- Then stake another 500 tokens for 60 days on Jan 15th
- Each deposit tracked independently with its own timeline

âœ… **Fair reward calculations:**
- Rewards accrue per-second based on elapsed time
- Capped at the lock duration (no extra rewards for waiting longer)
- Uses safe integer math to avoid precision loss

âœ… **Early withdrawal penalties:**
- Withdraw before lock ends â†’ 5% penalty, no rewards
- Withdraw after lock ends â†’ 2% fee, full rewards paid

âœ… **Global reward controls:**
- Owner can start/stop reward accrual
- Owner can adjust APY rates for new deposits
- Existing deposits keep their original rates

âœ… **Battle-tested security:**
- OpenZeppelin SafeERC20 (handles non-standard tokens)
- ReentrancyGuard (prevents reentrancy attack vectors)
- Ownable (admin controls)
- Math.mulDiv() (overflow-safe reward calculations)
- Solidity 0.8.28+ built-in overflow checks

### Contract Architecture Overview

**What's inside the contract:**

**State Variables:**
- Token addresses (what token users stake)
- APY rates for each tier (10%, 15%, 27%)
- Penalty and fee percentages
- Total amount staked across all users

**User Data Tracking:**
- Each user has a `UserInfo` containing:
  - Total amount they've staked
  - Array of individual deposits (each with its own APY, duration, amount, timestamp)

**Main Functions:**
- `deposit()` - Lock tokens and choose duration tier
- `withdraw()` - Get tokens back (with or without rewards)
- `startReward()` - Owner turns on reward accrual
- `updateApy()` - Owner adjusts rates for new deposits

## Understanding the Data Structures

### DepositItem: Individual Stake Records

```solidity
struct DepositItem {
    uint256 apy;        // 10, 15, or 27 (representing percentage)
    uint256 duration;   // 30 days, 60 days, or 120 days
    uint256 amount;     // Tokens in this specific deposit
    uint256 timestamp;  // When this deposit was made
}
```

**Why track each deposit separately?**
- Different deposits can have different lock periods
- APY rates might change over time; old deposits keep their rate
- Users can withdraw individual deposits when they mature
- Simplifies reward calculation (one deposit at a time)

**Example user journey:**
```javascript
// Day 0: Alice deposits 1000 tokens for 30 days
depositItems[0] = {
  apy: 10,
  duration: 30 days,
  amount: 1000,
  timestamp: 1704067200  // Jan 1, 2024
}

// Day 10: Alice deposits another 500 tokens for 60 days
depositItems[1] = {
  apy: 15,
  duration: 60 days,
  amount: 500,
  timestamp: 1704931200  // Jan 11, 2024
}

// Day 35: Alice's first deposit matured (30 days passed)
// She can withdraw index 0 with full rewards
// Her second deposit still has 25 days remaining
```

### UserInfo: Per-User Aggregation

```solidity
struct UserInfo {
    uint256 amount;             // Total across all active deposits
    DepositItem[] depositItems; // Array of individual stakes
}

mapping(address => UserInfo) private userInfo;
```

**Why both `amount` and `depositItems`?**
- `amount` = quick lookup of total staked (useful for UI dashboards)
- `depositItems` = detailed breakdown for reward calculations
- When a user withdraws, both are updated (amount decreases, item removed from array)

## Planning Your Staking Token

### Choosing Your Staking Token

**You have several options for what token users will stake:**

#### Option 1: Use an Existing Token
**Best for:** Established projects with existing token holders

```solidity
// In constructor, reference an existing deployed token
constructor(address tokenAddr, address feeAddr, address _claimant) {
    stakingToken = IERC20(tokenAddr);
    rewardToken = stakingToken;  // Same token for staking and rewards
    claimant = _claimant;  // For achievement verification
    // ...
}
```

**Deployment:**
```bash
# Deploy staking contract pointing to existing token
npx hardhat run scripts/deploy-staking.ts --network zilliqaTestnet
# Provide existing token address: 0xYourTokenAddress
```

#### Option 2: Deploy a New Token First
**Best for:** New projects or learning (what we'll demonstrate)

**Steps:**
1. Deploy an ERC20 token (from Module 1.5 - Island 1)
2. Deploy the staking contract pointing to that token
3. Transfer reward tokens to the staking contract
4. Users can now stake

**Example workflow:**
```bash
# Step 1: Deploy your ERC20 token
npm run deploy:token

# Step 2: Deploy staking contract with that token address
npm run deploy:staking

# Step 3: Transfer reward tokens to staking contract
npm run fund:staking
```

#### Option 3: Use the Same Token for Different Networks
**Best for:** Multi-chain projects

You can deploy the same staking contract on:
- Zilliqa Testnet (for learning and testing)
- Zilliqa Mainnet (for production)
- Other EVM chains (Ethereum, Polygon, BSC, etc.)

### Token Economics Considerations

**Before deploying, plan your tokenomics:**

#### Reward Pool Size
**How many tokens will you allocate for staking rewards?**

Example calculation:
- Total supply: 1,000,000 tokens
- Reward pool: 100,000 tokens (10%)
- Target TVL: 500,000 tokens staked
- Average APY: 15%
- Annual rewards needed: 500,000 Ã— 0.15 = 75,000 tokens âœ… (fits in pool)

#### Sustainability
**How long should rewards last?**

```
Reward Pool: 100,000 tokens
Annual payout at max TVL: 75,000 tokens
Duration: 100,000 / 75,000 = 1.33 years
```

**Options to extend:**
- Gradually decrease APY rates
- Add more tokens to reward pool
- Implement reward halving (like Bitcoin)
- Use protocol fees to replenish rewards

#### Claimant Address for Achievements

**Important for this training module:**

Your staking contract will include a `claimant` address for achievement verification:

```solidity
address public claimant;  // Set in constructor

constructor(address tokenAddr, address feeAddr, address _claimant) {
    stakingToken = IERC20(tokenAddr);
    rewardToken = stakingToken;
    feeAddress = feeAddr;
    claimant = _claimant;  // Your training portal wallet
    // ...
}
```

**This lets us verify:**
- You successfully deployed the contract
- You understand constructor parameters
- You can claim achievement credit for completing the module

## Why This Design?

### One Contract vs Multiple Contracts

**Our approach: Everything in one contract**
```solidity
import "@openzeppelin/contracts/utils/math/Math.sol";

contract Staking is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    // State: tokens, rates, user deposits, claimant
    // Logic: deposit, withdraw, calculate rewards (using Math.mulDiv)
    // Admin: start/stop, update rates (with safety caps)
}
```

**Why this is good for learning:**
- âœ… See the complete flow in one place
- âœ… Easier to understand how pieces connect
- âœ… Lower gas costs (no cross-contract calls)
- âœ… Simpler to audit and deploy
- âœ… Used by many production protocols

**Advanced alternative: Split into multiple contracts**
- One contract for storage, another for logic, another for rewards
- More flexible (can upgrade logic without migrating data)
- Better for large teams (different people work on different contracts)
- Higher complexity and gas costs

**For this module:** We use the unified approach because it's clearer, cheaper, and battle-tested. Many successful protocols use this exact pattern!

## What You'll Build in This Module

### Module Roadmap

**2.5.1 (This Lesson):** Introduction and Planning
- âœ… Understand staking mechanics
- âœ… Review contract features and architecture
- âœ… Plan your staking token strategy

**2.5.2:** Understanding the Staking Contract Code
- Deep dive into `DepositItem` and `UserInfo` structures
- Reward calculation logic (`_calculateReward`)
- Deposit flow with duration tiers
- Withdrawal flow with penalties and fees
- Interactive code exploration

**2.5.3:** Deployment with Hardhat 3
- Project setup (brief reference to Module 2.3)
- Writing deployment scripts with claimant integration
- Local testing with Hardhat node
- Zilliqa testnet deployment
- Achievement verification and claiming

**2.5.4:** Testing & Verification
- Comprehensive test suite using Hardhat
- Time manipulation with `time.increase()`
- Edge cases: early withdrawal, multiple deposits, reward caps
- Block explorer verification
- Security best practices

## Practice Your Understanding

Before moving to the next lesson, make sure you understand these key concepts:

**Think about these questions:**
- What's the difference between a 30-day stake at 10% APY vs a 120-day stake at 27% APY?
- Why might a user choose a shorter lock period even though it pays less?
- What happens if a user needs their tokens back before the lock period ends?

**Simple calculation practice:**

If Alice stakes 1000 tokens for 30 days at 10% APY and waits the full period:
- Annual reward would be: 1000 Ã— 10% = 100 tokens
- For 30 days: 100 Ã— (30/365) = approximately 8.22 tokens
- After 2% withdrawal fee: She gets back 1000 - 20 + 8.22 = **988.22 tokens**

Try this one yourself: If Bob stakes 5000 tokens for 60 days at 15% APY, how much does he earn? (Hint: follow the same pattern!)

**Key concept review:**
- âœ… Staking = locking tokens for a period to earn rewards
- âœ… Longer locks = higher APY rates
- âœ… Early withdrawal = penalty + no rewards
- âœ… Normal withdrawal = small fee + full rewards
- âœ… Each deposit is tracked separately (you can have multiple)

## Wrap-Up

You now understand:
- âœ… What staking contracts do and why they're valuable
- âœ… The architecture of our unified staking contract
- âœ… How `DepositItem` and `UserInfo` structures work
- âœ… Duration tiers, APY rates, and penalty systems
- âœ… Token economics and reward pool planning
- âœ… Key security considerations (reentrancy, SafeERC20, math precision)

**Next up:** In Module 2.5.2, we'll do a deep dive into the actual Solidity code, walking through every function and understanding exactly how deposits, withdrawals, and reward calculations work. Get ready to read real production code!

Ready to see the contract in action? Let's go! ðŸš€

