---
id: interface-design
module: advanced-solidity-foundations
number: 2.1.2
title: Interface Design and Implementation
objective: >-
  Design minimal, versioned interfaces and code to abstractions so your staking system can integrate any ERC20 safely. Practice safe external calls with try/catch and build testable modules using dependency inversion.
slug: interface-design
---

## Set the stage

Inheritance gives you code reuse within your own contracts; interfaces give you interoperability with the world. Think of an interface like a USB-C port: any device that follows the spec plugs in and works without the computer caring which brand it is. In Solidity, that means your staking contract can accept any conforming ERC20 token, integrate with any compliant reward distributor, and swap oracle providers—all without recompiling or redeploying your core logic.

For the staking arc we're building toward in Module 5, you'll need to hold tokens (any token), emit rewards (from pluggable modules), and maybe consult external price feeds. Interfaces let you define these boundaries once, test with mocks, and upgrade implementations independently. This lesson shows you how to design minimal, versioned interfaces that stay stable across upgrades and how to safely call them with `try/catch` and dependency inversion.

## Conceptual foundations

### Interfaces vs abstract contracts vs concrete contracts

| Type | State? | Implementation? | When to use |
|------|--------|----------------|-------------|
| **Interface** | No | No (only signatures, events, errors) | Define external APIs; maximum flexibility; swap implementations freely |
| **Abstract contract** | Yes (optional) | Partial (some functions implemented, some not) | Share common logic and state; force children to complete specific functions |
| **Concrete contract** | Yes | Full | Deploy as-is; no open extension points |

For staking:
- Use **interfaces** for tokens (`IERC20`), reward modules (`IRewardDistributor`), oracles (`IPriceFeed`)
- Use **abstract contracts** for shared staking logic (e.g., `BaseStaking` with hooks like `_beforeStake`)
- Use **concrete contracts** for final deployments (e.g., `FixedAPRStaking`, `TieredRewardStaking`)

### Mental model: contracts vs interfaces

Imagine a contract as a ship with a crew (internal implementation) and a set of portholes (public functions). An **interface** is a map of those portholes—where they are, what shape they have, what you can pass through them—but no details about the crew inside. When you code to an interface, you're saying: "I don't care how this ship works internally; I only care that it has a `transfer` porthole that accepts `(address, uint256)` and returns `bool`."

This decoupling is powerful:
- Your staking contract can work with *any* token that implements `IERC20`, from USDC to a governance token you haven't heard of yet
- You can test your contract with a mock token that always succeeds or always reverts, without deploying the real token
- You can upgrade the reward logic (swap `LinearRewardDistributor` for `TieredRewardDistributor`) without touching the staking core

### Dependency inversion: high-level depends on abstraction

**Dependency inversion** (a SOLID principle) says: high-level modules should depend on abstractions, not concrete implementations. In Solidity:
- ✅ `contract StakingVault { IERC20 public token; }` (depends on interface)
- ❌ `contract StakingVault { MyToken public token; }` (depends on concrete contract)

Why? If you depend on `MyToken`, you can *only* use `MyToken`. If you depend on `IERC20`, you can use any token. Dependency inversion makes your contract **open for extension, closed for modification**—you add new tokens or modules by deploying new implementations, not by rewriting the core.

### External vs public: gas and intent

- **`external`**: Callable only from outside the contract; arguments live in calldata (cheaper). Use in interfaces to signal "this is for external callers."
- **`public`**: Callable from outside *and* inside; arguments may be copied to memory (more gas). Use in contracts when you need internal calls.

**Default for interfaces**: Always `external`. It's cheaper and communicates intent clearly.

### Minimal surface: the smaller, the safer

Every function you add to an interface is a promise you must keep forever (or version carefully). Small interfaces are:
- Easier to audit (fewer attack surfaces)
- Easier to mock (less boilerplate in tests)
- Easier to version (fewer breaking changes)

**Heuristic**: If you can't justify a function in one sentence, don't add it. For `IRewardDistributor`, you need `pending(address) → uint256` (view rewards) and `claimRewards() → uint256` (claim them). That's it. Don't add `claimFor(address)`, `batchClaim(address[])`, `setRewardRate(uint256)` unless you have a specific use case and security plan.

### Versioning strategies

Interfaces are contracts too; once deployed and depended upon, they're hard to change. Versioning strategies:
- **Additive versioning**: `IThing` → `IThingV2 is IThing` (new functions added; old code still works)
- **Breaking versioning**: `IThing` → `IThingV2` (separate interface; old code must update)
- **Deprecation**: Mark old functions with `@deprecated` in NatSpec; add new ones; eventually remove

For staking, start with `IRewardDistributor`. If you need to add a batch claim function later, create `IRewardDistributorV2 is IRewardDistributor { function batchClaim(address[] calldata accounts) external; }`. Old consumers still work; new consumers can cast to `V2` if available.

<svg viewBox="0 0 600 280" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      {`.box { fill: var(--background); stroke: var(--border); stroke-width: 2; rx: 6; }
        .interface { fill: var(--primary); fill-opacity: 0.1; stroke: var(--primary); stroke-width: 2; }
        .impl { fill: var(--muted); fill-opacity: 0.1; stroke: var(--muted); stroke-width: 2; }
        .label { fill: var(--foreground); font-size: 12px; font-family: ui-monospace, monospace; }
        .arrow { stroke: var(--foreground); stroke-width: 2; fill: none; marker-end: url(#arr); }`}
    </style>
    <marker id="arr" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
      <polygon points="0 0, 10 3, 0 6" style={{fill: 'var(--foreground)'}} />
    </marker>
  </defs>
  {/* Staking Core */}
  <rect className="box" x="220" y="20" width="160" height="60" />
  <text className="label" x="300" y="50" textAnchor="middle">Staking Core</text>
  <text className="label" x="300" y="68" textAnchor="middle" style={{fontSize: '10px', fill: 'var(--muted-foreground)'}}>depends on:</text>
  {/* Interfaces */}
  <rect className="interface" x="50" y="130" width="140" height="50" />
  <text className="label" x="120" y="160" textAnchor="middle">IERC20</text>
  <path className="arrow" d="M 270 80 L 140 130" />
  <rect className="interface" x="230" y="130" width="140" height="50" />
  <text className="label" x="300" y="160" textAnchor="middle">IRewardDistributor</text>
  <path className="arrow" d="M 300 80 L 300 130" />
  <rect className="interface" x="410" y="130" width="140" height="50" />
  <text className="label" x="480" y="160" textAnchor="middle">IPriceFeed</text>
  <path className="arrow" d="M 330 80 L 460 130" />
  {/* Implementations */}
  <rect className="impl" x="50" y="210" width="140" height="50" />
  <text className="label" x="120" y="240" textAnchor="middle">USDC / WETH / ...</text>
  <path className="arrow" d="M 120 210 L 120 180" />
  <rect className="impl" x="230" y="210" width="140" height="50" />
  <text className="label" x="300" y="240" textAnchor="middle">LinearRewards</text>
  <path className="arrow" d="M 300 210 L 300 180" />
  <rect className="impl" x="410" y="210" width="140" height="50" />
  <text className="label" x="480" y="240" textAnchor="middle">ChainlinkOracle</text>
  <path className="arrow" d="M 480 210 L 480 180" />
</svg>

**Key insight**: The staking core never imports concrete token contracts, reward modules, or oracles. It only depends on interfaces. Implementations can be swapped, upgraded, or mocked without touching the core.

## Guided code walk-throughs

The following examples show how to design robust interfaces and integrate them safely into your staking system.

### 1) Minimal interface with NatSpec and custom errors

We define an `IRewardDistributor` interface that your staking core can call to compute and claim rewards. Notice the complete NatSpec documentation, minimal function surface (two functions only), and custom error for failure signaling.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/// @title IRewardDistributor
/// @notice Minimal API for modules that calculate and release staking rewards
/// @dev Keep this surface small; extend via IRewardDistributorV2 if needed
interface IRewardDistributor {
    /// @notice Emitted when rewards are successfully claimed
    /// @param account The beneficiary who claimed
    /// @param amount The reward amount released
    event RewardsClaimed(address indexed account, uint256 amount);

    /// @notice Error thrown when insufficient rewards are available
    error InsufficientRewards();

    /// @notice Compute the pending unclaimed reward for an account
    /// @param account The staker's address
    /// @return amount The claimable reward in wei
    function pending(address account) external view returns (uint256 amount);

    /// @notice Claim all pending rewards for the caller
    /// @return amount The amount transferred to the caller
    /// @dev Reverts with InsufficientRewards if the pool is empty
    function claimRewards() external returns (uint256 amount);
}
```

**Takeaway**: An interface is a promise—no state, no constructors, no implementation. Just signatures, events, and errors. Your staking core can depend on this contract without caring whether rewards come from a fixed pool, a minting schedule, or an external treasury.

### 2) Dependency inversion: accept any token via `IERC20`

This vault accepts deposits of *any* ERC20 token specified at construction. By depending on `IERC20` (an interface) instead of a concrete token contract, we unlock flexibility: tests can inject mocks, users can stake any token, and future integrations require zero changes to the vault.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract FlexibleStakingVault {
    using SafeERC20 for IERC20;

    IERC20 public immutable stakingToken;
    mapping(address => uint256) public balanceOf;

    event Deposited(address indexed account, uint256 amount);
    event Withdrawn(address indexed account, uint256 amount);

    /// @param _token Any ERC20-compliant token (dependency inversion)
    constructor(IERC20 _token) {
        stakingToken = _token;
    }

    function deposit(uint256 amount) external {
        require(amount > 0, "ZERO_AMOUNT");
        balanceOf[msg.sender] += amount; // Effects
        stakingToken.safeTransferFrom(msg.sender, address(this), amount); // Interactions
        emit Deposited(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0 && amount <= balanceOf[msg.sender], "INVALID_AMOUNT");
        balanceOf[msg.sender] -= amount; // Effects
        stakingToken.safeTransfer(msg.sender, amount); // Interactions
        emit Withdrawn(msg.sender, amount);
    }
}
```

**Takeaway**: Depend on interfaces, not implementations. This vault works with USDC, WETH, or a governance token you haven't deployed yet. In tests, pass a mock token that reverts on transfer to verify error handling.

### 3) Testing with mocks: isolate dependencies

Interfaces make testing trivial. Here's a minimal mock `IRewardDistributor` for unit tests. You control exactly what it returns, without deploying complex reward logic.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract MockRewardDistributor {
    uint256 public mockPending;
    bool public shouldFail;

    event RewardsClaimed(address indexed account, uint256 amount);
    error InsufficientRewards();

    function setPending(uint256 amount) external { mockPending = amount; }
    function setShouldFail(bool _fail) external { shouldFail = _fail; }

    function pending(address) external view returns (uint256) {
        return mockPending;
    }

    function claimRewards() external returns (uint256) {
        if (shouldFail) revert InsufficientRewards();
        emit RewardsClaimed(msg.sender, mockPending);
        return mockPending;
    }
}
```

**Test strategy**:
1. **Happy path**: Set `mockPending = 1000`, call `claimRewards()`, assert success
2. **Failure path**: Set `shouldFail = true`, call `claimRewards()`, assert revert
3. **Zero rewards**: Set `mockPending = 0`, call `claimRewards()`, assert zero return

**Takeaway**: Mocks eliminate external dependencies. You test your staking logic in isolation, fast and deterministically. In production, swap the mock for the real `LinearRewardDistributor`.

## Practice and reflection

Apply these patterns to your staking design:

- **Surface audit**: Review `IRewardDistributor`. If you could only keep *one* function (either `pending` or `claimRewards`), which would you choose and why? Write two sentences defending your choice.
- **Versioning exercise**: Propose `IRewardDistributorV2` that adds a `batchClaim(address[] calldata accounts)` function. Write the new interface (inheriting from V1) and explain in one sentence why this is backward-compatible.
- **Token swap scenario**: Your protocol currently uses Token A. A governance vote decides to switch to Token B. List every on-chain change required if your vault depends on `IERC20` vs. a concrete `TokenA` contract. Which is simpler?
- **Mock design**: Sketch a mock `IERC20` contract that always reverts on `transferFrom`. How would you use this in a test to verify your vault's error handling?

{/* Concept Matching */}
<ConceptMatching pairs={[
  {"conceptId":"interface","definitionId":"def-interface","concept":"interface","definition":"No implementation; pure API boundary for integrations","category":"contracts"},
  {"conceptId":"abstract","definitionId":"def-abstract","concept":"abstract contract","definition":"Partial implementation; requires children to finish it","category":"contracts"},
  {"conceptId":"external","definitionId":"def-external","concept":"external","definition":"Callable only from outside; gas‑efficient for interfaces","category":"visibility"},
  {"conceptId":"public","definitionId":"def-public","concept":"public","definition":"Callable internally and externally; heavier ABI","category":"visibility"},
  {"conceptId":"di","definitionId":"def-di","concept":"dependency inversion","definition":"High‑level modules depend on interfaces, not concrete classes","category":"design"}
]}/>

Short reflection: If you had to explain dependency inversion to a non-technical stakeholder, what analogy would you use? Write two sentences.

## Security and pitfalls

Interfaces are low-risk by design (no state, no logic), but misuse at integration points introduces vulnerabilities.

### Interface design pitfalls

- **Over-promising**: Adding functions you might not need forces implementations to provide them (or revert). Keep surfaces minimal; extend with `V2` if needed.
- **Under-documenting**: Missing NatSpec means integrators guess behavior. Document preconditions, failure modes, and event semantics.
- **Breaking changes**: Renaming functions or reordering parameters breaks all consumers. Version interfaces instead (`IThingV2`).
- **No custom errors**: Generic reverts (`require(false)`) are hard to handle. Define `error InsufficientFunds()` etc. so callers can `try/catch` specific failures.

### Integration pitfalls

- **Trusting returns blindly**: Even well-designed interfaces can lie (malicious implementations). Always validate critical returns (e.g., balance checks after transfers).
- **No SafeERC20**: Raw `IERC20.transfer` doesn't revert on failure with non-standard tokens (e.g., USDT). Use `SafeERC20.safeTransfer`.
- **Silent failures**: If calling an interface that might revert, wrap in `try/catch` and emit events. Don't let external failures corrupt your state silently.
- **Skipping mocks in tests**: If you only test with real implementations, you miss edge cases (reverts, zero returns, reentrancy). Always write mock-based unit tests.

### Versioning pitfalls

- **Breaking inheritance**: If `IThingV2` changes signatures from `IThing`, old code breaks. Always make `V2` inherit `V1` and *add* functions.
- **No migration path**: Document how consumers detect which version a contract implements. Common pattern: expose `function version() external pure returns (string memory)`.

### Access control at boundaries

- **Who can set interfaces?**: If your staking contract has `setRewardDistributor(IRewardDistributor newDist)`, gate it with `onlyOwner` or a role. Otherwise anyone can point your contract at a malicious module.
- **Validate addresses**: When accepting an interface address in a setter, consider checking `newDist.supportsInterface(type(IRewardDistributor).interfaceId)` (EIP-165) or calling a view function to verify it's not a random address.

## Security checklist

Before shipping interface integrations:

- [ ] **Minimal function surface**: Only functions you actually need; no speculative additions
- [ ] **Complete NatSpec**: Every function, parameter, return value, and error documented
- [ ] **Custom errors defined**: Specific `error` types for each failure mode
- [ ] **All functions `external`**: Interfaces should never have `public` (wastes gas, unclear intent)
- [ ] **No state or constructors**: Interfaces are pure API contracts
- [ ] **Events with `indexed` subjects**: Critical for off-chain filtering
- [ ] **Versioning plan**: If you must add functions later, you'll use `IV2 is IV1` pattern
- [ ] **Dependency inversion**: High-level contracts depend on interfaces, not concrete contracts
- [ ] **SafeERC20 for tokens**: All `IERC20` calls use `safeTransfer` and `safeTransferFrom`
- [ ] **Try/catch on risky calls**: External interface calls that can fail are wrapped
- [ ] **Mock-based tests**: Unit tests use mocks to isolate logic; integration tests use real implementations
- [ ] **Access control on setters**: Functions that change interface dependencies are gated (`onlyOwner`, `onlyRole`)

## Wrap-up and next steps

You've learned how to design minimal, versioned interfaces that keep your staking system open for extension and closed for modification. You saw how dependency inversion (depending on `IERC20` instead of concrete tokens) unlocks flexibility and testability, and how mocks let you verify behavior in isolation. You also practiced `try/catch` for safe external calls and explored versioning strategies (`IV2 is IV1`) that keep old code working.

Next, you'll dive into events and libraries. Events make your interface observable for dashboards and analytics; libraries centralize reusable logic (APR calculations, fee math) without inflating storage. Combined with interfaces, they'll form the foundation of a modular, auditable staking system.

