---
id: events-libraries
module: advanced-solidity-foundations
number: 2.1.3
title: "Events and Libraries: Clean APIs and Cheaper State"
objective: >-
  Emit analytics‑friendly events and use stateless libraries to cut storage costs while keeping staking logic modular and testable.
slug: events-libraries
---

## Big picture

Events are your protocol’s telemetry—frontends, indexers, and analytics teams depend on them. Libraries are your protocol’s toolbox—pure, reusable helpers that keep storage lean and logic consistent. Together, they make staking flows observable and efficient without inflating on‑chain state.

For our staking arc, clear event schemas power dashboards (e.g., reward accruals per staker), and small libraries centralize math like fee calculations. That means cheaper contracts, easier audits, and happier integrators.

## Under the hood

- **Definition — Event**: A log record emitted by a transaction. **When to use it**: Announce consequential state changes for off‑chain consumers; never use events to gate critical logic.
- **Definition — `indexed` topic**: Up to three event parameters promoted to topics for efficient filtering. **When to use it**: Subjects you’ll query by (e.g., `account`, `token`).
- **Definition — Event schema stability**: Keeping event names/fields consistent release to release. **When to use it**: Always—breaking schemas breaks dashboards.
- **Definition — Library**: A collection of functions without persistent state. **When to use it**: Pure/view utilities shared across contracts (math, normalization, encoding).
- **Definition — `using for`**: Syntax to attach library functions to a type. **When to use it**: Readability and discoverability for common operations.
- **Definition — Gas trade‑offs**: Events are cheaper than storage for historical data; libraries avoid repeated code and reduce bytecode via reuse. **Common anti‑pattern**: Storing data you only need for analytics—emit an event instead.

## Snippets and examples

### 1) Design analytics‑friendly events and emit them correctly

We define events with consistent verbs and `indexed` subjects so indexers can filter efficiently. In the example, a vault announces deposits and withdrawals. The payloads are sized for analytics without encoding business‑critical logic.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract EventfulVault {
    using SafeERC20 for IERC20;

    IERC20 public immutable asset;
    mapping(address => uint256) public balanceOf;

    event Deposited(address indexed account, address indexed token, uint256 amount);
    event Withdrawn(address indexed account, address indexed token, uint256 amount);

    constructor(IERC20 _asset) { asset = _asset; }

    function deposit(uint256 amount) external {
        require(amount > 0, "ZERO_AMOUNT");
        balanceOf[msg.sender] += amount; // Effects
        asset.safeTransferFrom(msg.sender, address(this), amount); // Interactions
        emit Deposited(msg.sender, address(asset), amount);
    }

    function withdraw(uint256 amount) external {
        require(amount > 0 && amount <= balanceOf[msg.sender], "INVALID_AMOUNT");
        balanceOf[msg.sender] -= amount;
        asset.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, address(asset), amount);
    }
}
```

Takeaway: pick verbs (`Deposited`, `Withdrawn`) and `indexed` subjects (account, token) you’ll query by; keep payloads stable across releases.

### 2) Centralize math in a stateless library

Libraries keep your staking math consistent and testable. Here, `FeeMath` implements basis‑points math, and a consumer uses it to compute protocol fees without sprinkling the formula across contracts.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

library FeeMath {
    uint256 internal constant BPS_DENOMINATOR = 10_000;
    function fee(uint256 amount, uint256 feeBps) internal pure returns (uint256) {
        return (amount * feeBps) / BPS_DENOMINATOR;
    }
}

contract FeeConsumer {
    using FeeMath for uint256;

    event ProtocolFeeComputed(uint256 gross, uint256 feeBps, uint256 feeAmount);

    function quoteProtocolFee(uint256 gross, uint256 feeBps) external returns (uint256) {
        uint256 feeAmount = FeeMath.fee(gross, feeBps);
        emit ProtocolFeeComputed(gross, feeBps, feeAmount);
        return feeAmount;
    }
}
```

Takeaway: pure functions in libraries are easy to fuzz and reuse; one source of truth prevents drift.

## Practice and reflection

- Sketch an event schema for `RewardClaimed` with two `indexed` subjects and one payload value. Explain your indexing choices in one sentence.
- Identify one piece of data your staking app currently stores that could be event‑only. What would consumers lose if you moved it out of storage?

{/* Word Jumble */}
<WordJumble 
  word="INDEXED" 
  hint="Event topic used to filter by address or token" 
/>

Short reflection: Name one event you would add to improve your analytics dashboard and why.

## Pitfalls and tips

- **Events are not logic**: Never rely on events for authorization or invariants; they can be omitted in a revert and aren’t read on‑chain
- **Privacy**: Events are public; avoid emitting sensitive data
- **Schema stability**: Don’t rename fields lightly; version with new event names if needed
- **Library trust**: Keep libraries small and pure; avoid unexpected state writes via `delegatecall`
- **Gas**: Emitting many events per tx is costly; prefer one well‑structured event over many noisy ones

## Wrap‑up and next steps

You can now design stable, queryable event schemas and extract reusable math into libraries. Next, we’ll combine these with safe contract‑to‑contract calls so staking flows remain observable, modular, and resilient.

