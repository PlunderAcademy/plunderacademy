---
id: intro-to-rng-contracts
module: random-number-generator-practical
number: 4.5.1
title: Introduction to Random Number Generation
objective: >-
  Understand the challenges of on-chain randomness, learn about commit-reveal patterns, and explore practical use cases for verifiable random number generation.
slug: intro-to-rng-contracts
---

## Why Random Numbers Matter

Random number generation is fundamental to many blockchain applications:

- **Gaming & Lotteries**: Fair draws, loot drops, matchmaking
- **NFT Traits**: Randomized characteristics and rarity
- **DeFi Protocols**: Fair distribution, random selection
- **Governance**: Random validator selection, jury pools
- **Airdrops**: Fair participant selection

However, generating truly random numbers on a deterministic blockchain is one of the most challenging problems in smart contract development.

## The Challenge of On-Chain Randomness

### Why It's Hard

Blockchains are **deterministic systems** by design:

```solidity
// ‚ùå BAD: Predictable and manipulatable
function badRandom() public view returns (uint256) {
    return uint256(keccak256(abi.encodePacked(block.timestamp)));
}
```

**Problems with naive approaches:**

1. **Block Timestamp Manipulation**
   - Validators can manipulate timestamps within limits
   - Predictable in advance
   - Not secure for high-value randomness

2. **Block Hash Manipulation**
   - Validators can potentially withhold blocks
   - Only previous blocks are safe
   - Limited entropy

3. **User Input Only**
   - Users can predict outcomes
   - Selective participation attacks
   - Front-running vulnerabilities

### Attack Vectors

**Example: Lottery Attack**

```solidity
// Vulnerable lottery contract
function drawWinner() public returns (address) {
    uint256 random = uint256(blockhash(block.number - 1));
    uint256 winnerIndex = random % players.length;
    return players[winnerIndex];
}
```

**Attack scenario:**
1. Attacker calls `drawWinner()` in a transaction
2. Sees the outcome would be unfavorable
3. Reverts the transaction (no state change)
4. Only submits transaction when they win
5. Other players have no chance

## Solutions for Secure Randomness

### 1. Off-Chain Oracles (e.g., Chainlink VRF)

**How it works:**
- Request randomness from external oracle
- Oracle generates random number off-chain
- Cryptographic proof verifies randomness
- Oracle submits number + proof on-chain

**Pros:**
- Very secure
- Cryptographically verifiable
- Industry standard

**Cons:**
- Requires external service (centralization risk)
- Costs additional fees
- Multiple transactions needed
- Dependency on oracle availability

### 2. Commit-Reveal Pattern

**How it works:**
- Users commit to a future block (commitment phase)
- Wait for target block
- Reveal using block data (reveal phase)
- Combines user-specific and block entropy

**Pros:**
- Fully on-chain
- No external dependencies
- Cost-effective
- Fast (just 2 transactions)

**Cons:**
- Requires two transactions
- Short delay between commit and reveal
- Users must return to reveal

### 3. Multi-Party Computation (MPC)

**How it works:**
- Multiple parties contribute entropy
- No single party knows outcome
- Combined entropy generates random number

**Pros:**
- Decentralized
- Secure if enough participants

**Cons:**
- Complex implementation
- Requires coordination
- Gas intensive

## The Commit-Reveal Pattern (Our Approach)

We'll implement a **commit-reveal VRF** (Verifiable Random Function) that provides secure, verifiable randomness without external dependencies.

### How It Works

<table>
  <thead>
    <tr>
      <th>Phase</th>
      <th>Action</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Commit</strong></td>
      <td>User declares intent for future block</td>
      <td>Prevents outcome prediction</td>
    </tr>
    <tr>
      <td><strong>Wait</strong></td>
      <td>Wait for target block to be mined</td>
      <td>Ensures unpredictable block data</td>
    </tr>
    <tr>
      <td><strong>Reveal</strong></td>
      <td>Generate random number using block data</td>
      <td>Combines user + block entropy</td>
    </tr>
  </tbody>
</table>

### Security Properties

**1. Unpredictability**
- Future block properties are unknown at commit time
- Validators cannot predict without significant cost
- User-specific entropy prevents identical results

**2. Fairness**
- All values in range have equal probability
- No value is favored
- Mathematically provable fairness

**3. Verifiability**
- All entropy sources published in events
- Anyone can verify calculation
- Transparent and auditable

**4. Manipulation Resistance**
- Uses previous block hash (already finalized, cannot be manipulated)
- Combines multiple entropy sources
- Range committed upfront (prevents post-hoc selection)

### Entropy Sources

Our implementation combines three sources:

<table>
  <thead>
    <tr>
      <th>Source</th>
      <th>Purpose</th>
      <th>Security Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>msg.sender</code></td>
      <td>User-specific entropy</td>
      <td>Different users ‚Üí different results</td>
    </tr>
    <tr>
      <td><code>block.prevrandao</code></td>
      <td>Block randomness</td>
      <td>Unpredictable validator entropy</td>
    </tr>
    <tr>
      <td><code>blockhash(block.number - 1)</code></td>
      <td>Previous block hash</td>
      <td>Manipulation-resistant (finalized)</td>
    </tr>
  </tbody>
</table>

**Why these three?**

1. **User Address**: Ensures different users get different results even with identical blocks
2. **PREVRANDAO**: Provides strong block-level entropy (works excellently on Zilliqa 2.0)
3. **Previous Block Hash**: Cannot be manipulated by validators (already finalized and included in chain)

## Use Cases

### Gaming

```solidity
// Randomized loot drops
function openTreasureChest(uint256 chestId) external {
    require(canOpenChest(chestId), "Cannot open chest");
    
    // Commit to future randomness
    rng.commit(block.number + 10, 1, 100); // Range: 1-100
    
    // Later, reveal and determine loot
    uint256 roll = rng.reveal();
    
    if (roll >= 95) {
        // Legendary (5% chance)
        giveLegendaryItem(msg.sender);
    } else if (roll >= 75) {
        // Rare (20% chance)
        giveRareItem(msg.sender);
    } else {
        // Common (75% chance)
        giveCommonItem(msg.sender);
    }
}
```

### Fair Lotteries

```solidity
// Winner selection
function selectWinner() external onlyOwner {
    require(players.length > 0, "No players");
    
    // Commit to select winner
    rng.commit(block.number + 20, 1, players.length);
    
    // Later, reveal and transfer prize
    uint256 winnerIndex = rng.reveal() - 1; // Convert to 0-based index
    address winner = players[winnerIndex];
    
    payable(winner).transfer(prizePool);
}
```

### NFT Trait Generation

```solidity
// Random trait assignment
function mintNFTWithTraits(uint256 tokenId) external {
    // Commit for trait randomness
    rng.commit(block.number + 5, 1, 1000);
    
    // Later, generate traits
    uint256 traitSeed = rng.reveal();
    
    // Use seed to determine multiple traits
    uint256 background = (traitSeed % 10) + 1;
    uint256 eyes = ((traitSeed / 10) % 15) + 1;
    uint256 outfit = ((traitSeed / 100) % 20) + 1;
    
    setNFTTraits(tokenId, background, eyes, outfit);
}
```

### DeFi Distribution

```solidity
// Fair airdrop selection
function selectAirdropRecipients(uint256 count) external {
    require(eligibleUsers.length > 0, "No eligible users");
    
    for (uint256 i = 0; i < count; i++) {
        // Commit for each selection
        rng.commit(block.number + 10 + i, 1, eligibleUsers.length);
        
        // Later, reveal and airdrop
        uint256 selectedIndex = rng.reveal() - 1;
        address recipient = eligibleUsers[selectedIndex];
        
        token.transfer(recipient, airdropAmount);
    }
}
```

## Mathematical Fairness

### Distribution Analysis

Our contract uses a mathematically sound approach:

```solidity
function generateRandomNumber(
    uint256 randomNumber, 
    uint256 minRandom, 
    uint256 maxRandom
) internal pure returns (uint256) {
    uint256 range = maxRandom - minRandom + 1;
    return (randomNumber % range) + minRandom;
}
```

**Key properties:**

1. **Input Space**: 2^256 possible values (from keccak256)
2. **Output Range**: User-specified (1 to 2 billion max)
3. **Bias**: Negligible for all practical ranges

### Bias Analysis

<table>
  <thead>
    <tr>
      <th>Range Size</th>
      <th>Example</th>
      <th>Bias</th>
      <th>Practical Impact</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10</td>
      <td>1-10 (dice)</td>
      <td>8.64 √ó 10‚Åª‚Å∑‚Å∑</td>
      <td>None (69 orders of magnitude better than lottery)</td>
    </tr>
    <tr>
      <td>100</td>
      <td>1-100 (percentage)</td>
      <td>8.64 √ó 10‚Åª‚Å∑‚Å∂</td>
      <td>None (68 orders of magnitude better than lottery)</td>
    </tr>
    <tr>
      <td>1,000</td>
      <td>1-1000 (lottery)</td>
      <td>8.64 √ó 10‚Åª‚Å∑‚Åµ</td>
      <td>None (67 orders of magnitude better than lottery)</td>
    </tr>
    <tr>
      <td>2 billion</td>
      <td>Max range</td>
      <td>1.73 √ó 10‚Åª‚Å∂‚Å∏</td>
      <td>None (60 orders of magnitude better than lottery)</td>
    </tr>
  </tbody>
</table>

**Conclusion**: The bias is so small it's statistically irrelevant for any practical application.

## Comparison: Commit-Reveal vs Chainlink VRF

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Commit-Reveal (Our Approach)</th>
      <th>Chainlink VRF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Security</strong></td>
      <td>High (multiple entropy sources)</td>
      <td>Very High (cryptographic proof)</td>
    </tr>
    <tr>
      <td><strong>Cost</strong></td>
      <td>Low (only gas fees)</td>
      <td>High (gas + oracle fees)</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Fast (5-20 blocks)</td>
      <td>Slower (multiple confirmations)</td>
    </tr>
    <tr>
      <td><strong>Dependencies</strong></td>
      <td>None (fully on-chain)</td>
      <td>External oracle service</td>
    </tr>
    <tr>
      <td><strong>Complexity</strong></td>
      <td>Simple</td>
      <td>More complex integration</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Gaming, NFTs, fair selection</td>
      <td>High-value lotteries, critical applications</td>
    </tr>
  </tbody>
</table>

## What You'll Build

In this practical module, you'll create a production-ready random number generator contract with:

‚úÖ **Secure commit-reveal pattern**  
‚úÖ **Configurable random ranges** (1 to 2 billion)  
‚úÖ **Multiple entropy sources** for unpredictability  
‚úÖ **Fair distribution** (mathematically proven)  
‚úÖ **Event emission** for transparency  
‚úÖ **Commitment management** (cancel stale commitments)  
‚úÖ **Comprehensive test suite**  
‚úÖ **Zilliqa 2.0 deployment**  

## Module Structure

This practical is divided into four lessons:

1. **Introduction** (this lesson) - Understanding RNG challenges and solutions
2. **Understanding the Contract** - Deep dive into implementation details
3. **Deployment Setup** - Local testing and testnet deployment with Hardhat 3
4. **Testing & Verification** - Comprehensive test suite and security analysis

## Next Steps

Ready to dive into the contract implementation? In the next lesson, we'll explore the `ZilliqaRandomNumber2` contract in detail, covering:

- Contract architecture and storage
- Commitment system mechanics
- Security measures and validations
- Random number generation algorithm
- Event system for transparency

Let's build! üé≤

