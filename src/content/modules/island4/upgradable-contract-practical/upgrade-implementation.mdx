---
id: upgrade-implementation
module: upgradable-contract-practical
number: 4.6.5
title: Upgrading to V2 with Batch Submissions
objective: >-
  Implement TrainingRegistryV2 with batch voucher submission, safely upgrade the proxy, test state preservation, and verify gas savings.
slug: upgrade-implementation
---

## Upgrade Overview

Now comes the exciting part: **upgrading the live contract!** This is why we built it upgradeable in the first place.

**The problem: (This is a theoretical problem, for this example)**
- Users claim one achievement at a time
- Each submission costs gas (~150,000 gas)
- Heavy users completing 10 achievements pay 10x gas

**The solution:**
- Add batch submission: submit multiple achievements in one transaction
- Gas savings: ~70% for batch of 5 (from 750k to ~250k gas)
- Better UX: claim all achievements at once

**What you'll do:**
1. **Create TrainingRegistryV2** (add batch submission)
2. **Maintain storage layout** (append-only, adjust _gap)
3. **Deploy V2 implementation**
4. **Upgrade proxy** to point at V2
5. **Test state preservation** (V1 data intact)
6. **Verify gas savings** (measure improvement)

**Critical: This is a real upgrade pattern!** The exact process used to upgrade production contracts managing millions in value.

## Why Batch Submissions?

### Gas Cost Comparison

**V1 (Individual submissions):**
```
Claim 5 achievements:
  submitVoucher(1) ‚Üí 150,000 gas
  submitVoucher(2) ‚Üí 150,000 gas
  submitVoucher(3) ‚Üí 150,000 gas
  submitVoucher(4) ‚Üí 150,000 gas
  submitVoucher(5) ‚Üí 150,000 gas
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Total:           750,000 gas
```

**V2 (Batch submission):**
```
Claim 5 achievements:
  submitVoucherBatch([1,2,3,4,5]) ‚Üí 250,000 gas
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Total:                         250,000 gas
  
  Savings: 500,000 gas (67% reduction!)
```

**Why such savings?**
- Base transaction cost paid once (21,000 gas)
- Loop overhead amortized across all submissions
- Single event emission instead of 5
- Batch signature verification (if implemented)

## Creating TrainingRegistryV2

### Storage Layout Rules

**Critical rules for upgrades:**
1. **Never reorder** existing state variables
2. **Never delete** existing state variables
3. **Never change types** of existing variables
4. **Always append** new variables at the end
5. **Reduce _gap** by slots consumed

### src/TrainingRegistryV2.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {Ownable2StepUpgradeable} from "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {EIP712Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import {ERC1155Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

contract TrainingRegistryV2 is
    Initializable,
    UUPSUpgradeable,
    Ownable2StepUpgradeable,
    PausableUpgradeable,
    EIP712Upgradeable,
    ERC1155Upgradeable
{
    using ECDSA for bytes32;

    struct CompletionVoucher {
        uint256 taskCode;
        address wallet;
    }

    bytes32 private constant VOUCHER_TYPEHASH = keccak256(
        "CompletionVoucher(uint256 taskCode,address wallet)"
    );

    // ========================================
    // V1 STORAGE (DO NOT MODIFY!)
    // ========================================
    mapping(address => bool) public isIssuer;
    mapping(address => mapping(uint256 => bool)) public completed;
    mapping(address => uint256[]) private _walletTokenIds;
    mapping(address => mapping(uint256 => bool)) private _hasTokenId;
    address public claimant;

    event IssuerUpdated(address indexed issuer, bool allowed);
    event TaskCompleted(uint256 indexed taskCode, address indexed wallet);
    event BatchSubmitted(address indexed wallet, uint256[] taskCodes, uint256 count);  // NEW EVENT
    event BaseURISet(string newBaseURI);
    event UriPadDigitsSet(uint8 newPadDigits);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    // NO NEW INITIALIZER - upgrade preserves existing initialization
    // Never add initialize() to V2+, only V1 has it!

    function setIssuer(address issuer, bool allowed) external onlyOwner {
        isIssuer[issuer] = allowed;
        emit IssuerUpdated(issuer, allowed);
    }

    function setBaseURI(string memory newBaseURI) external onlyOwner {
        _setURI(newBaseURI);
        _baseDirectoryUri = newBaseURI;
        emit BaseURISet(newBaseURI);
    }

    function setUriPadDigits(uint8 newPad) external onlyOwner {
        uriPadDigits = newPad;
        emit UriPadDigitsSet(newPad);
    }

    function pause() external onlyOwner { _pause(); }
    function unpause() external onlyOwner { _unpause(); }

    // V1 function - UNCHANGED
    function submitVoucher(uint256 taskCode, bytes calldata signature) external whenNotPaused {
        require(!completed[msg.sender][taskCode], "already completed");

        bytes32 structHash = keccak256(abi.encode(VOUCHER_TYPEHASH, taskCode, msg.sender));
        bytes32 digest = MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);
        address signer = ECDSA.recover(digest, signature);
        require(isIssuer[signer], "invalid issuer");

        completed[msg.sender][taskCode] = true;
        _mint(msg.sender, taskCode, 1, "");
        emit TaskCompleted(taskCode, msg.sender);
    }

    // ========================================
    // V2 NEW FEATURE: BATCH SUBMISSION
    // ========================================
    
    /// @notice Submit multiple vouchers in one transaction
    /// @param taskCodes Array of task codes to claim
    /// @param signatures Array of signatures (one per task)
    function submitVoucherBatch(
        uint256[] calldata taskCodes,
        bytes[] calldata signatures
    ) external whenNotPaused {
        require(taskCodes.length > 0, "empty batch");
        require(taskCodes.length == signatures.length, "length mismatch");
        require(taskCodes.length <= 20, "batch too large");  // Prevent gas limit issues

        uint256 successCount = 0;

        for (uint256 i = 0; i < taskCodes.length; i++) {
            uint256 taskCode = taskCodes[i];
            
            // Skip if already completed (don't revert entire batch)
            if (completed[msg.sender][taskCode]) {
                continue;
            }

            // Verify signature
            bytes32 structHash = keccak256(abi.encode(VOUCHER_TYPEHASH, taskCode, msg.sender));
            bytes32 digest = MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);
            address signer = ECDSA.recover(digest, signatures[i]);
            
            if (!isIssuer[signer]) {
                continue;  // Skip invalid signatures
            }

            // Mark complete and mint
            completed[msg.sender][taskCode] = true;
            _mint(msg.sender, taskCode, 1, "");
            emit TaskCompleted(taskCode, msg.sender);
            successCount++;
        }

        require(successCount > 0, "no valid vouchers");
        
        batchSubmissionCount++;
        emit BatchSubmitted(msg.sender, taskCodes, successCount);
    }

    function _update(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal override {
        require(from == address(0) || to == address(0), "SBT: non-transferable");
        super._update(from, to, ids, amounts);

        if (to != address(0)) {
            for (uint256 i = 0; i < ids.length; i++) {
                uint256 tokenId = ids[i];
                if (!_hasTokenId[to][tokenId] && balanceOf(to, tokenId) > 0) {
                    _hasTokenId[to][tokenId] = true;
                    _walletTokenIds[to].push(tokenId);
                }
            }
        }
        if (from != address(0)) {
            for (uint256 i = 0; i < ids.length; i++) {
                uint256 tokenId = ids[i];
                if (_hasTokenId[from][tokenId] && balanceOf(from, tokenId) == 0) {
                    _hasTokenId[from][tokenId] = false;
                    _removeWalletTokenId(from, tokenId);
                }
            }
        }
    }

    function uri(uint256 tokenId) public view override returns (string memory) {
        return string(abi.encodePacked(_baseDirectoryUri, _paddedDecimal(tokenId, uriPadDigits), ".json"));
    }

    function _paddedDecimal(uint256 value, uint8 minDigits) internal pure returns (string memory) {
        string memory dec = Strings.toString(value);
        uint256 len = bytes(dec).length;
        if (len >= minDigits) return dec;
        uint256 pad = uint256(minDigits) - len;
        bytes memory zeros = new bytes(pad);
        for (uint256 i = 0; i < pad; i++) zeros[i] = 0x30;
        return string(abi.encodePacked(zeros, dec));
    }

    function _removeWalletTokenId(address wallet, uint256 tokenId) internal {
        uint256[] storage list = _walletTokenIds[wallet];
        for (uint256 i = 0; i < list.length; i++) {
            if (list[i] == tokenId) {
                uint256 last = list[list.length - 1];
                list[i] = last;
                list.pop();
                break;
            }
        }
    }

    function getWalletAchievements(address wallet) external view returns (uint256[] memory) {
        return _walletTokenIds[wallet];
    }

    function hasAchievement(address wallet, uint256 tokenId) external view returns (bool) {
        return _hasTokenId[wallet][tokenId];
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // ========================================
    // STORAGE LAYOUT (matches V1 exactly, then adds V2)
    // ========================================
    string private _baseDirectoryUri;     // Slot 5 (from V1)
    uint8 public uriPadDigits;            // Slot 6 (from V1)
    uint256[37] private _gap;            // Slots 7-43 (reduced from 38)
    uint256 public batchSubmissionCount;  // Slot 44 (NEW in V2)
}
```

**Key changes from V1:**
1. ‚úÖ V1 storage preserved exactly (lines 30-35)
2. ‚úÖ New variable appended: `batchSubmissionCount` (line 40)
3. ‚úÖ New event: `BatchSubmitted` (line 45)
4. ‚úÖ V1 function unchanged: `submitVoucher()` (lines 70-83)
5. ‚úÖ New function added: `submitVoucherBatch()` (lines 90-133)
6. ‚úÖ _gap reduced: 38 ‚Üí 37 (line 190)
7. ‚úÖ Still has `_authorizeUpgrade()` (line 187) - CRITICAL!

## Upgrade Process

### script/Upgrade.s.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Script} from "forge-std/Script.sol";
import {console2} from "forge-std/console2.sol";
import {TrainingRegistryV1} from "../src/TrainingRegistryV1.sol";
import {TrainingRegistryV2} from "../src/TrainingRegistryV2.sol";

contract Upgrade is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address proxyAddress = vm.envAddress("PROXY_ADDRESS");
        
        console2.log("=== Upgrading to TrainingRegistry V2 ===");
        console2.log("Proxy Address:", proxyAddress);
        console2.log("Deployer:", vm.addr(deployerPrivateKey));
        
        // Cast proxy to V1 for upgrade call
        TrainingRegistryV1 registryV1 = TrainingRegistryV1(proxyAddress);
        
        // Verify current state before upgrade
        console2.log("\nPre-upgrade state:");
        address owner = registryV1.owner();
        address claimant = registryV1.claimant();
        console2.log("Owner:", owner);
        console2.log("Claimant:", claimant);
        
        vm.startBroadcast(deployerPrivateKey);
        
        // 1. Deploy V2 implementation
        console2.log("\n1. Deploying V2 implementation...");
        TrainingRegistryV2 implementationV2 = new TrainingRegistryV2();
        console2.log("V2 Implementation:", address(implementationV2));
        
        // 2. Upgrade proxy to V2
        console2.log("\n2. Upgrading proxy...");
        registryV1.upgradeToAndCall(address(implementationV2), "");
        console2.log("‚úÖ Proxy upgraded!");
        
        vm.stopBroadcast();
        
        // 3. Verify upgrade
        console2.log("\n3. Verifying upgrade...");
        TrainingRegistryV2 registryV2 = TrainingRegistryV2(proxyAddress);
        
        // Check V1 state preserved
        address newOwner = registryV2.owner();
        address newClaimant = registryV2.claimant();
        
        require(newOwner == owner, "Owner changed!");
        require(newClaimant == claimant, "Claimant changed!");
        
        console2.log("Owner (preserved):", newOwner);
        console2.log("Claimant (preserved):", newClaimant);
        
        // Check V2 features available
        uint256 batchCount = registryV2.batchSubmissionCount();
        console2.log("Batch submission count:", batchCount);
        
        console2.log("\n=== Upgrade Successful! ===");
        console2.log("V2 Implementation:", address(implementationV2));
        console2.log("Proxy (unchanged):", proxyAddress);
        console2.log("\nNew features:");
        console2.log("- submitVoucherBatch() for gas savings");
        console2.log("- batchSubmissionCount tracking");
    }
}
```

### Run the Upgrade

```bash
# Deploy V2 and upgrade proxy
forge script script/Upgrade.s.sol \
  --rpc-url zilliqaTestnet \
  --broadcast \
  --legacy
```

**Expected output:**
```
=== Upgrading to TrainingRegistry V2 ===
Proxy Address: 0xProxyAddress
Deployer: 0xYourAddress

Pre-upgrade state:
Owner: 0xYourAddress
Claimant: 0xYourClaimant

1. Deploying V2 implementation...
V2 Implementation: 0xNewImplementationAddress

2. Upgrading proxy...
‚úÖ Proxy upgraded!

3. Verifying upgrade...
Owner (preserved): 0xYourAddress
Claimant (preserved): 0xYourClaimant
Batch submission count: 0

=== Upgrade Successful! ===
```

## Testing the Upgrade

### test/Upgrade.t.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, console2} from "forge-std/Test.sol";
import {TrainingRegistryV1} from "../src/TrainingRegistryV1.sol";
import {TrainingRegistryV2} from "../src/TrainingRegistryV2.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

contract UpgradeTest is Test {
    using MessageHashUtils for bytes32;

    TrainingRegistryV1 public implV1;
    TrainingRegistryV2 public implV2;
    ERC1967Proxy public proxy;
    TrainingRegistryV1 public registryV1;
    TrainingRegistryV2 public registryV2;
    
    address public owner;
    address public issuer;
    uint256 public issuerPk;
    address public learner;
    address public claimant;

    bytes32 private constant VOUCHER_TYPEHASH = keccak256(
        "CompletionVoucher(uint256 taskCode,address wallet)"
    );

    function setUp() public {
        owner = address(this);
        (issuer, issuerPk) = makeAddrAndKey("ISSUER");
        learner = address(0xBEEF);
        claimant = address(0xC1A1);

        // Deploy V1
        implV1 = new TrainingRegistryV1();
        bytes memory initData = abi.encodeWithSelector(
            TrainingRegistryV1.initialize.selector,
            owner,
            "https://base/",
            "TrainingCert",
            "1",
            claimant
        );
        proxy = new ERC1967Proxy(address(implV1), initData);
        registryV1 = TrainingRegistryV1(address(proxy));
        
        registryV1.setIssuer(issuer, true);
    }

    function testUpgradePreservesState() public {
        // Create V1 state: submit 3 achievements
        vm.startPrank(learner);
        for (uint256 i = 1; i <= 3; i++) {
            registryV1.submitVoucher(i, _signVoucher(i, learner));
        }
        vm.stopPrank();

        // Verify V1 state
        assertTrue(registryV1.completed(learner, 1));
        assertTrue(registryV1.completed(learner, 2));
        assertTrue(registryV1.completed(learner, 3));
        assertEq(registryV1.balanceOf(learner, 1), 1);
        
        // Record V1 state
        address preOwner = registryV1.owner();
        address preClaimant = registryV1.claimant();
        uint8 prePadDigits = registryV1.uriPadDigits();

        // Upgrade to V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        
        // Cast to V2
        registryV2 = TrainingRegistryV2(address(proxy));

        // Verify all V1 state preserved
        assertEq(registryV2.owner(), preOwner);
        assertEq(registryV2.claimant(), preClaimant);
        assertEq(registryV2.uriPadDigits(), prePadDigits);
        
        // Verify achievement data intact
        assertTrue(registryV2.completed(learner, 1));
        assertTrue(registryV2.completed(learner, 2));
        assertTrue(registryV2.completed(learner, 3));
        assertEq(registryV2.balanceOf(learner, 1), 1);
        assertEq(registryV2.balanceOf(learner, 2), 1);
        assertEq(registryV2.balanceOf(learner, 3), 1);

        uint256[] memory achievements = registryV2.getWalletAchievements(learner);
        assertEq(achievements.length, 3);
    }

    function testV2BatchSubmission() public {
        // Upgrade to V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        // Prepare batch
        uint256[] memory taskCodes = new uint256[](5);
        bytes[] memory signatures = new bytes[](5);
        
        for (uint256 i = 0; i < 5; i++) {
            taskCodes[i] = i + 1;
            signatures[i] = _signVoucher(i + 1, learner);
        }

        // Submit batch
        vm.prank(learner);
        registryV2.submitVoucherBatch(taskCodes, signatures);

        // Verify all claimed
        for (uint256 i = 1; i <= 5; i++) {
            assertTrue(registryV2.completed(learner, i));
            assertEq(registryV2.balanceOf(learner, i), 1);
        }
        
        assertEq(registryV2.batchSubmissionCount(), 1);
    }

    function testV2BatchSkipsCompleted() public {
        // Upgrade to V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        // Submit task 1 individually first
        vm.prank(learner);
        registryV2.submitVoucher(1, _signVoucher(1, learner));

        // Try to batch submit including task 1 again
        uint256[] memory taskCodes = new uint256[](3);
        bytes[] memory signatures = new bytes[](3);
        
        taskCodes[0] = 1;  // Already completed
        taskCodes[1] = 2;  // New
        taskCodes[2] = 3;  // New
        
        signatures[0] = _signVoucher(1, learner);
        signatures[1] = _signVoucher(2, learner);
        signatures[2] = _signVoucher(3, learner);

        // Should succeed, skipping task 1
        vm.prank(learner);
        registryV2.submitVoucherBatch(taskCodes, signatures);

        // Verify: 1 was already there, 2 and 3 added
        assertEq(registryV2.balanceOf(learner, 1), 1);
        assertEq(registryV2.balanceOf(learner, 2), 1);
        assertEq(registryV2.balanceOf(learner, 3), 1);
    }

    function testV2OldFunctionStillWorks() public {
        // Upgrade to V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        // Use old V1 function
        vm.prank(learner);
        registryV2.submitVoucher(1, _signVoucher(1, learner));

        assertTrue(registryV2.completed(learner, 1));
    }

    function testV2BatchRevertsOnEmptyArray() public {
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        uint256[] memory taskCodes = new uint256[](0);
        bytes[] memory signatures = new bytes[](0);

        vm.prank(learner);
        vm.expectRevert("empty batch");
        registryV2.submitVoucherBatch(taskCodes, signatures);
    }

    function testV2BatchRevertsOnLengthMismatch() public {
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        uint256[] memory taskCodes = new uint256[](2);
        bytes[] memory signatures = new bytes[](3);  // Mismatch!

        vm.prank(learner);
        vm.expectRevert("length mismatch");
        registryV2.submitVoucherBatch(taskCodes, signatures);
    }

    // ============ HELPER FUNCTIONS ============

    function _signVoucher(uint256 taskCode, address wallet) internal view returns (bytes memory) {
        bytes32 structHash = keccak256(abi.encode(VOUCHER_TYPEHASH, taskCode, wallet));
        bytes32 domainSeparator = _domainSeparator();
        bytes32 digest = MessageHashUtils.toTypedDataHash(domainSeparator, structHash);
        
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(issuerPk, digest);
        return abi.encodePacked(r, s, v);
    }

    function _domainSeparator() internal view returns (bytes32) {
        bytes32 typehash = keccak256(
            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
        );
        return keccak256(
            abi.encode(
                typehash,
                keccak256(bytes("TrainingCert")),
                keccak256(bytes("1")),
                block.chainid,
                address(proxy)
            )
        );
    }
}
```

### Run Upgrade Tests

```bash
forge test --match-contract UpgradeTest -vvv
```

**Expected output:**
```
Ran 6 tests for test/Upgrade.t.sol:UpgradeTest
[PASS] testUpgradePreservesState() (gas: 2933901)
[PASS] testV2BatchRevertsOnEmptyArray() (gas: 2551876)
[PASS] testV2BatchRevertsOnLengthMismatch() (gas: 2553002)
[PASS] testV2BatchSkipsCompleted() (gas: 2933274)
[PASS] testV2BatchSubmission() (gas: 3153488)
[PASS] testV2OldFunctionStillWorks() (gas: 2689255)
Suite result: ok. 6 passed; 0 failed; 0 skipped; finished in 4.04ms (5.90ms CPU time)

Ran 1 test suite in 7.45ms (4.04ms CPU time): 6 tests passed, 0 failed, 0 skipped (6 total tests)
```

## Gas Comparison

### Measure Gas Savings

Create a gas comparison test (Note this contract single calls are actually really compressed so the batch doesnt save a lot here but this was just an example):
test/GasCompare.t.sol
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, console2} from "forge-std/Test.sol";
import {TrainingRegistryV1} from "../src/TrainingRegistryV1.sol";
import {TrainingRegistryV2} from "../src/TrainingRegistryV2.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

contract GasCompareTest is Test {
    using MessageHashUtils for bytes32;

    TrainingRegistryV1 public implV1;
    TrainingRegistryV2 public implV2;
    ERC1967Proxy public proxy;
    TrainingRegistryV1 public registryV1;
    TrainingRegistryV2 public registryV2;
    
    address public owner;
    address public issuer;
    uint256 public issuerPk;
    address public learner;
    address public claimant;

    bytes32 private constant VOUCHER_TYPEHASH = keccak256(
        "CompletionVoucher(uint256 taskCode,address wallet)"
    );

    function setUp() public {
        owner = address(this);
        (issuer, issuerPk) = makeAddrAndKey("ISSUER");
        learner = address(0xBEEF);
        claimant = address(0xC1A1);

        // Deploy V1
        implV1 = new TrainingRegistryV1();
        bytes memory initData = abi.encodeWithSelector(
            TrainingRegistryV1.initialize.selector,
            owner,
            "https://base/",
            "TrainingCert",
            "1",
            claimant
        );
        proxy = new ERC1967Proxy(address(implV1), initData);
        registryV1 = TrainingRegistryV1(address(proxy));
        
        registryV1.setIssuer(issuer, true);
    }

    function testGasComparison() public {
        // Setup V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        // Measure V1 individual submissions
        uint256 gasV1Start = gasleft();
        for (uint256 i = 1; i <= 5; i++) {
            vm.prank(learner);
            registryV2.submitVoucher(i, _signVoucher(i, learner));
        }
        uint256 gasV1Used = gasV1Start - gasleft();
        
        // Setup second user for V2 batch
        address learner2 = address(0xCAFE);
        
        // Measure V2 batch submission
        uint256[] memory taskCodes = new uint256[](5);
        bytes[] memory signatures = new bytes[](5);
        for (uint256 i = 0; i < 5; i++) {
            taskCodes[i] = i + 1;
            signatures[i] = _signVoucher(i + 1, learner2);
        }
        
        uint256 gasV2Start = gasleft();
        vm.prank(learner2);
        registryV2.submitVoucherBatch(taskCodes, signatures);
        uint256 gasV2Used = gasV2Start - gasleft();
        
        console2.log("V1 (5 individual):", gasV1Used);
        console2.log("V2 (1 batch of 5):", gasV2Used);
        console2.log("Savings:", gasV1Used - gasV2Used);
        console2.log("Savings %:", ((gasV1Used - gasV2Used) * 100) / gasV1Used);
        
        // Verify savings
        assertTrue(gasV2Used < gasV1Used, "V2 should use less gas");
    }

    function testGasComparison10Tasks() public {
        // Setup V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        // Measure V1 individual submissions (10 tasks)
        uint256 gasV1Start = gasleft();
        for (uint256 i = 1; i <= 10; i++) {
            vm.prank(learner);
            registryV2.submitVoucher(i, _signVoucher(i, learner));
        }
        uint256 gasV1Used = gasV1Start - gasleft();
        
        // Setup second user for V2 batch
        address learner2 = address(0xCAFE);
        
        // Measure V2 batch submission (10 tasks)
        uint256[] memory taskCodes = new uint256[](10);
        bytes[] memory signatures = new bytes[](10);
        for (uint256 i = 0; i < 10; i++) {
            taskCodes[i] = i + 1;
            signatures[i] = _signVoucher(i + 1, learner2);
        }
        
        uint256 gasV2Start = gasleft();
        vm.prank(learner2);
        registryV2.submitVoucherBatch(taskCodes, signatures);
        uint256 gasV2Used = gasV2Start - gasleft();
        
        console2.log("\n=== 10 Tasks Comparison ===");
        console2.log("V1 (10 individual):", gasV1Used);
        console2.log("V2 (1 batch of 10):", gasV2Used);
        console2.log("Savings:", gasV1Used - gasV2Used);
        console2.log("Savings %:", ((gasV1Used - gasV2Used) * 100) / gasV1Used);
        
        // Verify savings scale with batch size
        assertTrue(gasV2Used < gasV1Used, "V2 should use less gas");
    }

    function testGasComparison20Tasks() public {
        // Setup V2
        implV2 = new TrainingRegistryV2();
        registryV1.upgradeToAndCall(address(implV2), "");
        registryV2 = TrainingRegistryV2(address(proxy));

        // Measure V1 individual submissions (20 tasks - max batch size)
        uint256 gasV1Start = gasleft();
        for (uint256 i = 1; i <= 20; i++) {
            vm.prank(learner);
            registryV2.submitVoucher(i, _signVoucher(i, learner));
        }
        uint256 gasV1Used = gasV1Start - gasleft();
        
        // Setup second user for V2 batch
        address learner2 = address(0xCAFE);
        
        // Measure V2 batch submission (20 tasks - max)
        uint256[] memory taskCodes = new uint256[](20);
        bytes[] memory signatures = new bytes[](20);
        for (uint256 i = 0; i < 20; i++) {
            taskCodes[i] = i + 1;
            signatures[i] = _signVoucher(i + 1, learner2);
        }
        
        uint256 gasV2Start = gasleft();
        vm.prank(learner2);
        registryV2.submitVoucherBatch(taskCodes, signatures);
        uint256 gasV2Used = gasV2Start - gasleft();
        
        console2.log("\n=== 20 Tasks Comparison (Max Batch) ===");
        console2.log("V1 (20 individual):", gasV1Used);
        console2.log("V2 (1 batch of 20):", gasV2Used);
        console2.log("Savings:", gasV1Used - gasV2Used);
        console2.log("Savings %:", ((gasV1Used - gasV2Used) * 100) / gasV1Used);
        
        // Maximum savings should be significant
        assertTrue(gasV2Used < gasV1Used, "V2 should use less gas");
    }

    // ============ HELPER FUNCTIONS ============

    function _signVoucher(uint256 taskCode, address wallet) internal view returns (bytes memory) {
        bytes32 structHash = keccak256(abi.encode(VOUCHER_TYPEHASH, taskCode, wallet));
        bytes32 domainSeparator = _domainSeparator();
        bytes32 digest = MessageHashUtils.toTypedDataHash(domainSeparator, structHash);
        
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(issuerPk, digest);
        return abi.encodePacked(r, s, v);
    }

    function _domainSeparator() internal view returns (bytes32) {
        bytes32 typehash = keccak256(
            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
        );
        return keccak256(
            abi.encode(
                typehash,
                keccak256(bytes("TrainingCert")),
                keccak256(bytes("1")),
                block.chainid,
                address(proxy)
            )
        );
    }
}
```

**Run it:**
```bash
forge test --match-contract GasCompareTest -vv
```

**Output:**
```
[‚†í] Compiling...
[‚†í] Compiling 1 files with Solc 0.8.28
[‚†¢] Solc 0.8.28 finished in 2.42s
Compiler run successful!

Ran 3 tests for test/GasCompare.t.sol:GasCompareTest
[PASS] testGasComparison() (gas: 3701177)
Logs:
  V1 (5 individual): 574329
  V2 (1 batch of 5): 568268
  Savings: 6061
  Savings %: 1

[PASS] testGasComparison10Tasks() (gas: 4765634)
Logs:

=== 10 Tasks Comparison ===
  V1 (10 individual): 1109719
  V2 (1 batch of 10): 1085309
  Savings: 24410
  Savings %: 2

[PASS] testGasComparison20Tasks() (gas: 6895574)
Logs:

=== 20 Tasks Comparison (Max Batch) ===
  V1 (20 individual): 2180692
  V2 (1 batch of 20): 2119456
  Savings: 61236
  Savings %: 2

Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 9.16ms (14.73ms CPU time)

Ran 1 test suite in 12.90ms (9.16ms CPU time): 3 tests passed, 0 failed, 0 skipped (3 total tests)
```

## Storage Layout Verification

### Compare V1 and V2 Layouts

```bash
# V1 layout
forge inspect TrainingRegistryV1 storage-layout

# V2 layout
forge inspect TrainingRegistryV2 storage-layout
```

## Common Upgrade Pitfalls

### ‚ùå Adding New Initializer

```solidity
// DON'T DO THIS in V2!
contract TrainingRegistryV2 {
    function initializeV2() public initializer {
        // This will FAIL - already initialized in V1
    }
}
```

**Why it fails:**
- `initializer` modifier checks if already initialized
- V1 already set the initialized flag
- Use `reinitializer(2)` if you need post-upgrade initialization

### ‚ùå Reordering Storage

```solidity
// V1
contract TrainingRegistryV1 {
    mapping(address => bool) public isIssuer;        // Slot 0
    mapping(address => mapping(uint256 => bool)) public completed;  // Slot 1
    address public claimant;                          // Slot 2
}

// V2 - WRONG!
contract TrainingRegistryV2 {
    address public claimant;                          // NOW Slot 0!
    mapping(address => bool) public isIssuer;        // NOW Slot 1!
    mapping(address => mapping(uint256 => bool)) public completed;  // NOW Slot 2!
}
```

**Result:** Silent data corruption. Slot 0 held a mapping, now interpreted as an address!

### ‚ùå Forgetting _authorizeUpgrade

```solidity
// V2 - BROKEN!
contract TrainingRegistryV2 {
    // Missing _authorizeUpgrade function
    // Contract is now FROZEN - can't upgrade to V3!
}
```

**Critical:** Every UUPS version MUST include `_authorizeUpgrade`!

## Wrap-Up

You've successfully:

‚úÖ **Created TrainingRegistryV2** with batch voucher submission  
‚úÖ **Maintained storage layout** (append-only, adjusted _gap)  
‚úÖ **Deployed V2 implementation**  
‚úÖ **Upgraded proxy** from V1 to V2  
‚úÖ **Tested state preservation** (all V1 data intact)  
‚úÖ **Verified gas savings** (66% reduction for batch of 5)  
‚úÖ **Tested upgrade safety** (comprehensive test suite)  
‚úÖ **Understood upgrade pitfalls** (no initializer, preserve storage, keep _authorizeUpgrade)  

**Key lessons:**
1. Upgradeable contracts let you add features post-launch
2. Storage layout discipline is CRITICAL (append-only, never reorder)
3. New features can coexist with old ones (backward compatibility)
4. Gas savings are real and measurable
5. Test upgrades thoroughly (state preservation, new features, old features still work)

**What you've built:**
You deployed and upgraded the actual contract architecture powering Plunder Academy achievements! This is production-grade upgradeable contract development. The patterns you learned apply to any upgradeable protocol managing real value.

**Congratulations!** You've mastered upgradeable smart contracts - one of the most advanced topics in Solidity development. This skill is highly valued in the industry and essential for building long-lived DeFi protocols. üéâüöÄ

## Claim Your Achievement

### Achievement Submission

**You've successfully deployed TrainingRegistryV2!**

**To claim your achievement:**

1. **Find your deployment transaction hash** (from deployment output or `broadcast/` folder)

3. **Connect your wallet** (the one set as `CLAIMANT_ADDRESS`)
4. **Submit the deployment transaction hash for TrainingRegistryV2 below!**
5. **Verification happens automatically:**
   - Checks transaction deployed a contract
   - Verifies it's a TrainingRegistryV2 implementation
   - Confirms proxy was deployed and initialized
   - Validates claimant matches your wallet
6. **Receive your achievement NFT!**

**Next:** Island 5 will teach you to build full-stack dapps, connecting these backend contracts to beautiful frontends with wagmi and RainbowKit!

