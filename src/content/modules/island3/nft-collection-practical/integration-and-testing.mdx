---
id: integration-and-testing
module: nft-collection-practical
number: 3.8
title: Integration and Testing
objective: >-
  Validate the full NFT flow: mint phases, safe transfers, reveal, and royalties—with events and negative tests for real‑world robustness.
slug: integration-and-testing
---

## Set the stage

Testing is your sea trial. Before a ship launches, crews rehearse emergencies, verify instruments, and simulate rough weather. Likewise, you’ll prove that presale/public phases work, reveals don’t mutate IDs, royalties respond correctly, and transfers are safe—even against malicious receivers. Your tests are living documentation and the guardrails that keep your launch steady.

## Conceptual foundations

### Fixture‑driven isolation

- **Definition**: Recreate known starting states for each test using fixtures.
- **When to use**: Always—prevents order dependence and flakiness.
- **Tip**: Reset phase, supply, and URIs in a shared `deployCollectionFixture`.

### Events as public contracts

- **Definition**: Your event schema is part of the API; dashboards and bots depend on it.
- **Practice**: Assert `PhaseChanged`, `Revealed`, and royalty updates with exact args and indexed fields.

### Negative testing mindset

- **Definition**: Prove the system fails safely: out‑of‑phase mints, wrong payments, missing interfaces.
- **Benefit**: Catches real‑world regressions early; documents guarantees.

### Determinism and time

- **Definition**: Avoid wall‑clock dependence; use helpers to control time.
- **Tip**: Advance to exact timestamps for phase changes; avoid sleeps.

### Interface‑first testing

- **Definition**: Interact through public interfaces (ERC721, ERC2981) and not internal details.
- **Benefit**: Reduces coupling and makes refactors safer.

## Guided code walk‑throughs

### 1) End‑to‑end: presale → public → reveal

```ts
// test/Collection.integration.ts (excerpt)
import { loadFixture, time } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { expect } from "chai";

describe("Collection", () => {
  it("presale then public then reveal", async () => {
    const { collection, admin, user } = await loadFixture(deployCollectionFixture);
    await expect(collection.setPhase(1)).to.emit(collection, "PhaseChanged");
    await collection.connect(user).mintPresale(1, [], { value: 0n });
    await expect(collection.setPhase(2)).to.emit(collection, "PhaseChanged");
    await collection.connect(user).mintPublic(1, { value: 0n });
    await expect(collection.reveal("bafy..."))
      .to.emit(collection, "Revealed");
  });
});
```

Takeaway: exercise happy path end‑to‑end with event assertions.

### 2) Royalties smoke test

```ts
// test/Royalties.spec.ts (excerpt)
it("returns default royalty info", async () => {
  const salePrice = 1_000_000n;
  const [receiver, amount] = await collection.royaltyInfo(0, salePrice);
  expect(amount).to.be.greaterThan(0n);
  expect(receiver).to.properAddress; // custom chai matcher in your setup
});
```

Takeaway: assert the interface returns expected shapes; marketplace enforcement varies.

### 3) Revert on unsafe receiver (no IERC721Receiver)

```ts
// test/SafeTransfer.spec.ts (excerpt)
import { expect } from "chai";

it("reverts safeTransferFrom to non-receiver contract", async () => {
  const { collection, user, badContract } = await loadFixture(deployCollectionFixture);
  await collection.connect(user).mintPublic(1, { value: 0n });
  await expect(
    collection.connect(user)["safeTransferFrom(address,address,uint256)"](user.address, badContract.target, 1n)
  ).to.be.reverted; // explicit error depends on your implementation
});
```

Takeaway: enforce interface checks to prevent token loss when transferring to contracts.

## Practice and reflection

- Add a negative test: unauthorized URI change or out‑of‑phase mint
- Validate `safeTransferFrom` to a contract without the receiver interface reverts
- Add a test to assert `royaltyInfo` returns a receiver and non‑zero amount
- Measure gas for mint under cap and at cap; ensure it stays predictable

{/* Practice and reflection */}
<PracticeNote>
Focus on readability: fixtures, helpers, and table‑driven tests beat monolithic specs.
</PracticeNote>

{/* True/False */}
<TrueFalse statements={[
  {"id":"t1","text":"Event assertions are optional for integration tests","correctAnswer":false,"explanation":"Events are public contracts—assert them."},
  {"id":"t2","text":"Fixtures help avoid test order dependence","correctAnswer":true,"explanation":"Reset state per test for reliability."}
]}/>

## Security and pitfalls

### Order‑dependent tests

**Danger**: Tests pass locally but fail in CI when order changes.

**Rule**: Use fixtures; never rely on previous test side effects.

### Missing negative tests

**Danger**: Happy‑path only testing misses out‑of‑phase minting or wrong payment handling.

**Rule**: For each feature, add at least one revert case with explicit error expectation.

### Interface drift

**Danger**: Changing event args or names silently breaks dashboards.

**Rule**: Treat events as contracts; add tests that assert exact topics and args.

### Time dependence

**Danger**: Using wall‑clock for phase checks yields flaky tests.

**Rule**: Use helpers to advance time deterministically.

## Security checklist

- [ ] **Fixtures**: All tests isolated via fixtures or snapshot resets
- [ ] **Event assertions**: `PhaseChanged`, `Revealed`, royalty updates asserted
- [ ] **Negative tests**: Out‑of‑phase mint, wrong payment, unauthorized actions
- [ ] **Interface safety**: `safeTransferFrom` with/without receiver interface covered
- [ ] **Royalties**: `royaltyInfo` returns valid receiver and positive amount
- [ ] **Gas bounds**: Capture mint gas at cap for regression tracking
- [ ] **Deterministic time**: Use helpers for phase timing
- [ ] **CI ready**: Tests avoid network flakiness and implicit ordering

## Wrap‑up

Your collection is launch‑ready: tested phases, safe transfers, reveal, and royalties. Ship with a clear incident plan and monitoring for phase/reveal events.


