---
id: "nft-practical-lesson-1"
slug: "deployment-launch"
module: "nft-collection-practical"
number: "3.7"
title: "NFT Collection Deployment and Launch"
objective: "Deploy a complete NFT collection with all advanced features and proper launch strategy."
practicalTakeaway: "Successfully launch an NFT collection ready for marketplace integration and community engagement."
---

# NFT Collection Deployment and Launch

## Set the stage

Time to stitch the pieces together: ERC721 core, IPFS metadata + reveal, ERC‑2981 royalties, and multi‑phase minting. We’ll focus on clear initialization, admin safety, and event contracts that make launches observable.

A good launch feels like a well‑planned voyage: the captain (admin) is known, the route (phases) is posted, the cargo manifest (supply, URIs, royalties) is signed, and the lighthouse (events) makes every maneuver visible. If any of these are missing, confusion spreads—scripts drift, dashboards misread the state, and collectors lose trust.

Your goal here is a deterministic setup you can rehearse and repeat: one command to deploy, one to verify, and one to reveal. Keep the contract’s surface area minimal and push observability into events so off‑chain systems can track progress reliably.

## Conceptual foundations

### Deterministic initialization

- **Definition**: All critical parameters (owner, base URIs, royalty receiver/fee, supply caps, initial phase) set in a single, auditable flow.
- **When to use**: Always—accidental partial setups cause mismatched dashboards and emergency fixes.
- **Practice**: Treat initialization like a transaction: validate inputs, emit events, and keep it idempotent.

### Admin model and separation of duties

- **Definition**: Clear authority for reveal, phase changes, and royalty updates.
- **Options**: `Ownable` for simplicity; `AccessControl` for multi‑role teams; consider a multisig for critical actions.
- **Rule**: Every admin action must emit an event.

### Event contract = public API

- **Definition**: Events are the observable contract for bots, analytics, and community dashboards.
- **When to use**: Always—emit on phase changes, reveals, and royalty updates.
- **Tip**: Index key params (e.g., new phase, base CID, bps) for easy filtering.

### Idempotent scripts and rollbacks

- **Definition**: Re‑running a script causes no harm (safe if partially completed).
- **Practice**: Write deploy/verify/reveal scripts that check current state first; abort or no‑op if already correct.
- **Rollback**: Keep a runbook for pausing mints and reverting misconfig (e.g., reset phase to Closed).

### Environment and secrets

- **Guidance**: Only public env values go in `NEXT_PUBLIC_*`; keep deploy keys and private endpoints off‑client.
- **Tip**: Parameterize scripts by network and admin; never hard‑code.

## Guided code walk‑throughs

### 1) On‑chain initializer (constructor pattern)

2–3 lines of setup: set the initial owner, hidden URI, default royalty, and start with `Closed` phase for safety.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC2981} from "@openzeppelin/contracts/token/common/ERC2981.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract Collection is ERC721, ERC2981, Ownable {
    enum Phase { Closed, Presale, Public }
    Phase public phase;
    string private _hidden;

    event PhaseChanged(Phase phase);
    event Revealed(string baseCid);

    constructor(address admin, string memory hiddenURI, address royaltyReceiver, uint96 feeBps)
        ERC721("MyCollection", "MYC")
        Ownable(admin)
    {
        _hidden = hiddenURI;
        _setDefaultRoyalty(royaltyReceiver, feeBps);
        phase = Phase.Closed;
        emit PhaseChanged(phase);
    }
}
```

Takeaway: initialize critical state once, emit events, and start Closed to avoid accidental mints.

### 2) Launch checklist (what to encode/tests)

```md
- Owner/admin set and documented
- BaseURI placeholder set; reveal plan documented
- Default royalty (ERC‑2981) set to receiver with fee bps
- Phase = Closed; price/maxPerWallet configured
- Pausable verified; incident runbook linked
```

Takeaway: encode assumptions as tests or scripts to prevent human error.

### 3) Post‑deploy verification script (outline)

```ts
// scripts/verifyLaunch.ts (outline)
import { expect } from "chai";

export async function verify(core: any, admin: string) {
  expect(await core.owner?.()).to.equal(admin);
  // Expect placeholder tokenURI for token 0 (if minted in tests)
  // Expect royalty info for a sample sale price
}
```

Takeaway: quick assertions catch misconfigurations immediately after deploy.

## Practice and reflection

- Draft your public announcement events (phase changes, reveal) and confirm they’re emitted
- List what you’ll monitor during mint: errors, gas, event counts, wallet limits
- Write an idempotent deploy script: safe to re‑run without duplicating state
- Add a dry‑run mode: log intended changes without broadcasting transactions

{/* True/False */}
<TrueFalse statements={[
  {"id":"l1","text":"Reveals should change token IDs","correctAnswer":false,"explanation":"Keep IDs stable; only URIs change."},
  {"id":"l2","text":"Phase switches should emit indexable events","correctAnswer":true,"explanation":"Makes launches observable by bots/dashboards."}
]}/>

## Security and pitfalls

### Partial initialization

**Danger**: Deploying without setting royalties or starting in `Closed` leads to mispriced mints or accidental openings.

**Good**:
```solidity
constructor(address admin, address rcv, uint96 bps) Ownable(admin) {
    _setDefaultRoyalty(rcv, bps);
    phase = Phase.Closed; emit PhaseChanged(phase);
}
```

**Rule**: Initialize all critical parameters in one place; emit events for observability.

### Hard‑coded env and addresses

**Danger**: Scripts with embedded addresses or gateway URLs break across networks and audits.

**Rule**: Parameterize by network and admin via env; validate at runtime.

### Missing event assertions

**Danger**: Silent changes to royalty or phase confuse dashboards.

**Rule**: Assert events in verification scripts; index on chain id + address.

### Non‑idempotent scripts

**Danger**: Re‑running scripts flips state (e.g., toggling phase) or overwrites settings unexpectedly.

**Rule**: Read state first; if already correct, no‑op; otherwise, emit and proceed.

## Security checklist

Before launching your collection:

- [ ] **Owner set**: `Ownable(admin)` initialized with the correct admin
- [ ] **Start Closed**: Phase initialized to `Closed` and event emitted
- [ ] **Royalties configured**: Default receiver and bps within marketplace norms
- [ ] **Hidden URI set**: Placeholder path reachable; JSON valid
- [ ] **Events indexable**: `PhaseChanged`, `Revealed`, and royalty updates emit with indexed params
- [ ] **Idempotent scripts**: Deploy/verify/reveal are safe to re‑run
- [ ] **Env hygiene**: No secrets in client; addresses parameterized per network
- [ ] **Dry‑run**: Script mode to print planned changes without txs
- [ ] **Runbook**: Incident plan to pause mints and revert misconfig
- [ ] **Monitoring**: Dashboard subscribed to events pre‑launch

## Wrap‑up

Your collection is wired for a safe launch: deterministic init, reveal/royalties, and phase controls. Next, validate end‑to‑end with integration/testing. For deployment, target a testnet first (e.g., Zilliqa testnet), verify events and configuration, then proceed to mainnet only after checklists pass in CI.

