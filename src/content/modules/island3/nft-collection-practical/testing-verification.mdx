---
id: testing-verification
module: nft-collection-practical
number: 3.7.5
title: Testing and Verification
objective: >-
  Write comprehensive tests for your NFT collection using Hardhat 3, covering minting, reveals, payments, and security edge cases.
slug: testing-verification
---

## Testing Overview

Your NFT collection is deployed and has real metadata on IPFS! But before calling it production-ready, you need comprehensive tests. In this lesson, you'll:

1. **Set up Hardhat 3 testing** with Viem
2. **Test core functionality** (minting, ownership, supply)
3. **Test reveal mechanics** (hidden â†’ revealed)
4. **Test payment handling** (pricing, refunds, withdrawals)
5. **Test access control** (owner-only functions)
6. **Test edge cases** (supply limits, zero values, reverts)
7. **Verify gas efficiency**

## Why Testing Matters

**Real-world NFT issues:**
- **Azuki Elementals:** Minting bugs caused chaos
- **Meebits:** People lost millions in contract bugs
- **Many projects:** Incorrect supply caps, broken metadata

**Testing prevents:**
- Lost user funds
- Broken minting
- Supply exploits
- Access control failures

**Your tests prove:**
- Contract works as expected
- Edge cases handled
- Security validated
- Ready for mainnet

## Test Structure

### test/SimpleNFTCollection.test.ts

Create a comprehensive test suite following Hardhat 3 patterns:

```typescript
import assert from "node:assert/strict";
import { describe, it } from "node:test";
import { network } from "hardhat";
import { parseEther, getAddress } from "viem";

describe("SimpleNFTCollection", async function () {
  const { viem, networkHelpers } = await network.connect();
  const [owner, user1, user2, claimant] = await viem.getWalletClients();

  it("Should set the correct name and symbol", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    assert.equal(await nft.read.name(), "Test NFT");
    assert.equal(await nft.read.symbol(), "TNFT");
  });

  it("Should set the correct owner", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const contractOwner = await nft.read.owner();
    assert.equal(getAddress(contractOwner), getAddress(owner.account.address));
  });

  it("Should set the correct claimant", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const contractClaimant = await nft.read.claimant();
    assert.equal(getAddress(contractClaimant), getAddress(claimant.account.address));
  });

  it("Should initialize with correct parameters", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    assert.equal(await nft.read.MAX_SUPPLY(), 100n);
    assert.equal(await nft.read.mintPrice(), parseEther("1"));
    assert.equal(await nft.read.totalMinted(), 0n);
    assert.equal(await nft.read.isRevealed(), false);
  });

  it("Should revert if claimant is zero address", async function () {
    await assert.rejects(
      async () => await viem.deployContract("SimpleNFTCollection", [
        "Test NFT",
        "TNFT",
        "ipfs://revealed/",
        "ipfs://hidden.json",
        "0x0000000000000000000000000000000000000000",
      ])
    );
  });

  it("Should mint a single NFT with correct payment", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([1n], {
      account: user1.account,
      value: mintPrice,
    });

    assert.equal(await nft.read.totalMinted(), 1n);
    assert.equal(await nft.read.balanceOf([user1.account.address]), 1n);
    assert.equal(await nft.read.ownerOf([1n]), getAddress(user1.account.address));
  });

  it("Should mint multiple NFTs in one transaction", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([5n], {
      account: user1.account,
      value: mintPrice * 5n,
    });

    assert.equal(await nft.read.totalMinted(), 5n);
    assert.equal(await nft.read.balanceOf([user1.account.address]), 5n);
    
    // Check all token IDs are owned correctly
    for (let i = 1; i <= 5; i++) {
      assert.equal(await nft.read.ownerOf([BigInt(i)]), getAddress(user1.account.address));
    }
  });

  it("Should refund excess payment", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    const mintPrice = await nft.read.mintPrice();
    const overpayment = mintPrice + parseEther("5"); // Pay 6 instead of 1

    const balanceBefore = await publicClient.getBalance({
      address: user1.account.address,
    });

    const hash = await nft.write.mint([1n], {
      account: user1.account,
      value: overpayment,
    });

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    const balanceAfter = await publicClient.getBalance({
      address: user1.account.address,
    });

    const gasUsed = receipt.gasUsed * receipt.effectiveGasPrice;
    const expectedBalance = balanceBefore - mintPrice - gasUsed;

    // Allow small difference for gas estimation
    const diff = balanceAfter > expectedBalance 
      ? balanceAfter - expectedBalance 
      : expectedBalance - balanceAfter;
    
    assert.ok(diff < parseEther("0.001"), "Refund should be within 0.001 ZIL"); // Within 0.001 ZIL
  });

  it("Should emit NFTMinted event", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    const mintPrice = await nft.read.mintPrice();
    const hash = await nft.write.mint([3n], {
      account: user1.account,
      value: mintPrice * 3n,
    });

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    // Check for NFTMinted event
    assert.ok(receipt.logs.length > 0, "Should emit NFTMinted event");
  });

  it("Should revert if quantity is zero", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const mintPrice = await nft.read.mintPrice();
    
    await assert.rejects(
      async () => await nft.write.mint([0n], {
        account: user1.account,
        value: mintPrice,
      }),
      /Quantity must be greater than 0/
    );
  });

  it("Should revert if quantity exceeds 10", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const mintPrice = await nft.read.mintPrice();
    
    await assert.rejects(
      async () => await nft.write.mint([11n], {
        account: user1.account,
        value: mintPrice * 11n,
      }),
      /Cannot mint more than 10 at once/
    );
  });

  it("Should revert if insufficient payment", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const mintPrice = await nft.read.mintPrice();
    const underpayment = mintPrice - 1n;
    
    await assert.rejects(
      async () => await nft.write.mint([1n], {
        account: user1.account,
        value: underpayment,
      }),
      /Insufficient payment/
    );
  });

  it("Should revert if exceeds max supply", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    // Mint 100 NFTs (max supply)
    for (let i = 0; i < 10; i++) {
      await nft.write.ownerMint([owner.account.address, 10n]);
    }

    assert.equal(await nft.read.totalMinted(), 100n);

    // Try to mint one more
    const mintPrice = await nft.read.mintPrice();
    
    await assert.rejects(
      async () => await nft.write.mint([1n], {
        account: owner.account,
        value: mintPrice,
      }),
      /Exceeds max supply/
    );
  });

  it("Should allow owner to mint for free", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    await nft.write.ownerMint([user1.account.address, 5n]);

    assert.equal(await nft.read.totalMinted(), 5n);
    assert.equal(await nft.read.balanceOf([user1.account.address]), 5n);
  });

  it("Should revert if non-owner tries to owner mint", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    await assert.rejects(
      async () => await nft.write.ownerMint([user1.account.address, 1n], {
        account: user1.account,
      })
    ); // OwnableUnauthorizedAccount
  });

  it("Should respect max supply for owner minting", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    // Mint 95 NFTs
    await nft.write.ownerMint([owner.account.address, 95n]);

    // Try to mint 10 more (would exceed 100)
    await assert.rejects(
      async () => await nft.write.ownerMint([owner.account.address, 10n]),
      /Exceeds max supply/
    );

    // But 5 more should work
    await nft.write.ownerMint([owner.account.address, 5n]);

    assert.equal(await nft.read.totalMinted(), 100n);
  });

  it("Should return hidden URI when not revealed", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([1n], {
      account: user1.account,
      value: mintPrice,
    });

    const tokenURI = await nft.read.tokenURI([1n]);
    assert.equal(tokenURI, "ipfs://hidden.json");
  });

  it("Should return unique URI after reveal", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    // Mint some tokens
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([3n], {
      account: user1.account,
      value: mintPrice * 3n,
    });

    // Reveal
    await nft.write.reveal();

    // Check URIs
    assert.equal(await nft.read.tokenURI([1n]), "ipfs://revealed/1.json");
    assert.equal(await nft.read.tokenURI([2n]), "ipfs://revealed/2.json");
    assert.equal(await nft.read.tokenURI([3n]), "ipfs://revealed/3.json");
  });

  it("Should emit Revealed event", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    const hash = await nft.write.reveal();
    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    // Check for Revealed event
    assert.ok(receipt.logs.length > 0, "Should emit Revealed event");
  });

  it("Should revert if trying to reveal twice", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    // First reveal
    await nft.write.reveal();

    // Second reveal should fail
    await assert.rejects(
      async () => await nft.write.reveal(),
      /Already revealed/
    );
  });

  it("Should revert if non-owner tries to reveal", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    await assert.rejects(
      async () => await nft.write.reveal({ account: user1.account })
    );
  });

  it("Should revert tokenURI for non-existent token", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    await assert.rejects(
      async () => await nft.read.tokenURI([999n])
    );
  });

  it("Should allow owner to update mint price", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const newPrice = parseEther("0.05");
    await nft.write.setMintPrice([newPrice]);

    assert.equal(await nft.read.mintPrice(), newPrice);
  });

  it("Should emit PriceUpdated event", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    const newPrice = parseEther("0.05");
    const hash = await nft.write.setMintPrice([newPrice]);
    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    assert.ok(receipt.logs.length > 0, "Should emit PriceUpdated event");
  });

  it("Should revert if non-owner tries to update price", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    await assert.rejects(
      async () => await nft.write.setMintPrice([parseEther("0.05")], {
        account: user1.account,
      })
    );
  });

  it("Should allow owner to update base URI", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const newBaseURI = "ipfs://newCID/";
    await nft.write.setBaseURI([newBaseURI]);

    // Reveal to check new base URI
    await nft.write.reveal();

    // Mint a token
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([1n], {
      value: mintPrice,
    });

    const tokenURI = await nft.read.tokenURI([1n]);
    assert.equal(tokenURI, "ipfs://newCID/1.json");
  });

  it("Should allow owner to update not revealed URI", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const newHiddenURI = "ipfs://newHidden.json";
    await nft.write.setNotRevealedURI([newHiddenURI]);

    // Mint a token
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([1n], {
      value: mintPrice,
    });

    const tokenURI = await nft.read.tokenURI([1n]);
    assert.equal(tokenURI, newHiddenURI);
  });

  it("Should allow owner to withdraw contract balance", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    // Mint some NFTs to accumulate funds
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([5n], {
      account: user1.account,
      value: mintPrice * 5n,
    });

    const contractBalance = await publicClient.getBalance({
      address: nft.address,
    });

    assert.equal(contractBalance, mintPrice * 5n);

    // Withdraw
    const ownerBalanceBefore = await publicClient.getBalance({
      address: owner.account.address,
    });

    const withdrawHash = await nft.write.withdraw();
    const receipt = await publicClient.waitForTransactionReceipt({
      hash: withdrawHash,
    });

    const ownerBalanceAfter = await publicClient.getBalance({
      address: owner.account.address,
    });

    const gasUsed = receipt.gasUsed * receipt.effectiveGasPrice;
    const expectedBalance = ownerBalanceBefore + contractBalance - gasUsed;

    // Allow small difference for gas estimation
    const diff = ownerBalanceAfter > expectedBalance
      ? ownerBalanceAfter - expectedBalance
      : expectedBalance - ownerBalanceAfter;

    assert.ok(diff < parseEther("0.001"), "Withdrawal amount should be correct");
  });

  it("Should emit Withdrawn event", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    // Mint to add funds
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([1n], {
      account: user1.account,
      value: mintPrice,
    });

    // Withdraw
    const hash = await nft.write.withdraw();
    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    assert.ok(receipt.logs.length > 0, "Should emit Withdrawn event");
  });

  it("Should revert if no funds to withdraw", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    await assert.rejects(
      async () => await nft.write.withdraw(),
      /No funds to withdraw/
    );
  });

  it("Should revert if non-owner tries to withdraw", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    // Mint to add funds
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([1n], {
      account: user1.account,
      value: mintPrice,
    });

    // Try to withdraw as non-owner
    await assert.rejects(
      async () => await nft.write.withdraw({ account: user1.account })
    );
  });

  it("Should return correct remaining supply", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    assert.equal(await nft.read.remainingSupply(), 100n);

    // Mint some
    const ownerAddr = await nft.read.owner();
    await nft.write.ownerMint([ownerAddr, 25n]);

    assert.equal(await nft.read.remainingSupply(), 75n);
  });

  it("Should return wallet of owner correctly", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    // Mint some tokens
    const mintPrice = await nft.read.mintPrice();
    await nft.write.mint([5n], {
      account: user1.account,
      value: mintPrice * 5n,
    });

    const wallet = await nft.read.walletOfOwner([user1.account.address]);
    
    assert.equal(wallet.length, 5);
    assert.equal(wallet[0], 1n);
    assert.equal(wallet[1], 2n);
    assert.equal(wallet[2], 3n);
    assert.equal(wallet[3], 4n);
    assert.equal(wallet[4], 5n);
  });

  it("Should return empty array for non-owners", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);

    const wallet = await nft.read.walletOfOwner([user2.account.address]);
    assert.equal(wallet.length, 0);
  });

  it("Should use reasonable gas for single mint", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    const mintPrice = await nft.read.mintPrice();
    const hash = await nft.write.mint([1n], {
      account: user1.account,
      value: mintPrice,
    });

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    console.log("      Gas used for single mint:", receipt.gasUsed.toString());
    
    // Should be under 150k gas
    assert.ok(receipt.gasUsed < 150000n, "Gas should be under 150k");
  });

  it("Should be more efficient for batch minting", async function () {
    const nft = await viem.deployContract("SimpleNFTCollection", [
      "Test NFT",
      "TNFT",
      "ipfs://revealed/",
      "ipfs://hidden.json",
      claimant.account.address,
    ]);
    const publicClient = await viem.getPublicClient();

    const mintPrice = await nft.read.mintPrice();
    const hash = await nft.write.mint([10n], {
      account: user1.account,
      value: mintPrice * 10n,
    });

    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    console.log("      Gas used for 10 mints:", receipt.gasUsed.toString());
    console.log("      Gas per NFT:", (receipt.gasUsed / 10n).toString());
    
    // Should be under 600k gas for 10 mints
    assert.ok(receipt.gasUsed < 600000n, "Gas should be under 600k for 10 mints");
  });
});
```

## Running the Tests

### Run All Tests

```bash
npm test
```

**Expected output:**
```
Running node:test tests

  SimpleNFTCollection
    âœ” Should set the correct name and symbol (258ms)
    âœ” Should set the correct owner (108ms)
    âœ” Should set the correct claimant (87ms)
    âœ” Should initialize with correct parameters (127ms)
    âœ” Should revert if claimant is zero address
    âœ” Should mint a single NFT with correct payment (279ms)
    âœ” Should mint multiple NFTs in one transaction (409ms)
    âœ” Should refund excess payment (319ms)
    âœ” Should emit NFTMinted event (220ms)
    âœ” Should revert if quantity is zero (255ms)
    âœ” Should revert if quantity exceeds 10 (370ms)
    âœ” Should revert if insufficient payment (179ms)
    âœ” Should revert if exceeds max supply (907ms)
    âœ” Should allow owner to mint for free (239ms)
    âœ” Should revert if non-owner tries to owner mint (165ms)
    âœ” Should respect max supply for owner minting (304ms)
    âœ” Should return hidden URI when not revealed (194ms)
    âœ” Should return unique URI after reveal (391ms)
    âœ” Should emit Revealed event (164ms)
    âœ” Should revert if trying to reveal twice (184ms)
    âœ” Should revert if non-owner tries to reveal (214ms)
    âœ” Should revert tokenURI for non-existent token (161ms)
    âœ” Should allow owner to update mint price (219ms)
    âœ” Should emit PriceUpdated event (307ms)
    âœ” Should revert if non-owner tries to update price (124ms)
    âœ” Should allow owner to update base URI (320ms)
    âœ” Should allow owner to update not revealed URI (361ms)
    âœ” Should allow owner to withdraw contract balance (310ms)
    âœ” Should emit Withdrawn event (311ms)
    âœ” Should revert if no funds to withdraw (202ms)
    âœ” Should revert if non-owner tries to withdraw (230ms)
    âœ” Should return correct remaining supply (239ms)
    âœ” Should return wallet of owner correctly (321ms)
    âœ” Should return empty array for non-owners (90ms)
      Gas used for single mint: 96857
    âœ” Should use reasonable gas for single mint (208ms)
      Gas used for 10 mints: 331235
      Gas per NFT: 33123
    âœ” Should be more efficient for batch minting (235ms)


  36 passing (44240ms)
```

## Test Coverage

### Run Coverage

```bash
npx hardhat test --coverage
```

**Expected output:**
```
  SimpleNFTCollection
    âœ“ All tests passing

| File Path ðŸ“¦                      | Line % ðŸ“ˆ | Statement % ðŸ“ˆ | Uncovered Lines ðŸ” | Partially Covered Lines ðŸ” |
| --------------------------------- | --------- | -------------- | ------------------ | -------------------------- |        
| contracts/SimpleNFTCollection.sol | 100.00    | 100.00         | -                  | -                          |        
| --------------------------------- | --------- | -------------- | ------------------ | -------------------------- |        
| Total                             | 100.00    | 100.00         |                    |                            | 
```

**Aim for:**
- âœ… 95% statement coverage
- âœ… 95% line coverage

## Test Best Practices

### 1. Deploy Fresh Contracts Per Test

**Why:** Ensures test isolation and predictable state

**Pattern:**
```typescript
it("Should mint a single NFT with correct payment", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [
    "Test NFT",
    "TNFT",
    "ipfs://revealed/",
    "ipfs://hidden.json",
    claimant.account.address,
  ]);

  const mintPrice = await nft.read.mintPrice();
  await nft.write.mint([1n], {
    account: user1.account,
    value: mintPrice,
  });

  assert.equal(await nft.read.totalMinted(), 1n);
});
```

### 2. Test One Thing Per Test

**Good:**
```typescript
it("Should mint NFT with correct payment", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  
  const mintPrice = await nft.read.mintPrice();
  await nft.write.mint([1n], {
    account: user1.account,
    value: mintPrice,
  });
  
  assert.equal(await nft.read.totalMinted(), 1n);
});

it("Should revert if insufficient payment", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  
  const mintPrice = await nft.read.mintPrice();
  const underpayment = mintPrice - 1n;
  
  await assert.rejects(
    async () => await nft.write.mint([1n], {
      account: user1.account,
      value: underpayment,
    }),
    /Insufficient payment/
  );
});
```

**Bad:**
```typescript
it("Should mint NFT", async function () {
  // Tests minting, payment, events, ownership, supply... too much!
});
```

### 3. Use Descriptive Test Names

**Good:**
```typescript
it("Should revert if non-owner tries to reveal")
it("Should refund excess payment")
it("Should emit NFTMinted event")
```

**Bad:**
```typescript
it("Reveal test 1")
it("Test minting")
```

### 4. Test Both Success and Failure

For every function:
- âœ… Test successful execution
- âœ… Test all revert conditions
- âœ… Test edge cases

**Example:**
```typescript
// Success case
it("Should allow owner to mint for free", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  
  await nft.write.ownerMint([user1.account.address, 5n]);
  
  assert.equal(await nft.read.totalMinted(), 5n);
});

// Failure case
it("Should revert if non-owner tries to owner mint", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  
  await assert.rejects(
    async () => await nft.write.ownerMint([user1.account.address, 1n], {
      account: user1.account,
    })
  );
});
```

### 5. Verify Events

**Pattern:**
```typescript
it("Should emit NFTMinted event", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  const publicClient = await viem.getPublicClient();

  const mintPrice = await nft.read.mintPrice();
  const hash = await nft.write.mint([3n], {
    account: user1.account,
    value: mintPrice * 3n,
  });

  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  
  assert.ok(receipt.logs.length > 0, "Should emit NFTMinted event");
});
```

### 6. Check State Changes with Node Assert

**Pattern:**
```typescript
it("Should return correct remaining supply", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  
  assert.equal(await nft.read.remainingSupply(), 100n);
  
  const ownerAddr = await nft.read.owner();
  await nft.write.ownerMint([ownerAddr, 25n]);
  
  assert.equal(await nft.read.remainingSupply(), 75n);
});
```

### 7. Use assert.rejects for Expected Failures

**Pattern:**
```typescript
it("Should revert if quantity is zero", async function () {
  const nft = await viem.deployContract("SimpleNFTCollection", [...]);
  
  const mintPrice = await nft.read.mintPrice();
  
  await assert.rejects(
    async () => await nft.write.mint([0n], {
      account: user1.account,
      value: mintPrice,
    }),
    /Quantity must be greater than 0/
  );
});
```

## Common Test Failures

### "Transaction reverted without a reason string"

**Cause:** `require` statement failed but no error message

**Solution:** Add descriptive error messages to all `require` statements

### "Gas estimation failed"

**Cause:** Transaction would revert

**Solution:** Check test setup, ensure correct parameters

### "Nonce too high"

**Cause:** Test account state conflict

**Solution:** Use fresh accounts via fixtures

### "Insufficient funds"

**Cause:** Test account ran out of ZIL

**Solution:** Use `loadFixture` to reset state

Now tests run automatically on every commit!

## Pre-Deployment Checklist

Before deploying to mainnet:

- [ ] **All tests passing** (36/36)
- [ ] **100% code coverage**
- [ ] **Gas usage optimized** (under 150k per mint)
- [ ] **Security tests passing**
- [ ] **Edge cases covered**
- [ ] **Testnet deployed and tested**
- [ ] **Metadata pinned to IPFS**
- [ ] **Reveal tested on testnet**
- [ ] **Withdrawal tested**
- [ ] **Multiple users tested**

## Wrap-Up

You've successfully:

âœ… **Written comprehensive tests** for all contract functions  
âœ… **Tested minting logic** (paid, owner, batch)  
âœ… **Tested reveal mechanics** (hidden â†’ revealed)  
âœ… **Tested payment handling** (pricing, refunds, withdrawals)  
âœ… **Tested access control** (owner-only functions)  
âœ… **Tested edge cases** (supply limits, zero values)  
âœ… **Verified gas efficiency** (under 150k per mint)  
âœ… **Achieved 100% code coverage**  

**Your NFT collection is now:**
- Thoroughly tested
- Production-ready
- Security validated
- Gas optimized
- Ready for mainnet deployment!

## Achievement Complete! ðŸŽ‰

You've completed the entire NFT Collection Practical module!

**You now have:**
1. âœ… Deep understanding of NFT contracts
2. âœ… Deployed NFT collection on Zilliqa testnet
3. âœ… Real metadata and images on IPFS
4. âœ… Working reveal mechanics
5. âœ… Comprehensive test suite

**Claim your achievement:**
- Visit https://plunderacademy.com/lessons/island3/nft-collection-practical
- Connect your training portal wallet
- Submit your deployment transaction hash
- Receive your achievement NFT!

**What's next?**
- Deploy to mainnet (when ready)
- Create your own unique collection
- Build a minting website
- List on OpenSea or other marketplaces
- Experiment with advanced features (royalties, allowlists, etc.)

Congratulations, NFT Developer! ðŸš€

