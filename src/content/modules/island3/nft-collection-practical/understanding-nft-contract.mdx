---
id: understanding-nft-contract
module: nft-collection-practical
number: 3.7.2
title: Understanding the SimpleNFTCollection Contract
objective: >-
  Deep dive into the NFT collection contract, understanding every function, design decision, and security consideration.
slug: understanding-nft-contract
---

## Contract Overview

The `SimpleNFTCollection` contract is a production-ready ERC721 NFT collection with reveal mechanics, paid minting, and achievement tracking. It's built on OpenZeppelin's battle-tested contracts and follows all industry standards.

**Key features:**
- ‚úÖ ERC721 standard compliance (marketplace compatible)
- ‚úÖ Fixed supply (100 tokens)
- ‚úÖ Paid minting (0.01 ZIL default, adjustable)
- ‚úÖ Batch minting support
- ‚úÖ Reveal mechanics (hidden ‚Üí revealed)
- ‚úÖ Owner controls (pricing, URIs, reveal)
- ‚úÖ Payment withdrawal
- ‚úÖ Claimant tracking (achievement verification)

## Full Contract Code

Here's the complete contract we'll be deploying:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title SimpleNFTCollection
 * @dev A production-ready NFT collection contract for educational purposes
 * Features:
 * - Fixed supply minting (100 tokens)
 * - Paid minting with ZIL
 * - Metadata URI management
 * - Reveal mechanics
 * - Owner controls for price and base URI
 * - Claimant tracking for achievement verification
 */
contract SimpleNFTCollection is ERC721, Ownable {
    using Strings for uint256;

    // Collection parameters
    uint256 public constant MAX_SUPPLY = 100;
    uint256 public mintPrice = 0.01 ether;
    uint256 public totalMinted = 0;
    
    // Metadata
    string private baseTokenURI;
    bool public isRevealed = false;
    string public notRevealedUri;
    
    // Achievement tracking
    address public claimant;

    // Events
    event NFTMinted(address indexed minter, uint256 indexed tokenId, uint256 quantity);
    event PriceUpdated(uint256 newPrice);
    event BaseURIUpdated(string newBaseURI);
    event Revealed(string newBaseURI);
    event Withdrawn(address indexed recipient, uint256 amount);

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _initBaseURI,
        string memory _notRevealedUri,
        address _claimant
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        require(_claimant != address(0), "Invalid claimant address");
        baseTokenURI = _initBaseURI;
        notRevealedUri = _notRevealedUri;
        claimant = _claimant;
    }

    /**
     * @dev Mint NFTs (paid)
     * Requirements:
     * - Must send exact mint price * quantity
     * - Supply must not be exceeded
     */
    function mint(uint256 _quantity) public payable {
        require(_quantity > 0, "Quantity must be greater than 0");
        require(_quantity <= 10, "Cannot mint more than 10 at once");
        require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");
        require(msg.value >= mintPrice * _quantity, "Insufficient payment");

        uint256 startTokenId = totalMinted + 1;
        
        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = totalMinted + 1;
            totalMinted++;
            _safeMint(msg.sender, tokenId);
        }

        emit NFTMinted(msg.sender, startTokenId, _quantity);

        // Refund excess payment
        if (msg.value > mintPrice * _quantity) {
            payable(msg.sender).transfer(msg.value - (mintPrice * _quantity));
        }
    }

    /**
     * @dev Owner can mint for free (e.g., for giveaways)
     */
    function ownerMint(address _to, uint256 _quantity) public onlyOwner {
        require(_quantity > 0, "Quantity must be greater than 0");
        require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");

        uint256 startTokenId = totalMinted + 1;
        
        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = totalMinted + 1;
            totalMinted++;
            _safeMint(_to, tokenId);
        }

        emit NFTMinted(_to, startTokenId, _quantity);
    }

    /**
     * @dev Returns the token URI for a given token ID
     */
    function tokenURI(uint256 tokenId) 
        public 
        view 
        virtual 
        override 
        returns (string memory) 
    {
        require(ownerOf(tokenId) != address(0), "Token does not exist");

        if (!isRevealed) {
            return notRevealedUri;
        }

        return bytes(baseTokenURI).length > 0
            ? string(abi.encodePacked(baseTokenURI, tokenId.toString(), ".json"))
            : "";
    }

    /**
     * @dev Update the mint price (owner only)
     */
    function setMintPrice(uint256 _newPrice) public onlyOwner {
        mintPrice = _newPrice;
        emit PriceUpdated(_newPrice);
    }

    /**
     * @dev Update the base URI (owner only)
     */
    function setBaseURI(string memory _newBaseURI) public onlyOwner {
        baseTokenURI = _newBaseURI;
        emit BaseURIUpdated(_newBaseURI);
    }

    /**
     * @dev Set the not revealed URI
     */
    function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {
        notRevealedUri = _notRevealedURI;
    }

    /**
     * @dev Reveal the collection
     */
    function reveal() public onlyOwner {
        require(!isRevealed, "Already revealed");
        isRevealed = true;
        emit Revealed(baseTokenURI);
    }

    /**
     * @dev Withdraw contract balance (owner only)
     */
    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        payable(owner()).transfer(balance);
        emit Withdrawn(owner(), balance);
    }

    /**
     * @dev Get tokens owned by an address
     */
    function walletOfOwner(address _owner) 
        public 
        view 
        returns (uint256[] memory) 
    {
        uint256 ownerTokenCount = balanceOf(_owner);
        uint256[] memory tokenIds = new uint256[](ownerTokenCount);
        uint256 currentIndex = 0;

        for (uint256 i = 1; i <= totalMinted; i++) {
            if (ownerOf(i) == _owner) {
                tokenIds[currentIndex] = i;
                currentIndex++;
            }
        }

        return tokenIds;
    }

    /**
     * @dev Check how many NFTs are still available
     */
    function remainingSupply() public view returns (uint256) {
        return MAX_SUPPLY - totalMinted;
    }
}
```

## Contract Architecture

### Inheritance Hierarchy

```
SimpleNFTCollection
‚îú‚îÄ‚îÄ ERC721 (OpenZeppelin)
‚îÇ   ‚îî‚îÄ‚îÄ Core NFT functionality
‚îÇ       ‚îú‚îÄ‚îÄ ownerOf(tokenId)
‚îÇ       ‚îú‚îÄ‚îÄ balanceOf(owner)
‚îÇ       ‚îú‚îÄ‚îÄ transferFrom(from, to, tokenId)
‚îÇ       ‚îú‚îÄ‚îÄ safeTransferFrom(from, to, tokenId)
‚îÇ       ‚îî‚îÄ‚îÄ approve(to, tokenId)
‚îî‚îÄ‚îÄ Ownable (OpenZeppelin)
    ‚îî‚îÄ‚îÄ Owner-only functions
        ‚îú‚îÄ‚îÄ onlyOwner modifier
        ‚îú‚îÄ‚îÄ owner() view
        ‚îî‚îÄ‚îÄ transferOwnership(newOwner)
```

**Why this structure?**
- **ERC721**: Provides standard NFT functionality that all wallets and marketplaces understand
- **Ownable**: Gives us secure admin controls (pricing, reveal, withdrawal)

This is the same pattern as your staking contract, which inherited `Ownable` and `ReentrancyGuard`.

## Line-by-Line Walkthrough

### 1. SPDX License and Pragma

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;
```

**Why 0.8.28?**
- Latest stable Solidity version
- Matches Zilliqa 2.0 requirements (shanghai EVM)
- Same as your staking contract for consistency
- Built-in overflow protection (no SafeMath needed)

### 2. Imports

```solidity
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
```

**OpenZeppelin contracts:**
- `ERC721`: Core NFT standard implementation
- `Ownable`: Owner-only function modifier
- `Strings`: Convert uint256 ‚Üí string for tokenURI

**Why OpenZeppelin?**
- Battle-tested (used by billions in production)
- Audited by security experts
- Gas-optimized
- Industry standard

### 3. State Variables

```solidity
// Collection parameters
uint256 public constant MAX_SUPPLY = 100;
uint256 public mintPrice = 0.01 ether;
uint256 public totalMinted = 0;
```

**MAX_SUPPLY = 100**
- `constant` = can't be changed (enforces scarcity)
- Public visibility = anyone can read it
- Set to 100 for educational purposes (adjust for production)

**mintPrice = 0.01 ether**
- Cost to mint one NFT
- `ether` keyword = 10^18 wei (Solidity unit)
- Owner can change this via `setMintPrice()`

**totalMinted = 0**
- Tracks how many NFTs have been minted
- Increments with each mint
- Used to enforce MAX_SUPPLY cap

### 4. Metadata Variables

```solidity
// Metadata
string private baseTokenURI;
bool public isRevealed = false;
string public notRevealedUri;
```

**baseTokenURI**
- IPFS link to revealed metadata folder
- Example: `"ipfs://QmHash/"`
- Combined with tokenId to form full URI

**isRevealed**
- Boolean flag: false = hidden, true = revealed
- Starts as `false` (mystery box)
- Owner calls `reveal()` to switch to `true`

**notRevealedUri**
- IPFS link to placeholder metadata
- Example: `"ipfs://QmPlaceholder/hidden.json"`
- All tokens show this until reveal

**Reveal flow:**
1. Deploy with `notRevealedUri = "ipfs://hidden"`
2. Users mint ‚Üí all show hidden.json
3. Owner calls `reveal()`
4. Now all tokens show `ipfs://revealed/{tokenId}.json`

### 5. Achievement Tracking

```solidity
// Achievement tracking
address public claimant;
```

**claimant**
- Your Plunder Academy training portal wallet
- Set in constructor
- Used to verify you completed the module
- Same pattern as staking contract

**How it works:**
1. You set `claimant` to your wallet address
2. Deploy the contract
3. Submit deployment transaction hash to training portal
4. Portal verifies `claimant` matches your connected wallet
5. You receive achievement NFT!

### 6. Events

```solidity
// Events
event NFTMinted(address indexed minter, uint256 indexed tokenId, uint256 quantity);
event PriceUpdated(uint256 newPrice);
event BaseURIUpdated(string newBaseURI);
event Revealed(string newBaseURI);
event Withdrawn(address indexed recipient, uint256 amount);
```

**Why events?**
- Indexed by block explorers (searchable)
- Used by marketplaces (OpenSea tracks NFTMinted)
- Cheap gas cost (logged, not stored in state)
- Frontend can listen for real-time updates

**indexed parameters:**
- `indexed minter` = searchable by minter address
- `indexed tokenId` = searchable by token ID
- Non-indexed = logged but not searchable (cheaper)

### 7. Constructor

```solidity
constructor(
    string memory _name,
    string memory _symbol,
    string memory _initBaseURI,
    string memory _notRevealedUri,
    address _claimant
) ERC721(_name, _symbol) Ownable(msg.sender) {
    require(_claimant != address(0), "Invalid claimant address");
    baseTokenURI = _initBaseURI;
    notRevealedUri = _notRevealedUri;
    claimant = _claimant;
}
```

**Parameters:**
- `_name`: Collection name (e.g., "Plunder NFT")
- `_symbol`: Collection symbol (e.g., "PNFT")
- `_initBaseURI`: IPFS link for revealed metadata
- `_notRevealedUri`: IPFS link for hidden metadata
- `_claimant`: Your training portal wallet

**Execution flow:**
1. `ERC721(_name, _symbol)` ‚Üí Initialize parent contract
2. `Ownable(msg.sender)` ‚Üí Set deployer as owner
3. `require(_claimant != address(0))` ‚Üí Validate claimant
4. Set state variables

**Why validate claimant?**
- Prevents accidental deployment with zero address
- Ensures achievement can be claimed
- Fail-fast validation (catch errors early)

### 8. Mint Function (Paid)

```solidity
function mint(uint256 _quantity) public payable {
    require(_quantity > 0, "Quantity must be greater than 0");
    require(_quantity <= 10, "Cannot mint more than 10 at once");
    require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");
    require(msg.value >= mintPrice * _quantity, "Insufficient payment");

    uint256 startTokenId = totalMinted + 1;
    
    for (uint256 i = 0; i < _quantity; i++) {
        uint256 tokenId = totalMinted + 1;
        totalMinted++;
        _safeMint(msg.sender, tokenId);
    }

    emit NFTMinted(msg.sender, startTokenId, _quantity);

    // Refund excess payment
    if (msg.value > mintPrice * _quantity) {
        payable(msg.sender).transfer(msg.value - (mintPrice * _quantity));
    }
}
```

**Step-by-step:**

**1. Validate quantity**
```solidity
require(_quantity > 0, "Quantity must be greater than 0");
require(_quantity <= 10, "Cannot mint more than 10 at once");
```
- Must mint at least 1
- Max 10 per transaction (prevents gas limit issues)

**2. Check supply**
```solidity
require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");
```
- Enforces the 100 token cap
- Prevents overselling

**3. Validate payment**
```solidity
require(msg.value >= mintPrice * _quantity, "Insufficient payment");
```
- `msg.value` = ZIL sent with transaction
- Must send at least `mintPrice * quantity`
- Example: mint 3 NFTs = 0.03 ZIL minimum

**4. Mint loop**
```solidity
uint256 startTokenId = totalMinted + 1;

for (uint256 i = 0; i < _quantity; i++) {
    uint256 tokenId = totalMinted + 1;
    totalMinted++;
    _safeMint(msg.sender, tokenId);
}
```
- Token IDs start at 1 (not 0)
- Increment `totalMinted` before each mint
- `_safeMint` checks recipient can receive NFTs

**Why _safeMint instead of _mint?**
- `_safeMint`: Checks if recipient is a contract that can handle NFTs
- Prevents NFTs being locked in incompatible contracts
- Required for marketplace compatibility

**5. Emit event**
```solidity
emit NFTMinted(msg.sender, startTokenId, _quantity);
```
- Marketplaces listen for this event
- Shows batch mint (e.g., "Minted tokens 5-7")

**6. Refund excess**
```solidity
if (msg.value > mintPrice * _quantity) {
    payable(msg.sender).transfer(msg.value - (mintPrice * _quantity));
}
```
- User sent 0.05 ZIL but only needed 0.03 ZIL?
- Automatically refund 0.02 ZIL
- Great UX (no overpayment)

### 9. Owner Mint Function

```solidity
function ownerMint(address _to, uint256 _quantity) public onlyOwner {
    require(_quantity > 0, "Quantity must be greater than 0");
    require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");

    uint256 startTokenId = totalMinted + 1;
    
    for (uint256 i = 0; i < _quantity; i++) {
        uint256 tokenId = totalMinted + 1;
        totalMinted++;
        _safeMint(_to, tokenId);
    }

    emit NFTMinted(_to, startTokenId, _quantity);
}
```

**Purpose:**
- Owner can mint for free (no payment required)
- Use cases: giveaways, team allocation, marketing

**Key differences from mint():**
- `onlyOwner` modifier (only contract owner can call)
- No `payable` (doesn't accept ZIL)
- No payment validation
- Can mint to any address (`_to` parameter)

**Still respects:**
- MAX_SUPPLY cap
- Same `_safeMint` safety checks
- Emits same event

### 10. Token URI Function

```solidity
function tokenURI(uint256 tokenId) 
    public 
    view 
    virtual 
    override 
    returns (string memory) 
{
    require(ownerOf(tokenId) != address(0), "Token does not exist");

    if (!isRevealed) {
        return notRevealedUri;
    }

    return bytes(baseTokenURI).length > 0
        ? string(abi.encodePacked(baseTokenURI, tokenId.toString(), ".json"))
        : "";
}
```

**This is the heart of NFT metadata!**

**1. Check token exists**
```solidity
require(ownerOf(tokenId) != address(0), "Token does not exist");
```
- `ownerOf()` reverts if token doesn't exist
- Prevents returning metadata for unminted tokens

**2. Hidden state**
```solidity
if (!isRevealed) {
    return notRevealedUri;
}
```
- If not revealed, all tokens show same URI
- Example: `"ipfs://QmPlaceholder/hidden.json"`
- All 100 tokens show same mystery box image

**3. Revealed state**
```solidity
return bytes(baseTokenURI).length > 0
    ? string(abi.encodePacked(baseTokenURI, tokenId.toString(), ".json"))
    : "";
```
- Concatenate: `baseURI + tokenId + ".json"`
- Example: `"ipfs://QmRevealed/" + "42" + ".json"`
- Result: `"ipfs://QmRevealed/42.json"`

**Why .toString()?**
- tokenId is uint256 (number)
- Need to convert to string for URI
- Strings library provides this helper

### 11. Admin Functions

```solidity
function setMintPrice(uint256 _newPrice) public onlyOwner {
    mintPrice = _newPrice;
    emit PriceUpdated(_newPrice);
}

function setBaseURI(string memory _newBaseURI) public onlyOwner {
    baseTokenURI = _newBaseURI;
    emit BaseURIUpdated(_newBaseURI);
}

function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {
    notRevealedUri = _notRevealedURI;
}
```

**All use onlyOwner modifier:**
- Only contract owner can call these
- Inherited from Ownable
- Prevents unauthorized changes

**Use cases:**
- `setMintPrice`: Adjust pricing based on demand
- `setBaseURI`: Update IPFS link after pinning
- `setNotRevealedURI`: Update placeholder if needed

**Events emitted:**
- Transparency (community can track changes)
- Indexable by block explorers
- Good practice for admin actions

### 12. Reveal Function

```solidity
function reveal() public onlyOwner {
    require(!isRevealed, "Already revealed");
    isRevealed = true;
    emit Revealed(baseTokenURI);
}
```

**The big moment!**

**One-way switch:**
- `require(!isRevealed)` = can only reveal once
- Prevents re-hiding after reveal
- Builds trust (no rug pulls)

**What happens:**
1. Before: `tokenURI(42)` returns `notRevealedUri`
2. Owner calls `reveal()`
3. After: `tokenURI(42)` returns `baseURI + "42.json"`

**All tokens reveal instantly:**
- No per-token reveal needed
- Gas efficient (single transaction)
- Fair (all collectors revealed together)

### 13. Withdraw Function

```solidity
function withdraw() public onlyOwner {
    uint256 balance = address(this).balance;
    require(balance > 0, "No funds to withdraw");
    payable(owner()).transfer(balance);
    emit Withdrawn(owner(), balance);
}
```

**Collect mint payments:**
- Users pay ZIL to mint
- Funds accumulate in contract
- Owner withdraws to their wallet

**Security checks:**
- `onlyOwner` = only owner can withdraw
- `require(balance > 0)` = prevents empty withdrawal
- `payable(owner())` = convert address to payable
- `emit Withdrawn` = transparent record

**Best practice:**
- Withdraw periodically (don't let funds sit)
- Consider multisig wallet for production
- Track withdrawals via events

### 14. Utility Functions

```solidity
function walletOfOwner(address _owner) 
    public 
    view 
    returns (uint256[] memory) 
{
    uint256 ownerTokenCount = balanceOf(_owner);
    uint256[] memory tokenIds = new uint256[](ownerTokenCount);
    uint256 currentIndex = 0;

    for (uint256 i = 1; i <= totalMinted; i++) {
        if (ownerOf(i) == _owner) {
            tokenIds[currentIndex] = i;
            currentIndex++;
        }
    }

    return tokenIds;
}

function remainingSupply() public view returns (uint256) {
    return MAX_SUPPLY - totalMinted;
}
```

**walletOfOwner:**
- Returns all token IDs owned by an address
- Example: `[5, 12, 47]` = owns tokens 5, 12, and 47
- Useful for frontends (show user's collection)

**Gas warning:**
- Loops through all minted tokens
- Can be expensive for large collections
- Use off-chain for production (The Graph, Moralis)

**remainingSupply:**
- Shows how many NFTs left to mint
- Example: `100 - 73 = 27 remaining`
- Simple but useful for UI

## Design Decisions

### Why Sequential Token IDs (1, 2, 3...)?

**Pros:**
- Simple and predictable
- Easy to generate metadata
- Fair (no cherry-picking rare tokens)

**Cons:**
- Later minters know distribution
- No randomness (for rarity)

**For production:**
- Consider random minting (Chainlink VRF)
- Or shuffle metadata order
- Or use commit-reveal scheme

### Why Limit to 10 Per Transaction?

```solidity
require(_quantity <= 10, "Cannot mint more than 10 at once");
```

**Prevents:**
- Gas limit issues (loops are expensive)
- Frontrunning entire supply
- Block stuffing attacks

**Production considerations:**
- Lower for expensive mints (1-5)
- Higher for cheap mints (20+)
- Remove limit for owner minting

### Why Not Reentrancy Guard?

**Staking contract had:**
```solidity
contract Staking is Ownable, ReentrancyGuard {
    function withdraw() public nonReentrant { ... }
}
```

**NFT contract doesn't need it because:**
- Refund happens AFTER minting completes
- No external calls before state changes
- Withdraw sends to owner (trusted)

**When you'd need it:**
- If you callback to minter during mint
- If you integrate with external contracts
- If you implement complex royalty splits

### Why Refund Excess Payment?

```solidity
if (msg.value > mintPrice * _quantity) {
    payable(msg.sender).transfer(msg.value - (mintPrice * _quantity));
}
```

**Alternative: Keep excess**
```solidity
// Just keep all ZIL sent
// Simpler, no refund logic
```

**Why we refund:**
- Better UX (no accidental overpayment)
- More trust (transparent pricing)
- Expected behavior (industry standard)

**Trade-off:**
- Slightly more gas (extra transfer)
- But worth it for user experience

## Security Considerations

### 1. Supply Cap Enforcement

```solidity
require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");
```

**What if we forgot this?**
- Infinite minting possible
- Devalues entire collection
- Breaks scarcity promise

**Always enforce caps!**

### 2. Zero Address Validation

```solidity
require(_claimant != address(0), "Invalid claimant address");
```

**Catches:**
- Typos in deployment script
- Accidental zero address
- Invalid configuration

**Best practice:**
- Validate all address parameters
- Especially in constructor (can't fix later)

### 3. Safe Minting

```solidity
_safeMint(msg.sender, tokenId);
```

**vs unsafe _mint:**
```solidity
_mint(msg.sender, tokenId);
```

**Why safe?**
- Checks if recipient is a contract
- If contract, requires IERC721Receiver implementation
- Prevents NFTs locked forever

**When not needed:**
- You know recipient is EOA (external account)
- Gas savings critical
- Custom receiver logic

### 4. Owner-Only Functions

```solidity
function setMintPrice(uint256 _newPrice) public onlyOwner {
    mintPrice = _newPrice;
    emit PriceUpdated(_newPrice);
}
```

**Without onlyOwner:**
- Anyone could set price to 0
- Anyone could withdraw funds
- Anyone could reveal early

**Critical for security!**

### 5. One-Way Reveal

```solidity
require(!isRevealed, "Already revealed");
```

**Prevents:**
- Re-hiding after reveal (rug pull)
- Owner favoritism (reveal, check, re-hide)
- Trust issues

**Builds confidence:**
- Once revealed, it's final
- No take-backs
- Provably fair

## Comparison to Staking Contract

### Similarities

<table>
<thead>
<tr>
<th>Feature</th>
<th>Staking</th>
<th>NFT</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenZeppelin base</td>
<td>‚úÖ Ownable, ReentrancyGuard</td>
<td>‚úÖ ERC721, Ownable</td>
</tr>
<tr>
<td>Owner controls</td>
<td>‚úÖ APY, fees, rewards</td>
<td>‚úÖ Price, URIs, reveal</td>
</tr>
<tr>
<td>Claimant tracking</td>
<td>‚úÖ For achievements</td>
<td>‚úÖ For achievements</td>
</tr>
<tr>
<td>Events</td>
<td>‚úÖ Deposit, Withdraw</td>
<td>‚úÖ Mint, Reveal</td>
</tr>
<tr>
<td>Supply limits</td>
<td>‚úÖ (via deposits)</td>
<td>‚úÖ MAX_SUPPLY</td>
</tr>
<tr>
<td>Payment handling</td>
<td>‚úÖ ERC20 deposits</td>
<td>‚úÖ ZIL payments</td>
</tr>
</tbody>
</table>

### Differences

<table>
<thead>
<tr>
<th>Aspect</th>
<th>Staking</th>
<th>NFT</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Token type</strong></td>
<td>ERC20 (fungible)</td>
<td>ERC721 (non-fungible)</td>
</tr>
<tr>
<td><strong>User receives</strong></td>
<td>Rewards over time</td>
<td>Unique NFT instantly</td>
</tr>
<tr>
<td><strong>Payment</strong></td>
<td>Deposit ERC20 tokens</td>
<td>Send ZIL</td>
</tr>
<tr>
<td><strong>Time logic</strong></td>
<td>Complex (APY, duration)</td>
<td>None (instant mint)</td>
</tr>
<tr>
<td><strong>Loops</strong></td>
<td>Avoid (gas issues)</td>
<td>Small loops OK (‚â§10)</td>
</tr>
<tr>
<td><strong>Metadata</strong></td>
<td>None</td>
<td>IPFS URIs</td>
</tr>
<tr>
<td><strong>Reentrancy</strong></td>
<td>High risk (needed guard)</td>
<td>Low risk (no guard)</td>
</tr>
</tbody>
</table>

## Common Pitfalls

### ‚ùå Starting Token IDs at 0

```solidity
// DON'T
for (uint256 i = 0; i < _quantity; i++) {
    _safeMint(msg.sender, totalMinted); // Starts at 0
    totalMinted++;
}
```

**Problem:** Token ID 0 can cause issues with some marketplaces

**Solution:** Start at 1
```solidity
// DO
uint256 tokenId = totalMinted + 1;
_safeMint(msg.sender, tokenId);
totalMinted++;
```

### ‚ùå Not Validating Payment

```solidity
// DON'T
function mint(uint256 _quantity) public payable {
    // No payment check!
    _safeMint(msg.sender, tokenId);
}
```

**Problem:** Free minting for everyone (no revenue)

**Solution:** Always validate
```solidity
require(msg.value >= mintPrice * _quantity, "Insufficient payment");
```

### ‚ùå Forgetting Supply Cap

```solidity
// DON'T
function mint() public payable {
    // No supply check!
    _safeMint(msg.sender, totalMinted);
    totalMinted++;
}
```

**Problem:** Infinite minting destroys scarcity

**Solution:** Always check supply
```solidity
require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");
```

### ‚ùå Revealing Before Metadata Ready

**Problem:**
1. Deploy contract
2. Reveal immediately
3. Upload metadata to IPFS
4. Result: Broken links!

**Solution:**
1. Deploy with placeholder URI
2. Generate and upload metadata to IPFS
3. Update baseURI
4. **Then** reveal

## Gas Optimization Notes

### Batch Minting

```solidity
// Cheaper to mint 10 in one transaction than 10 separate
mint(10); // ~200k gas
// vs
mint(1); // ~70k gas x 10 = ~700k gas
```

**Why?**
- Base transaction cost paid once
- Loop overhead amortized
- Event emitted once

### Read from Constants

```solidity
uint256 public constant MAX_SUPPLY = 100; // 0 gas to read
```

vs

```solidity
uint256 public maxSupply = 100; // 2100 gas to read (SLOAD)
```

**Constants are inlined at compile time!**

### String Concatenation

```solidity
string(abi.encodePacked(baseTokenURI, tokenId.toString(), ".json"))
```

**Expensive in loops!**
- Use for view functions only
- Never in state-changing functions
- Consider off-chain for large collections

## Next Steps

You now understand every line of the NFT contract! 

**Next lesson:** We'll set up the Hardhat 3 project and deploy this contract to Zilliqa testnet using the exact same workflow as your staking contract.

Ready to deploy? Let's go! üöÄ

