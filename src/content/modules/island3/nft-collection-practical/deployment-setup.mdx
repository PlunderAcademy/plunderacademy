---
id: deployment-setup
module: nft-collection-practical
number: 3.7.3
title: Deploying Your NFT Collection
objective: >-
  Deploy your NFT collection using Hardhat 3, test locally, deploy to Zilliqa testnet, and integrate claimant tracking for achievement verification.
slug: deployment-setup
---

## Deployment Overview

In this lesson, you'll deploy a production-ready NFT collection to Zilliqa testnet. The deployment process includes:

1. **Project setup** with Hardhat 3 and OpenZeppelin
2. **Contract preparation** with claimant integration
3. **Local testing** with Hardhat node
4. **Deployment scripts** for automated deployment
5. **Zilliqa testnet deployment** with verification
6. **Achievement claiming** using your transaction hash

**Important** We'll deploy with placeholder IPFS URIs first, then add real metadata in the next lesson. This ensures your contract is deployed and verified before handling metadata.

## Project Setup

### Create New Project

```bash
# Create project directory
mkdir my-nft-collection
cd my-nft-collection

# Initialize Node project
npm init -y

# Install Hardhat 3 and toolbox
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox-viem

# Initialize Hardhat
npx hardhat --init
# Choose: 
# "Hardhat 3"
# "use the default for relative or absolute path"
# "Create a TypeScript project (with Viem)"
# Accept all other defaults
```

### Install Dependencies

```bash
# OpenZeppelin contracts (ERC721, Ownable)
npm install @openzeppelin/contracts

# Dotenv for environment variables
npm install dotenv

# TypeScript support
npm install --save-dev typescript @types/node

# Small change needed in the tsconfig.json file
# Add this line to the compilerOptions:
# "resolveJsonModule": true,
```

### Project Structure

Your project should look like this (when we are done!):

```
my-nft-collection/
‚îú‚îÄ‚îÄ contracts/
‚îÇ   ‚îî‚îÄ‚îÄ SimpleNFTCollection.sol
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ deploy-nft.ts
‚îÇ   ‚îú‚îÄ‚îÄ mint-nft.ts
‚îÇ   ‚îú‚îÄ‚îÄ reveal.ts
‚îÇ   ‚îú‚îÄ‚îÄ interact.ts
‚îÇ   ‚îî‚îÄ‚îÄ generate-svgs.js        # Added in next lesson
‚îú‚îÄ‚îÄ metadata/                    # Added in next lesson
‚îÇ   ‚îú‚îÄ‚îÄ hidden.json
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îî‚îÄ‚îÄ revealed/
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ SimpleNFTCollection.test.ts
‚îú‚îÄ‚îÄ hardhat.config.ts
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .env
‚îî‚îÄ‚îÄ .gitignore
```

**For now, remove the default files:**
- Delete `contracts/Counter.sol`
- Delete `contracts/Counter.t.sol`
- Delete entire `ignition` directory
- Delete `scripts/send-op-tx.ts`
- Delete `test/Counter.ts`

## Configuring Hardhat for Zilliqa

### Update hardhat.config.ts

This is **identical** to your staking contract configuration:

```typescript
import type { HardhatUserConfig } from "hardhat/config";

import hardhatToolboxViemPlugin from "@nomicfoundation/hardhat-toolbox-viem";
import hardhatVerifyPlugin from "@nomicfoundation/hardhat-verify";
import hardhatNetworkHelpers from "@nomicfoundation/hardhat-network-helpers";
import { configVariable } from "hardhat/config";
import "dotenv/config";

const config: HardhatUserConfig = {
  plugins: [hardhatToolboxViemPlugin, hardhatVerifyPlugin, hardhatNetworkHelpers],
  solidity: {
    profiles: {
      default: {
        version: "0.8.28",
        settings: {
          evmVersion: "shanghai", // Required for Zilliqa 2.0 compatibility
        },
      },
      production: {
        version: "0.8.28",
        settings: {
          optimizer: {
            enabled: true,
            runs: 200,
          },
          evmVersion: "shanghai", // Required for Zilliqa 2.0 compatibility
        },
      },
    },
  },
  networks: {
    hardhatMainnet: {
      type: "edr-simulated",
      chainType: "l1",
    },
    hardhatOp: {
      type: "edr-simulated",
      chainType: "op",
    },
    zilliqaMainnet: {
      type: "http",
      chainType: "l1",
      chainId: 32769,
      url: "https://api.zilliqa.com",
      accounts: [configVariable("ZILLIQA_MAINNET_PRIVATE_KEY")]
    },
    zilliqaTestnet: {
      type: "http",
      chainType: "l1",
      chainId: 33101,
      url: "https://api.testnet.zilliqa.com",
      accounts: [configVariable("ZILLIQA_TESTNET_PRIVATE_KEY")]
    },
  },
  verify: {
    // Disable Etherscan since we're using Zilliqa networks
    etherscan: {
      enabled: false,
    },
    // Blockscout verification (no API key needed)
    blockscout: {
      enabled: true,
    },
  },
  // Add custom chain descriptors for Zilliqa networks
  chainDescriptors: {
    // Zilliqa Mainnet
    32769: {
      name: "Zilliqa",
      blockExplorers: {
        blockscout: {
          name: "Zilliqa Explorer",
          url: "https://zilliqa.blockscout.com",
          apiUrl: "https://zilliqa.blockscout.com/api",
        },
      },
    },
    // Zilliqa Testnet
    33101: {
      name: "Zilliqa Testnet",
      blockExplorers: {
        blockscout: {
          name: "Zilliqa Testnet Explorer",
          url: "https://testnet.zilliqa.blockscout.com",
          apiUrl: "https://testnet.zilliqa.blockscout.com/api",
        },
      },
    },
  },
};

export default config;
```

**Key settings:**
- **Compiler:** Solidity 0.8.28 with optimizer enabled
- **evmVersion:** "shanghai" - Required for Zilliqa 2.0 compatibility
- **Zilliqa networks:** Testnet and mainnet configurations
- **Private keys:** Loaded from environment variables

### Setup Environment Variables

**Create `.env` file:**

```bash
# Generate a fresh development wallet
openssl rand -hex 32 | sed 's/^/ZILLIQA_TESTNET_PRIVATE_KEY=0x/' > .env

# Add claimant address
echo "CLAIMANT_ADDRESS=your_training_portal_wallet_here" >> .env
echo "" >> .env
echo "# WARNING: Never commit this file!" >> .env
echo "# Add .env to .gitignore" >> .env
```

**Important wallet setup:**

**Development Wallet** (in `.env` as `ZILLIQA_TESTNET_PRIVATE_KEY`):
- Generated fresh for security
- Used to deploy contracts and pay gas
- Funded with testnet ZIL from faucet

**Claimant Wallet** (in `.env` as `CLAIMANT_ADDRESS`):
- Your **Plunder Academy training portal wallet**
- Used to verify you completed the module
- Set as `claimant` in the contract constructor

### Update .gitignore

**Ensure `.env` is never committed:**

```bash
# Add to .gitignore
echo ".env" >> .gitignore
echo "node_modules/" >> .gitignore
echo "artifacts/" >> .gitignore
echo "cache/" >> .gitignore
echo "typechain-types/" >> .gitignore
```

## Creating the NFT Contract

### contracts/SimpleNFTCollection.sol

Create your NFT collection contract with claimant integration:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title SimpleNFTCollection
 * @dev A production-ready NFT collection contract for educational purposes
 * Features:
 * - Fixed supply minting (100 tokens)
 * - Paid minting with ZIL
 * - Metadata URI management
 * - Reveal mechanics
 * - Owner controls for price and base URI
 * - Claimant tracking for achievement verification
 */
contract SimpleNFTCollection is ERC721, Ownable {
    using Strings for uint256;

    // Collection parameters
    uint256 public constant MAX_SUPPLY = 100;
    uint256 public mintPrice = 1 ether;
    uint256 public totalMinted = 0;
    
    // Metadata
    string private baseTokenURI;
    bool public isRevealed = false;
    string public notRevealedUri;
    
    // Achievement tracking
    address public claimant;

    // Events
    event NFTMinted(address indexed minter, uint256 indexed tokenId, uint256 quantity);
    event PriceUpdated(uint256 newPrice);
    event BaseURIUpdated(string newBaseURI);
    event Revealed(string newBaseURI);
    event Withdrawn(address indexed recipient, uint256 amount);

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _initBaseURI,
        string memory _notRevealedUri,
        address _claimant
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        require(_claimant != address(0), "Invalid claimant address");
        baseTokenURI = _initBaseURI;
        notRevealedUri = _notRevealedUri;
        claimant = _claimant;
    }

    /**
     * @dev Mint NFTs (paid)
     * Requirements:
     * - Must send exact mint price * quantity
     * - Supply must not be exceeded
     */
    function mint(uint256 _quantity) public payable {
        require(_quantity > 0, "Quantity must be greater than 0");
        require(_quantity <= 10, "Cannot mint more than 10 at once");
        require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");
        require(msg.value >= mintPrice * _quantity, "Insufficient payment");

        uint256 startTokenId = totalMinted + 1;
        
        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = totalMinted + 1;
            totalMinted++;
            _safeMint(msg.sender, tokenId);
        }

        emit NFTMinted(msg.sender, startTokenId, _quantity);

        // Refund excess payment
        if (msg.value > mintPrice * _quantity) {
            payable(msg.sender).transfer(msg.value - (mintPrice * _quantity));
        }
    }

    /**
     * @dev Owner can mint for free (e.g., for giveaways)
     */
    function ownerMint(address _to, uint256 _quantity) public onlyOwner {
        require(_quantity > 0, "Quantity must be greater than 0");
        require(totalMinted + _quantity <= MAX_SUPPLY, "Exceeds max supply");

        uint256 startTokenId = totalMinted + 1;
        
        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = totalMinted + 1;
            totalMinted++;
            _safeMint(_to, tokenId);
        }

        emit NFTMinted(_to, startTokenId, _quantity);
    }

    /**
     * @dev Returns the token URI for a given token ID
     */
    function tokenURI(uint256 tokenId) 
        public 
        view 
        virtual 
        override 
        returns (string memory) 
    {
        require(ownerOf(tokenId) != address(0), "Token does not exist");

        if (!isRevealed) {
            return notRevealedUri;
        }

        return bytes(baseTokenURI).length > 0
            ? string(abi.encodePacked(baseTokenURI, tokenId.toString(), ".json"))
            : "";
    }

    /**
     * @dev Update the mint price (owner only)
     */
    function setMintPrice(uint256 _newPrice) public onlyOwner {
        mintPrice = _newPrice;
        emit PriceUpdated(_newPrice);
    }

    /**
     * @dev Update the base URI (owner only)
     */
    function setBaseURI(string memory _newBaseURI) public onlyOwner {
        baseTokenURI = _newBaseURI;
        emit BaseURIUpdated(_newBaseURI);
    }

    /**
     * @dev Set the not revealed URI
     */
    function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {
        notRevealedUri = _notRevealedURI;
    }

    /**
     * @dev Reveal the collection
     */
    function reveal() public onlyOwner {
        require(!isRevealed, "Already revealed");
        isRevealed = true;
        emit Revealed(baseTokenURI);
    }

    /**
     * @dev Withdraw contract balance (owner only)
     */
    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        payable(owner()).transfer(balance);
        emit Withdrawn(owner(), balance);
    }

    /**
     * @dev Get tokens owned by an address
     */
    function walletOfOwner(address _owner) 
        public 
        view 
        returns (uint256[] memory) 
    {
        uint256 ownerTokenCount = balanceOf(_owner);
        uint256[] memory tokenIds = new uint256[](ownerTokenCount);
        uint256 currentIndex = 0;

        for (uint256 i = 1; i <= totalMinted; i++) {
            if (ownerOf(i) == _owner) {
                tokenIds[currentIndex] = i;
                currentIndex++;
            }
        }

        return tokenIds;
    }

    /**
     * @dev Check how many NFTs are still available
     */
    function remainingSupply() public view returns (uint256) {
        return MAX_SUPPLY - totalMinted;
    }
}
```

**Key additions for training:**
- `address public claimant` ‚Üí Your training portal wallet
- Constructor accepts `_claimant` parameter
- Used for achievement verification

### Compile the Contract

```bash
npx hardhat compile
```

**Expected output:**
```
Compiled 1 Solidity file with solc 0.8.28 (evm target: shanghai).
```

## Creating the Deployment Script

### scripts/deploy-nft.ts

Create a comprehensive deployment script with achievement integration:

```typescript
import { network } from "hardhat";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Deploying NFT Collection to ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get parameters from environment
    const claimantAddress = process.env.CLAIMANT_ADDRESS as `0x${string}`;
    
    if (!claimantAddress) {
      console.error("‚ùå CLAIMANT_ADDRESS not set in .env");
      console.log("Please set your training portal wallet address");
      process.exit(1);
    }
    
    // Collection parameters
    const collectionName = "Plunder NFT Collection";
    const collectionSymbol = "PNFT";
    
    // Placeholder IPFS URIs (we'll add real metadata in next lesson)
    const baseURI = "ipfs://placeholder-revealed/";
    const hiddenURI = "ipfs://placeholder-hidden/hidden.json";
    
    console.log("Deploying from account:", walletClient.account.address);
    console.log("Collection name:", collectionName);
    console.log("Collection symbol:", collectionSymbol);
    console.log("Base URI (placeholder):", baseURI);
    console.log("Hidden URI (placeholder):", hiddenURI);
    console.log("Claimant:", claimantAddress);
    
    // Show network info
    const chainId = await publicClient.getChainId();
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    
    // Deploy NFT Collection contract
    console.log("\nDeploying NFT Collection...");
    
    const nftArtifact = (await import("../artifacts/contracts/SimpleNFTCollection.sol/SimpleNFTCollection.json")).default;
    
    const deploymentTx = await walletClient.deployContract({
      abi: nftArtifact.abi,
      bytecode: nftArtifact.bytecode as `0x${string}`,
      args: [collectionName, collectionSymbol, baseURI, hiddenURI, claimantAddress],
    });
    
    console.log("‚è≥ Deployment transaction submitted...");
    console.log("Transaction hash:", deploymentTx);
    
    // Wait for transaction receipt
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: deploymentTx 
    });
    
    const contractAddress = receipt.contractAddress!;
    console.log("‚úÖ NFT Collection deployed to:", contractAddress);
    
    // Create contract instance
    const nft = await viem.getContractAt("SimpleNFTCollection", contractAddress);
    
    // Display transaction ID for achievement submission
    console.log("\nüéØ Transaction ID for Achievement Submission:");
    console.log(deploymentTx);
    
    // Wait for contract activation
    console.log("\n‚è≥ Waiting for contract activation...");
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Verify deployment
    console.log("\nüìã Verifying deployment...");
    try {
      const name = await nft.read.name();
      const symbol = await nft.read.symbol();
      const maxSupply = await nft.read.MAX_SUPPLY();
      const mintPrice = await nft.read.mintPrice();
      const totalMinted = await nft.read.totalMinted();
      const isRevealed = await nft.read.isRevealed();
      const claimant = await nft.read.claimant();
      const owner = await nft.read.owner();
      
      console.log("Collection Name:", name);
      console.log("Symbol:", symbol);
      console.log("Max Supply:", maxSupply.toString());
      console.log("Mint Price:", mintPrice.toString(), "wei (1 ZIL)");
      console.log("Total Minted:", totalMinted.toString());
      console.log("Is Revealed:", isRevealed);
      console.log("Claimant:", claimant);
      console.log("Owner:", owner);
      
      // Verification checks
      if (claimant.toLowerCase() !== claimantAddress.toLowerCase()) {
        console.error("‚ö†Ô∏è  Warning: Claimant address mismatch!");
      }
      if (owner.toLowerCase() !== walletClient.account.address.toLowerCase()) {
        console.error("‚ö†Ô∏è  Warning: Owner address mismatch!");
      }
      
      console.log("\n‚úÖ All verifications passed!");
      
    } catch (verificationError) {
      console.log("‚ö†Ô∏è  Contract verification failed (may need more time to activate)");
      console.log("Contract deployed successfully. Verify manually later.");
    }
    
    console.log("\nüéâ Deployment completed successfully!");
    console.log("Contract address:", contractAddress);
    console.log("Transaction ID:", deploymentTx);
    console.log("Network:", networkName);
    console.log("Chain ID:", chainId);
    console.log("Deployer:", walletClient.account.address);
    console.log("Claimant:", claimantAddress);
    
    console.log("\nüìã Next Steps:");
    console.log("1. Test minting locally with mint-nft.ts script");
    console.log("2. In next lesson, generate metadata and pin to IPFS");
    console.log("3. Update contract URIs with real IPFS links");
    console.log("4. Reveal the collection");
    console.log("5. Submit deployment transaction for achievement verification");
    console.log("   https://plunderacademy.com/lessons/island3/nft-collection-practical");
    
  } catch (error) {
    console.error("‚ùå Deployment failed:", error);
    process.exit(1);
  }
}

main().catch(console.error);
```

### Update package.json Scripts

Add convenient npm scripts:

```json
{
  "scripts": {
    "compile": "npx hardhat compile",
    "test": "npx hardhat test",
    "deploy:local": "npx hardhat run scripts/deploy-nft.ts",
    "deploy:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/deploy-nft.ts --network zilliqaTestnet",
    "mint:local": "npx hardhat run scripts/mint-nft.ts",
    "mint:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/mint-nft.ts --network zilliqaTestnet",
    "reveal:local": "npx hardhat run scripts/reveal.ts",
    "reveal:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/reveal.ts --network zilliqaTestnet",
    "interact:local": "npx hardhat run scripts/interact.ts",
    "interact:testnet": "HARDHAT_NETWORK=zilliqaTestnet npx hardhat run scripts/interact.ts --network zilliqaTestnet"
  }
}
```

## Local Deployment Testing

### Start Local Hardhat Network

**Terminal 1:**
```bash
npx hardhat node
```

This starts a local blockchain with pre-funded test accounts.

### Deploy Locally

**Terminal 2:**

Set environment variables and deploy:
```bash
export CLAIMANT_ADDRESS=0x70997970C51812dc3A010C7d01b50e0d17dc79C8
npm run deploy:local
```

**Expected output:**
```
Deploying NFT Collection to localhost...
Deploying from account: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Collection name: Plunder NFT Collection
Collection symbol: PNFT
Base URI (placeholder): ipfs://placeholder-revealed/
Hidden URI (placeholder): ipfs://placeholder-hidden/hidden.json
Claimant: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
Network: localhost
Chain ID: 31337

Deploying NFT Collection...
‚è≥ Deployment transaction submitted...
Transaction hash: 0x...
‚úÖ NFT Collection deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3

üìã Verifying deployment...
Collection Name: Plunder NFT Collection
Symbol: PNFT
Max Supply: 100
Mint Price: 1000000000000000000 wei (1 ZIL)
Total Minted: 0
Is Revealed: false
Claimant: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
Owner: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266

‚úÖ All verifications passed!
üéâ Deployment completed successfully!
```

### Test Minting Locally

Create `scripts/mint-nft.ts`:

```typescript
import { network } from "hardhat";
import { parseEther } from "viem";

const networkName = process.env.HARDHAT_NETWORK || "localhost";
console.log(`Minting NFTs on ${networkName}...`);

const { viem } = await network.connect({
  network: networkName,
});

const publicClient = await viem.getPublicClient();
const walletClients = await viem.getWalletClients();
const [walletClient] = walletClients;

async function main() {
  try {
    // Get contract address from environment
    const nftAddress = process.env.NFT_CONTRACT_ADDRESS as `0x${string}`;
    
    if (!nftAddress) {
      console.error("‚ùå NFT_CONTRACT_ADDRESS not set in .env");
      console.log("Please set the deployed contract address");
      process.exit(1);
    }
    
    // Mint parameters
    const quantity = parseInt(process.env.MINT_QUANTITY || "1");
    
    console.log("Minting from account:", walletClient.account.address);
    console.log("NFT contract:", nftAddress);
    console.log("Quantity to mint:", quantity);
    
    // Get contract instance
    const nft = await viem.getContractAt("SimpleNFTCollection", nftAddress);
    
    // Get contract info
    const mintPrice = await nft.read.mintPrice();
    const totalMinted = await nft.read.totalMinted();
    const maxSupply = await nft.read.MAX_SUPPLY();
    const remainingSupply = await nft.read.remainingSupply();
    
    console.log("\nüìä Collection status:");
    console.log("Mint price:", mintPrice.toString(), "wei");
    console.log("Total minted:", totalMinted.toString());
    console.log("Max supply:", maxSupply.toString());
    console.log("Remaining:", remainingSupply.toString());
    
    // Calculate payment
    const payment = mintPrice * BigInt(quantity);
    console.log("\nüí∞ Payment required:", payment.toString(), "wei");
    
    // Mint NFTs
    console.log("\nüé® Minting", quantity, "NFT(s)...");
    const hash = await nft.write.mint([BigInt(quantity)], {
      value: payment,
    });
    console.log("Transaction hash:", hash);
    
    // Wait for confirmation
    console.log("‚è≥ Waiting for confirmation...");
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    if (receipt.status === "success") {
      console.log("‚úÖ Minting successful!");
      
      // Get updated info
      const newTotalMinted = await nft.read.totalMinted();
      const userBalance = await nft.read.balanceOf([walletClient.account.address]);
      const userTokens = await nft.read.walletOfOwner([walletClient.account.address]);
      
      console.log("\nüìä Updated status:");
      console.log("Total minted:", newTotalMinted.toString());
      console.log("Your NFT balance:", userBalance.toString());
      console.log("Your token IDs:", userTokens.map(id => id.toString()).join(", "));
      
      console.log("\nüéâ Minting completed successfully!");
      console.log("Transaction ID:", hash);
      
    } else {
      console.error("‚ùå Transaction failed");
      process.exit(1);
    }
    
  } catch (error: any) {
    console.error("‚ùå Minting failed:", error);
    
    // Provide helpful error messages
    if (error.message?.includes("Exceeds max supply")) {
      console.log("\nüí° Collection is sold out!");
    } else if (error.message?.includes("Insufficient payment")) {
      console.log("\nüí° Not enough ZIL sent for minting");
    }
    
    process.exit(1);
  }
}

main().catch(console.error);
```

**Test it:**
```bash
export NFT_CONTRACT_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
export MINT_QUANTITY=3
npm run mint:local
```

## Zilliqa Testnet Deployment

### Prerequisites

**1. Import wallet to MetaMask:**
- Copy private key from `.env`
- MetaMask ‚Üí Import Account ‚Üí Paste private key

**2. Add Zilliqa Testnet to MetaMask:**
- Network Name: `Zilliqa Testnet`
- RPC URL: `https://api.testnet.zilliqa.com`
- Chain ID: `33101`
- Currency Symbol: `ZIL`
- Block Explorer: `https://testnet.zilliqa.blockscout.com`

**3. Get testnet ZIL:**
- Visit https://faucet.testnet.zilliqa.com
- Enter your wallet address
- Request testnet ZIL

### Deploy to Zilliqa Testnet

**Update `.env` with your claimant address:**
```
ZILLIQA_TESTNET_PRIVATE_KEY=0x...
CLAIMANT_ADDRESS=0x...  # Your training portal wallet!
```

**Deploy:**
```bash
npm run deploy:testnet
```

**Expected testnet output:**
```
Deploying NFT Collection to zilliqaTestnet...
Deploying from account: 0xYourDevelopmentWallet
Collection name: Plunder NFT Collection
Collection symbol: PNFT
Claimant: 0xYourTrainingPortalWallet
Network: zilliqaTestnet
Chain ID: 33101

‚è≥ Deployment transaction submitted...
Transaction hash: 0xabcd1234567890...

‚úÖ NFT Collection deployed to: 0xNewNFTContractAddress

üéØ Transaction ID for Achievement Submission:
0xabcd1234567890...

üìã Verifying deployment...
Collection Name: Plunder NFT Collection
Symbol: PNFT
Max Supply: 100
Mint Price: 1000000000000000000 wei (1 ZIL)
Claimant: 0xYourTrainingPortalWallet

‚úÖ All verifications passed!

üéâ Deployment completed successfully!
```

**Add contract address to `.env`:**
```bash
echo "NFT_CONTRACT_ADDRESS=0xYourNFTContractAddressHere" >> .env
```

### Test Minting on Testnet

```bash
export NFT_CONTRACT_ADDRESS=0xYourNFTContractAddress
export MINT_QUANTITY=2
npm run mint:testnet
```

## Post-Deployment Verification

### Verify on Block Explorer

**Visit Zilliqa Blockscout:**
https://testnet.zilliqa.blockscout.com

**Search for your contract address:**
- View deployment transaction
- Check contract balance
- Verify claimant address is correct
- See minted NFTs

### Interact With Your Contract

Create `scripts/interact.ts`:

```typescript
import { network } from "hardhat";

const nftAddress = process.env.NFT_CONTRACT_ADDRESS as `0x${string}`;
const networkName = process.env.HARDHAT_NETWORK || "localhost";

if (!nftAddress) {
  console.error("Set NFT_CONTRACT_ADDRESS in .env");
  process.exit(1);
}

const { viem } = await network.connect({ network: networkName });
const publicClient = await viem.getPublicClient();
const [walletClient] = await viem.getWalletClients();

async function main() {
  console.log(`Interacting with NFT Collection on ${networkName}...`);
  console.log("Contract address:", nftAddress);
  console.log("Using account:", walletClient.account.address);
  
  const nft = await viem.getContractAt("SimpleNFTCollection", nftAddress);
  
  // Get collection info
  console.log("\n=== Collection Information ===");
  const name = await nft.read.name();
  const symbol = await nft.read.symbol();
  const maxSupply = await nft.read.MAX_SUPPLY();
  const mintPrice = await nft.read.mintPrice();
  const totalMinted = await nft.read.totalMinted();
  const remainingSupply = await nft.read.remainingSupply();
  const isRevealed = await nft.read.isRevealed();
  const claimant = await nft.read.claimant();
  const owner = await nft.read.owner();
  
  console.log("Name:", name);
  console.log("Symbol:", symbol);
  console.log("Max Supply:", maxSupply.toString());
  console.log("Mint Price:", mintPrice.toString(), "wei");
  console.log("Total Minted:", totalMinted.toString());
  console.log("Remaining:", remainingSupply.toString());
  console.log("Is Revealed:", isRevealed);
  console.log("Claimant:", claimant);
  console.log("Owner:", owner);
  
  // Get user info
  console.log("\n=== Your NFT Holdings ===");
  const userBalance = await nft.read.balanceOf([walletClient.account.address]);
  console.log("Your NFT Balance:", userBalance.toString());
  
  if (userBalance > 0n) {
    const userTokens = await nft.read.walletOfOwner([walletClient.account.address]);
    console.log("Your Token IDs:", userTokens.map(id => id.toString()).join(", "));
    
    // Show metadata URIs for your tokens
    for (const tokenId of userTokens) {
      const uri = await nft.read.tokenURI([tokenId]);
      console.log(`Token ${tokenId} URI:`, uri);
    }
  }
  
  console.log("\n‚úÖ Interaction completed successfully!");
}

main().catch(console.error);
```

**Run it:**
```bash
export NFT_CONTRACT_ADDRESS=0xYourNFTAddress
npm run interact:testnet
```

### Create Reveal Script

Create `scripts/reveal.ts`:

```typescript
import { network } from "hardhat";

const nftAddress = process.env.NFT_CONTRACT_ADDRESS as `0x${string}`;
const networkName = process.env.HARDHAT_NETWORK || "localhost";

if (!nftAddress) {
  console.error("Set NFT_CONTRACT_ADDRESS in .env");
  process.exit(1);
}

const { viem } = await network.connect({ network: networkName });
const publicClient = await viem.getPublicClient();
const [walletClient] = await viem.getWalletClients();

async function main() {
  console.log(`Revealing NFT Collection on ${networkName}...`);
  console.log("Contract address:", nftAddress);
  console.log("Caller:", walletClient.account.address);
  
  const nft = await viem.getContractAt("SimpleNFTCollection", nftAddress);
  
  // Check current status
  const isRevealed = await nft.read.isRevealed();
  const owner = await nft.read.owner();
  
  console.log("Current reveal status:", isRevealed);
  console.log("Contract owner:", owner);
  
  if (isRevealed) {
    console.log("\n‚ö†Ô∏è  Collection is already revealed!");
    process.exit(0);
  }
  
  if (owner.toLowerCase() !== walletClient.account.address.toLowerCase()) {
    console.error("\n‚ùå Only the owner can reveal the collection!");
    process.exit(1);
  }
  
  // Reveal
  console.log("\nüéâ Revealing collection...");
  const hash = await nft.write.reveal();
  console.log("Transaction hash:", hash);
  
  // Wait for confirmation
  console.log("‚è≥ Waiting for confirmation...");
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  
  if (receipt.status === "success") {
    console.log("‚úÖ Collection revealed successfully!");
    
    const newIsRevealed = await nft.read.isRevealed();
    console.log("New reveal status:", newIsRevealed);
    
    console.log("\nüé® All NFTs now show their revealed metadata!");
    console.log("Transaction ID:", hash);
  } else {
    console.error("‚ùå Reveal failed");
    process.exit(1);
  }
}

main().catch(console.error);
```

**Run it (after adding metadata in next lesson):**
```bash
npm run reveal:testnet
```

## Claim Your Achievement

### Achievement Submission

**You've successfully deployed your NFT collection!**

**To claim your achievement:**

1. **Copy your deployment transaction hash** (from deployment output)
2. **Visit the training portal:** https://plunderacademy.com/lessons/island3/nft-collection-practical
3. **Connect your wallet** (the one set as `CLAIMANT_ADDRESS`)
4. **Submit the transaction hash**
5. **Verification happens automatically:**
   - Checks transaction created a contract
   - Verifies it's a SimpleNFTCollection contract
   - Confirms claimant matches your wallet
6. **Receive your achievement NFT!**

## Common Issues and Solutions

### Issue: "Insufficient funds for gas"

**Solution:**
```bash
# Get more testnet ZIL from faucet
https://faucet.testnet.zilliqa.com
```

### Issue: "Contract verification failed"

**Solution:**
```bash
# Contract may need more time to activate on Zilliqa
# Wait 10-30 seconds, then run interact script
npm run interact:testnet
```

### Issue: "Invalid claimant address"

**Solution:**
```bash
# Ensure CLAIMANT_ADDRESS is your training portal wallet
# Check .env file
cat .env | grep CLAIMANT_ADDRESS
```

### Issue: "Minting failed - insufficient payment"

**Solution:**
```bash
# Make sure you're sending enough ZIL
# mintPrice * quantity = total payment needed
# Example: 1 * 3 = 3 ZIL
```

## What's Next?

In the next lesson, we'll:
- Generate 100 unique SVG images (automated script)
- Create JSON metadata for each NFT
- Pin everything to IPFS using Pinata
- Update contract URIs with real IPFS links
- Test the reveal mechanics

## Wrap-Up

You've successfully:

‚úÖ **Set up Hardhat 3** with Zilliqa network configurations  
‚úÖ **Created the NFT contract** with claimant integration  
‚úÖ **Written deployment scripts** with comprehensive verification  
‚úÖ **Tested locally** with Hardhat node  
‚úÖ **Deployed to Zilliqa testnet** with proper configuration  
‚úÖ **Verified deployment** on block explorer  
‚úÖ **Tested minting** and tracking NFT ownership  
‚úÖ **Created admin scripts** for reveal and interaction  

**Next up:** Module 3.7.4 will cover metadata generation, IPFS pinning, and reveal mechanics. You'll create real NFT art and metadata!

Ready to add metadata? Let's go! üöÄ


