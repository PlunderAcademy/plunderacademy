---
id: events-and-error-handling
module: intro-to-solidity
number: 3.4
title: Events and Error Handling
objective: Learn how to emit events and handle errors in Solidity smart contracts.
slug: events-and-error-handling
---

## Events: The Communication Layer of Tokens

**Real-world analogy:** Events are like a newspaper for the blockchain. Every important thing that happens gets published (emitted), and anyone interested can subscribe to read about specific types of news (filter events).

Events are crucial for token contracts because they provide a way for external applications (like wallets, exchanges, and DeFi protocols) to track token activity without constantly checking balances.

### Standard ERC-20 Events

#### Transfer Event: The Heart of Token Activity

```solidity
event Transfer(address indexed from, address indexed to, uint256 value);

function _transfer(address from, address to, uint256 amount) internal {
    require(from != address(0), "Transfer from zero address");
    require(to != address(0), "Transfer to zero address");
    
    uint256 fromBalance = _balances[from];
    require(fromBalance >= amount, "Transfer amount exceeds balance");
    
    unchecked {
        _balances[from] = fromBalance - amount;
        _balances[to] += amount;
    }
    
    emit Transfer(from, to, amount);
}
```

**Why Transfer events are essential:**
- **Wallet updates:** Wallets listen for Transfer events to update balances
- **Exchange tracking:** Exchanges track deposits/withdrawals via Transfer events
- **DeFi integration:** DeFi protocols monitor Transfer events for automated triggers
- **Analytics:** Block explorers and analytics tools rely on Transfer events

#### Approval Event: Permission Tracking

```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);

function approve(address spender, uint256 amount) public returns (bool) {
    _approve(msg.sender, spender, amount);
    return true;
}

function _approve(address owner, address spender, uint256 amount) internal {
    require(owner != address(0), "Approve from zero address");
    require(spender != address(0), "Approve to zero address");
    
    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
}
```

**Approval event use cases:**
- **DeFi interfaces:** DEXes show your current approvals
- **Security monitoring:** Track who you've given permission to spend your tokens
- **Revocation tracking:** Monitor when approvals are set to zero

## Error Handling: Protecting Your Token

**Real-world analogy:** Error handling in smart contracts is like having multiple safety systems in a bank vault. Each `require` statement is like a different lock or alarm - if any security check fails, the entire operation is immediately stopped and reversed.

### The require Statement: Your First Line of Defense

#### Basic Token Validation

```solidity
function transfer(address to, uint256 amount) public returns (bool) {
    // Validate recipient address
    require(to != address(0), "Cannot transfer to zero address");
    require(to != address(this), "Cannot transfer to contract itself");
    
    // Validate amount
    require(amount > 0, "Transfer amount must be positive");
    require(_balances[msg.sender] >= amount, "Insufficient balance");
    
    // Security checks
    require(!blacklisted[msg.sender], "Sender is blacklisted");
    require(!blacklisted[to], "Recipient is blacklisted");
    
    _transfer(msg.sender, to, amount);
    return true;
}
```

#### Access Control Validation

```solidity
function mint(address to, uint256 amount) public {
    // Permission checks
    require(hasRole(MINTER_ROLE, msg.sender), "Must have minter role");
    require(mintingEnabled, "Minting is currently disabled");
    
    // Supply validation
    require(to != address(0), "Cannot mint to zero address");
    require(amount > 0, "Mint amount must be positive");
    require(totalSupply() + amount <= maxSupply, "Would exceed maximum supply");
    
    _mint(to, amount);
}
```

### Custom Error Messages for Better UX

#### Descriptive Error Messages

```solidity
// Bad: Vague error messages
require(amount <= _balances[msg.sender], "Error");
require(to != address(0), "Invalid");

// Good: Clear, helpful error messages
require(amount <= _balances[msg.sender], "Transfer amount exceeds your balance");
require(to != address(0), "Cannot transfer tokens to the zero address");
require(amount > 0, "Transfer amount must be greater than zero");
require(!paused(), "Token transfers are currently paused");
```

### Best Practices for Events and Error Handling

#### Event Design Guidelines

```solidity
// Good: Clear, indexable, informative events
event TokensPurchased(
    address indexed buyer,
    uint256 indexed paymentAmount,
    uint256 tokensReceived,
    uint256 exchangeRate
);

// Custom token events
event MintingEnabled(bool enabled);
event AddressBlacklisted(address indexed account, string reason);
event SupplyCapChanged(uint256 oldCap, uint256 newCap);
```

#### Error Message Strategy

```solidity
// Consistent error message format
require(condition, "TokenContract: descriptive error message");

// Examples:
require(to != address(0), "TokenContract: transfer to zero address");
require(amount > 0, "TokenContract: transfer amount must be positive");
require(_balances[from] >= amount, "TokenContract: transfer amount exceeds balance");
```

Events and error handling are the foundation of user experience and debugging in token contracts. Well-designed events enable rich interfaces and analytics, while comprehensive error handling protects users and provides clear feedback when operations fail!
