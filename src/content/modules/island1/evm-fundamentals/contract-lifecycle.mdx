---
id: contract-lifecycle
module: evm-fundamentals
number: 2.4
title: Contract Lifecycle on EVM
objective: >-
  Learn the phases of a smart contract's life from writing to deployment and
  interaction.
slug: contract-lifecycle
---

## Understanding the Smart Contract Journey

### The Complete Contract Lifecycle

**Real-world analogy:** Think of smart contract development like building and operating a restaurant:
1. **Write** = Creating the recipe book and operating procedures
2. **Compile** = Translating recipes into a format the kitchen staff can follow
3. **Deploy** = Opening the restaurant and registering it with the city
4. **Interact** = Customers ordering meals and staff following procedures
5. **Update** = Changing recipes or renovating while keeping the same address

Each phase has its own challenges, best practices, and potential pitfalls.

### Phase 1: Writing Smart Contracts

#### What Happens in This Phase

**Code creation:** Developers write smart contract logic in Solidity, defining:
- State variables (the contract's permanent data)
- Functions (what the contract can do)
- Events (how the contract communicates with the outside world)
- Access controls (who can do what)

#### Best Practices for Writing Phase

**Start with requirements:**
```solidity
// Example: Simple token contract requirements
// 1. Track balances for each user
// 2. Allow transfers between users
// 3. Prevent spending more than you have
// 4. Emit events for all transfers
// 5. Only owner can mint new tokens
```

**Use proven patterns:**
```solidity
// Use OpenZeppelin for standard functionality
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC20, Ownable {
    constructor() ERC20("MyToken", "MTK") {}
    
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
```

**Common writing mistakes to avoid:**
- **Reentrancy vulnerabilities:** Always update state before external calls
- **Integer overflow/underflow:** Use SafeMath or Solidity 0.8+ built-in checks
- **Access control gaps:** Ensure only authorized users can call sensitive functions
- **Gas inefficiencies:** Minimize storage operations and use appropriate data types

### Phase 2: Compilation Process

#### What Happens During Compilation

**Source code transformation:** The Solidity compiler (solc) transforms human-readable code into machine-executable bytecode and generates the ABI (Application Binary Interface).

**Compilation outputs:**
1. **Bytecode:** Low-level instructions the EVM can execute
2. **ABI:** JSON interface describing how to interact with the contract
3. **Metadata:** Additional information about compilation settings
4. **Gas estimates:** Predicted gas costs for deployment and function calls

**Compilation best practices:**
- **Solidity version:** Use specific versions, avoid floating pragmas in production
- **EVM version:** Set to Shanghai or below for Zilliqa 2.0 compatibility
- **Optimization:** Enable for production contracts to reduce gas costs

### Phase 3: Deployment to Blockchain

#### Understanding Deployment

**What deployment actually does:**
The deployment transaction carries initialization data, resulting in a contract address once mined. This address becomes the persistent locator allowing interaction with the deployed logic and state.

**The deployment process:**
1. **Transaction creation:** Wallet creates deployment transaction with bytecode
2. **Network broadcast:** Transaction is sent to the blockchain network
3. **Validation:** Network nodes validate the transaction
4. **Execution:** EVM executes the constructor and stores the bytecode
5. **Address assignment:** Network assigns a permanent address to the contract
6. **Confirmation:** Transaction is confirmed and contract is live

#### Deployment Cost Analysis

**Gas cost breakdown for typical contract:**
```
Base deployment cost:    32,000 gas
Contract code storage:   ~200 gas per byte of bytecode
Constructor execution:   Variable (depends on constructor complexity)
Total typical cost:      100,000-500,000 gas
```

**Real cost examples on Zilliqa:**
- **Simple contract:** ~100,000 gas = ~$0.20
- **Token contract:** ~300,000 gas = ~$0.60
- **Complex DeFi contract:** ~800,000 gas = ~$1.60

### Phase 4: Interaction and Usage

#### Types of Contract Interactions

**Read operations (calls):**
- Don't modify contract state
- Don't cost gas (free to execute)
- Return data immediately
- Can be called by anyone

**Write operations (transactions):**
- Modify contract state
- Cost gas to execute
- Take time to confirm (~1 second on Zilliqa)
- Must be called by accounts with sufficient gas

#### Interaction Methods

**Web3 libraries example:**
```javascript
// Using ethers.js
const contract = new ethers.Contract(contractAddress, abi, wallet);

// Read operation (free)
const balance = await contract.getBalance(userAddress);

// Write operation (costs gas)
const tx = await contract.transfer(recipientAddress, amount);
await tx.wait(); // Wait for confirmation
```

### Phase 5: Updates and Maintenance

#### The Immutability Challenge

**Default behavior:** Smart contracts are immutable by default - once deployed, the code cannot be changed.

**Update strategies:**
1. **Redeploy new contract:** Simple but requires new address
2. **Proxy pattern:** Same address, more complex but upgradeable
3. **Migration pattern:** Move data from old to new contract

#### Common Lifecycle Challenges

**Challenge 1: Contract Size Limits**
- **Problem:** EVM has a 24KB limit for contract size
- **Solutions:** Split into multiple contracts, use libraries, optimize code

**Challenge 2: Gas Cost Management**
- **Problem:** High gas costs make contracts unusable
- **Solutions:** Optimize storage usage, use events, batch operations

**Challenge 3: Security Vulnerabilities**
- **Problem:** Bugs in deployed contracts can't be easily fixed
- **Solutions:** Extensive testing, security audits, pause mechanisms
