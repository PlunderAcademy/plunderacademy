---
id: solidity-fundamentals
module: intro-to-solidity
number: 3.1
title: 'Solidity Fundamentals: Getting Started'
objective: >-
  Learn the basics of Solidity syntax, data types, and foundational constructs
  for building robust and secure decentralized applications.
slug: solidity-fundamentals
---

## What is Solidity?

### The Language of Smart Contracts

**Real-world analogy:** Think of Solidity like the legal language used to write contracts, but instead of lawyers interpreting them, computer programs execute them automatically and exactly as written.

Solidity is the primary programming language for writing smart contracts on Ethereum and all EVM-compatible blockchains, including Zilliqa. It is statically typed and contract-oriented, meaning every piece of data has a specific type that's checked before the contract runs.

**Why Solidity exists:**
- **Deterministic execution:** The same code always produces the same result
- **Security-focused:** Built-in features to prevent common programming mistakes
- **EVM compatibility:** Works on all Ethereum-compatible blockchains
- **Rich ecosystem:** Extensive libraries and tools available

### Understanding Contract Anatomy

Let's break down a complete token contract structure to understand how Solidity works:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Import statement - using proven, secure code
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

// Contract declaration - like a class in other programming languages
contract MyToken is ERC20, Ownable {
    // State variables - permanent storage on blockchain
    uint256 public constant MAX_SUPPLY = 1000000 * 10**18;
    mapping(address => bool) public minters;
    
    // Events - logs for external applications
    event MinterAdded(address indexed minter);
    event MinterRemoved(address indexed minter);
    
    // Constructor - runs once when contract is deployed
    constructor() ERC20("MyToken", "MTK") {}
    
    // Modifier - reusable code that checks conditions
    modifier onlyMinter() {
        require(minters[msg.sender], "Not authorized to mint");
        _;
    }
    
    // Functions - what the contract can do
    function addMinter(address minter) public onlyOwner {
        minters[minter] = true;
        emit MinterAdded(minter);
    }
    
    function mint(address to, uint256 amount) public onlyMinter {
        require(totalSupply() + amount <= MAX_SUPPLY, "Exceeds max supply");
        _mint(to, amount);
    }
}
```

### Breaking Down Contract Structure

#### 1. License and Pragma

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
```

**License identifier:** Tells the world how your code can be used (MIT = open source)
**Pragma:** Specifies which Solidity compiler version to use
- `^0.8.0` means version 0.8.0 or higher (but not 0.9.0)
- Use specific versions for production: `0.8.19`

#### 2. Import Statements

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
```

**What imports do:** Bring in code from other files or libraries
**OpenZeppelin:** Battle-tested, secure smart contract components
**Best practice:** Always use proven libraries rather than writing from scratch

#### 3. Contract Declaration

```solidity
contract MyToken is ERC20, Ownable {
```

**Contract keyword:** Like `class` in other programming languages
**Inheritance:** `is ERC20, Ownable` means our contract inherits functionality from both
**Multiple inheritance:** Solidity supports inheriting from multiple parent contracts

#### 4. State Variables

```solidity
uint256 public constant MAX_SUPPLY = 1000000 * 10**18;
mapping(address => bool) public minters;
```

**State variables:** Permanent data stored on the blockchain
**Visibility:** `public` automatically creates getter functions
**Constants:** Values that never change, save gas costs
**Gas cost:** Each storage operation costs gas, so design carefully

### Essential Data Types for Token Contracts

#### Integers: The Foundation of Token Math

```solidity
// Unsigned integers (no negative numbers)
uint8 public decimals = 18;        // How divisible the token is
uint256 public totalSupply;        // Total tokens in existence
uint256 public maxSupply;          // Maximum tokens that can exist

// Signed integers (can be negative)
int256 public temperature;         // Could be negative
```

**Why uint256 is everywhere:**
- **EVM optimization:** 256 bits is the native word size
- **Security:** No overflow issues in Solidity 0.8+
- **Standards:** ERC-20 uses uint256 for all amounts

#### Addresses: Digital Identities

```solidity
address public owner;                    // Who controls the contract
address public constant ZERO_ADDRESS = address(0);  // Burn address
```

**Address types:**
- **address:** Basic Ethereum address (20 bytes)
- **address payable:** Can receive ETH/ZIL transfers

**Common patterns:**
```solidity
// Check if address is valid
require(recipient != address(0), "Cannot transfer to zero address");

// Transfer tokens to an address
_transfer(msg.sender, recipient, amount);
```

#### Booleans: Simple Flags

```solidity
bool public paused = false;              // Is contract paused?
mapping(address => bool) public minters; // Who can mint tokens?
```

#### Strings and Bytes

```solidity
string public name = "My Token";         // Human-readable name
string public symbol = "MTK";            // Trading symbol
bytes32 public merkleRoot;               // Efficient fixed-size data
```

**Gas considerations:**
- **strings:** Variable length, expensive storage
- **bytes32:** Fixed size, much cheaper for short data

### Understanding Function Structure

#### Basic Function Anatomy

```solidity
function transfer(address to, uint256 amount) 
    public 
    returns (bool) 
{
    _transfer(msg.sender, to, amount);
    return true;
}
```

**Function components:**
1. **Name:** `transfer` - what the function does
2. **Parameters:** `address to, uint256 amount` - inputs
3. **Visibility:** `public` - who can call it
4. **Returns:** `bool` - what it gives back
5. **Body:** The actual code that executes

#### Function Visibility Levels

```solidity
// Anyone can call from outside the contract
function publicFunction() public {}

// Only this contract and contracts that inherit from it
function internalFunction() internal {}

// Only this exact contract
function privateFunction() private {}

// Only callable from outside (not from within contract)
function externalFunction() external {}
```

#### State Mutability

```solidity
// Reads blockchain state but doesn't change it
function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
}

// Doesn't read or change blockchain state
function add(uint256 a, uint256 b) public pure returns (uint256) {
    return a + b;
}

// Changes blockchain state (default, costs gas)
function transfer(address to, uint256 amount) public returns (bool) {
    _transfer(msg.sender, to, amount);
    return true;
}
```

### Global Variables and Context

#### Understanding msg

```solidity
function mint(address to, uint256 amount) public {
    // msg.sender: who called this function
    require(msg.sender == owner, "Only owner can mint");
    
    // msg.value: how much ETH/ZIL was sent with this call
    require(msg.value == 0, "Don't send ZIL to mint function");
    
    _mint(to, amount);
}
```

#### Block and Time Information

```solidity
contract TimeLockedToken {
    uint256 public unlockTime;
    
    constructor() {
        // block.timestamp: current block time in seconds
        unlockTime = block.timestamp + 365 days;
    }
    
    function withdraw() public {
        require(block.timestamp >= unlockTime, "Tokens still locked");
        // withdrawal logic
    }
}
```

### Error Handling Fundamentals

#### The require Statement

```solidity
function transfer(address to, uint256 amount) public returns (bool) {
    // Check conditions before executing
    require(to != address(0), "Cannot transfer to zero address");
    require(_balances[msg.sender] >= amount, "Insufficient balance");
    require(amount > 0, "Amount must be greater than zero");
    
    // If all checks pass, execute the transfer
    _transfer(msg.sender, to, amount);
    return true;
}
```

**Why require is crucial:**
- **Safety:** Prevents invalid operations
- **Gas efficiency:** Fails fast, saving gas
- **User experience:** Clear error messages help users understand issues

### Contract Patterns for Tokens

#### The Constructor Pattern

```solidity
contract MyToken is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply,
        address owner
    ) ERC20(name, symbol) {
        _mint(owner, initialSupply);
        _transferOwnership(owner);
    }
}
```

**Constructor facts:**
- Runs exactly once when contract is deployed
- Sets up initial state
- Can take parameters for customization
- Cannot be called again after deployment

#### The Modifier Pattern

```solidity
contract TokenWithRoles {
    mapping(address => bool) public admins;
    
    modifier onlyAdmin() {
        require(admins[msg.sender], "Must be admin");
        _; // This is where the function code runs
    }
    
    function setPrice(uint256 newPrice) public onlyAdmin {
        price = newPrice;
    }
}
```

**Modifiers are like security guards:**
- Check conditions before function execution
- Reusable across multiple functions
- Make code cleaner and more secure

### Common Token Contract Patterns

#### Supply Management

```solidity
contract MintableToken {
    uint256 public totalSupply;
    uint256 public constant MAX_SUPPLY = 1000000 * 10**18;
    
    function mint(address to, uint256 amount) public onlyOwner {
        require(totalSupply + amount <= MAX_SUPPLY, "Would exceed max supply");
        totalSupply += amount;
        _balances[to] += amount;
        emit Transfer(address(0), to, amount);
    }
}
```

#### Access Control

```solidity
contract TokenWithRoles {
    address public owner;
    mapping(address => bool) public minters;
    mapping(address => bool) public burners;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }
    
    modifier onlyMinter() {
        require(minters[msg.sender], "Not authorized to mint");
        _;
    }
}
```

#### Pausable Functionality

```solidity
contract PausableToken {
    bool public paused = false;
    
    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }
    
    function transfer(address to, uint256 amount) 
        public 
        whenNotPaused 
        returns (bool) 
    {
        _transfer(msg.sender, to, amount);
        return true;
    }
}
```

### Reading Existing Token Contracts

When you encounter a token contract, look for these key elements:

#### 1. Basic Information
```solidity
string public name;      // "Wrapped Ethereum"
string public symbol;    // "WETH"
uint8 public decimals;   // 18 (most common)
```

#### 2. Supply Information
```solidity
uint256 public totalSupply;  // Current tokens in existence
uint256 public maxSupply;    // Maximum possible tokens (if applicable)
```

#### 3. Balance Tracking
```solidity
mapping(address => uint256) private _balances;
```

#### 4. Key Functions
```solidity
function transfer(address to, uint256 amount) public returns (bool);
function approve(address spender, uint256 amount) public returns (bool);
function transferFrom(address from, address to, uint256 amount) public returns (bool);
```

### Best Practices for Beginners

#### 1. Always Use Latest Solidity Version
```solidity
pragma solidity ^0.8.19; // Use recent stable version
```

#### 2. Import from OpenZeppelin
```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
// Don't reinvent the wheel
```

#### 3. Add Clear Comments
```solidity
// This function mints new tokens to the specified address
function mint(address to, uint256 amount) public onlyOwner {
    // Check that minting won't exceed maximum supply
    require(totalSupply + amount <= MAX_SUPPLY, "Exceeds max supply");
    _mint(to, amount);
}
```

#### 4. Use Descriptive Variable Names
```solidity
// Good
uint256 public maxSupplyPerAddress = 1000 * 10**18;

// Bad
uint256 public max = 1000000000000000000000;
```

#### 5. Handle Edge Cases
```solidity
function transfer(address to, uint256 amount) public returns (bool) {
    require(to != address(0), "Cannot transfer to zero address");
    require(to != address(this), "Cannot transfer to contract itself");
    require(amount > 0, "Amount must be greater than zero");
    // ... rest of function
}
```

This foundation will prepare you to understand and work with token contracts. In the upcoming modules, you'll learn how to set up your development environment and build your first token using these concepts!
