---
id: comprehensive-testing-and-deployment
module: creating-erc20-tokens
number: 5.3
title: Professional Testing & Deployment with Hardhat 3
objective: >-
  Master comprehensive testing strategies and professional deployment using 
  Hardhat 3 and Hardhat Ignition for your token contract.
slug: comprehensive-testing-and-deployment
---

## Building a Comprehensive Test Suite

### Understanding Testing Strategy

**Real-world analogy:** Testing a smart contract is like quality testing a car before it leaves the factory. You test individual components (unit tests), how systems work together (integration tests), and real-world driving scenarios (end-to-end tests).

**Why comprehensive testing matters:**
- **Security:** Catch vulnerabilities before deployment
- **Reliability:** Ensure contract behaves as expected
- **Confidence:** Deploy with assurance
- **Documentation:** Tests serve as living documentation
- **Maintenance:** Easier to modify with good test coverage

### Test Categories We'll Implement

**Unit Tests (Solidity):**
- âœ… **Individual function testing:** Each function works correctly in isolation
- âœ… **Access control validation:** Role restrictions work properly
- âœ… **Edge case handling:** Boundary conditions and error cases
- âœ… **Event emission:** Proper event logging

**Integration Tests (TypeScript):**
- âœ… **Multi-transaction flows:** Complex scenarios across multiple transactions
- âœ… **Role interactions:** How different roles interact
- âœ… **Real-world scenarios:** Simulating actual usage patterns
- âœ… **Gas optimization:** Measuring and optimizing gas usage

## Creating Solidity Unit Tests

### Remove Default Tests and Add Your Token Tests

**Remove default test files:**
```bash
rm test/Counter.ts
```

**Create comprehensive Solidity tests by updating `contracts/ZilliqaAcademyToken.t.sol`:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import { Test } from "forge-std/Test.sol";
import { ZilliqaAcademyToken } from "./ZilliqaAcademyToken.sol";

contract ZilliqaAcademyTokenTest is Test {
    ZilliqaAcademyToken public token;
    
    address public owner = makeAddr("owner");
    address public minter = makeAddr("minter");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    
    event TokensMinted(address indexed to, uint256 amount, address indexed minter);
    event TokensBurned(address indexed from, uint256 amount, address indexed burner);
    
    function setUp() public {
        vm.prank(owner);
        token = new ZilliqaAcademyToken(owner);
    }
    
    function test_InitialState() public view {
        assertEq(token.name(), "Zilliqa Academy Token");
        assertEq(token.symbol(), "ZAT");
        assertEq(token.decimals(), 18);
        assertEq(token.totalSupply(), 1_000_000 * 10**18);
        assertEq(token.getMaxSupply(), 10_000_000 * 10**18);
        
        assertTrue(token.hasRole(token.DEFAULT_ADMIN_ROLE(), owner));
        assertTrue(token.hasRole(token.MINTER_ROLE(), owner));
        assertTrue(token.hasRole(token.PAUSER_ROLE(), owner));
        assertTrue(token.hasRole(token.BURNER_ROLE(), owner));
        
        assertEq(token.balanceOf(owner), 1_000_000 * 10**18);
    }
    
    function test_CannotDeployWithZeroAddress() public {
        vm.expectRevert("ZAT: initial owner cannot be zero address");
        new ZilliqaAcademyToken(address(0));
    }
    
    function test_OwnerCanMint() public {
        uint256 mintAmount = 1000 * 10**18;
        
        vm.expectEmit(true, true, false, true);
        emit TokensMinted(user1, mintAmount, owner);
        
        vm.prank(owner);
        token.mint(user1, mintAmount);
        
        assertEq(token.balanceOf(user1), mintAmount);
        assertEq(token.totalSupply(), 1_000_000 * 10**18 + mintAmount);
    }
    
    function test_NonMinterCannotMint() public {
        vm.expectRevert();
        vm.prank(user1);
        token.mint(user2, 1000 * 10**18);
    }
    
    function test_CannotMintBeyondCap() public {
        uint256 remainingMintable = token.getRemainingMintableSupply();
        
        vm.expectRevert("ERC20Capped: cap exceeded");
        vm.prank(owner);
        token.mint(user1, remainingMintable + 1);
    }
    
    function test_PauseStopsTransfers() public {
        vm.prank(owner);
        token.pause();
        
        vm.expectRevert("Pausable: paused");
        vm.prank(owner);
        token.transfer(user1, 1000 * 10**18);
    }
    
    function test_RoleManagement() public {
        vm.prank(owner);
        token.addMinter(user1);
        
        assertTrue(token.hasRole(token.MINTER_ROLE(), user1));
        
        vm.prank(owner);
        token.removeMinter(user1);
        
        assertFalse(token.hasRole(token.MINTER_ROLE(), user1));
    }
}
```

### Running Solidity Tests

**Execute your unit tests:**

```bash
npx hardhat test solidity
```

## Creating TypeScript Integration Tests

### Comprehensive Integration Test Suite

**Create `test/ZilliqaAcademyToken.test.ts`:**

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { ZilliqaAcademyToken } from "../typechain-types";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";

describe("ZilliqaAcademyToken Integration Tests", function () {
  async function deployTokenFixture() {
    const [owner, minter, user1, user2] = await ethers.getSigners();
    
    const ZilliqaAcademyToken = await ethers.getContractFactory("ZilliqaAcademyToken");
    const token = await ZilliqaAcademyToken.deploy(owner.address);
    
    return { token, owner, minter, user1, user2 };
  }
  
  describe("Deployment", function () {
    it("Should deploy with correct initial state", async function () {
      const { token, owner } = await loadFixture(deployTokenFixture);
      
      expect(await token.name()).to.equal("Zilliqa Academy Token");
      expect(await token.symbol()).to.equal("ZAT");
      expect(await token.decimals()).to.equal(18);
      expect(await token.totalSupply()).to.equal(ethers.parseEther("1000000"));
      expect(await token.balanceOf(owner.address)).to.equal(ethers.parseEther("1000000"));
    });
  });
  
  describe("Role Management Workflow", function () {
    it("Should handle complete role management lifecycle", async function () {
      const { token, owner, minter, user1 } = await loadFixture(deployTokenFixture);
      
      // Owner grants minter role
      await token.connect(owner).addMinter(minter.address);
      expect(await token.hasRole(await token.MINTER_ROLE(), minter.address)).to.be.true;
      
      // Minter can mint tokens
      const mintAmount = ethers.parseEther("1000");
      await expect(token.connect(minter).mint(user1.address, mintAmount))
        .to.emit(token, "TokensMinted")
        .withArgs(user1.address, mintAmount, minter.address);
      
      // Owner revokes minter role
      await token.connect(owner).removeMinter(minter.address);
      expect(await token.hasRole(await token.MINTER_ROLE(), minter.address)).to.be.false;
    });
  });
  
  describe("Emergency Pause Scenario", function () {
    it("Should handle emergency pause and recovery", async function () {
      const { token, owner, user1, user2 } = await loadFixture(deployTokenFixture);
      
      // Initial transfer works
      const transferAmount = ethers.parseEther("1000");
      await token.connect(owner).transfer(user1.address, transferAmount);
      expect(await token.balanceOf(user1.address)).to.equal(transferAmount);
      
      // Emergency pause
      await token.connect(owner).pause();
      expect(await token.paused()).to.be.true;
      
      // Transfers are blocked
      await expect(
        token.connect(user1).transfer(user2.address, ethers.parseEther("100"))
      ).to.be.revertedWith("Pausable: paused");
      
      // Unpause and transfers work again
      await token.connect(owner).unpause();
      await token.connect(user1).transfer(user2.address, ethers.parseEther("100"));
      expect(await token.balanceOf(user2.address)).to.equal(ethers.parseEther("100"));
    });
  });
  
  describe("Gas Usage Analysis", function () {
    it("Should measure gas usage for key operations", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);
      
      // Measure mint gas
      const mintTx = await token.connect(owner).mint(user1.address, ethers.parseEther("1000"));
      const mintReceipt = await mintTx.wait();
      console.log(`Mint gas used: ${mintReceipt?.gasUsed}`);
      
      // Measure transfer gas
      const transferTx = await token.connect(owner).transfer(user1.address, ethers.parseEther("1000"));
      const transferReceipt = await transferTx.wait();
      console.log(`Transfer gas used: ${transferReceipt?.gasUsed}`);
    });
  });
});
```

### Running Integration Tests

**Execute TypeScript tests:**

```bash
npx hardhat test nodejs
```

**Run all tests together:**

```bash
npx hardhat test
```

## Professional Deployment with Hardhat Ignition

### Creating Deployment Modules

**Update `ignition/modules/Counter.ts` to be our token deployment module:**

```bash
rm ignition/modules/Counter.ts
```

**Create `ignition/modules/ZilliqaAcademyToken.ts`:**

```typescript
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const ZilliqaAcademyTokenModule = buildModule("ZilliqaAcademyTokenModule", (m) => {
  // Get deployment parameters
  const initialOwner = m.getParameter("initialOwner");
  
  // Deploy the token contract
  const token = m.contract("ZilliqaAcademyToken", [initialOwner]);
  
  return { token };
});

export default ZilliqaAcademyTokenModule;
```

### Local Deployment Testing

**Deploy to local Hardhat network:**

```bash
# Terminal 1: Start local blockchain
npx hardhat node

# Terminal 2: Deploy to local network (replace with your address)
npx hardhat ignition deploy ignition/modules/ZilliqaAcademyToken.ts --network localhost --parameters '{"ZilliqaAcademyTokenModule": {"initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"}}'
```

### Testnet Deployment

**Deploy to Zilliqa Testnet:**

1. **Ensure your `.env` file has your private key:**
   ```
   PRIVATE_KEY=your_metamask_private_key_here
   ```

2. **Deploy to testnet (replace with your address):**
   ```bash
   npx hardhat ignition deploy ignition/modules/ZilliqaAcademyToken.ts --network zilliqaTestnet --parameters '{"ZilliqaAcademyTokenModule": {"initialOwner": "YOUR_WALLET_ADDRESS"}}'
   ```

3. **Expected output:**
   ```
   Hardhat Ignition ðŸš€
   
   Deploying [ ZilliqaAcademyTokenModule ]
   
   âœ… ZilliqaAcademyTokenModule#ZilliqaAcademyToken - 0x1234567890123456789012345678901234567890
   
   [ ZilliqaAcademyTokenModule ] successfully deployed ðŸš€
   ```

### Post-Deployment Verification

**Verify your deployment:**

1. **Check contract on Zilliqa Blockscout:** https://zilliqa.blockscout.com
2. **Use Hardhat console to interact:**
   ```bash
   npx hardhat console --network zilliqaTestnet
   ```
   
   ```javascript
   const token = await ethers.getContractAt("ZilliqaAcademyToken", "YOUR_CONTRACT_ADDRESS");
   await token.name(); // Should return "Zilliqa Academy Token"
   await token.symbol(); // Should return "ZAT"
   await token.totalSupply(); // Should return initial supply
   ```

## Creating Interaction Scripts

### Contract Interaction Script

**Create `scripts/interact.ts`:**

```typescript
import { ethers } from "hardhat";

async function main() {
  // Replace with your deployed contract address
  const contractAddress = "YOUR_DEPLOYED_CONTRACT_ADDRESS";
  const token = await ethers.getContractAt("ZilliqaAcademyToken", contractAddress);
  
  // Get contract info
  console.log("=== Token Information ===");
  console.log("Token Name:", await token.name());
  console.log("Token Symbol:", await token.symbol());
  console.log("Total Supply:", ethers.formatEther(await token.totalSupply()));
  console.log("Max Supply:", ethers.formatEther(await token.getMaxSupply()));
  console.log("Remaining Mintable:", ethers.formatEther(await token.getRemainingMintableSupply()));
  
  // Get deployer info
  const [deployer] = await ethers.getSigners();
  console.log("\n=== Deployer Information ===");
  console.log("Deployer Address:", deployer.address);
  console.log("Deployer Balance:", ethers.formatEther(await token.balanceOf(deployer.address)));
  
  // Check roles
  console.log("\n=== Role Information ===");
  console.log("Has Admin Role:", await token.hasRole(await token.DEFAULT_ADMIN_ROLE(), deployer.address));
  console.log("Has Minter Role:", await token.hasRole(await token.MINTER_ROLE(), deployer.address));
  console.log("Has Pauser Role:", await token.hasRole(await token.PAUSER_ROLE(), deployer.address));
  console.log("Has Burner Role:", await token.hasRole(await token.BURNER_ROLE(), deployer.address));
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

**Run interaction script:**

```bash
npx hardhat run scripts/interact.ts --network zilliqaTestnet
```

## Production Deployment Checklist

### Pre-Deployment Security Review

**Before mainnet deployment:**

âœ… **Code Review:** Have the contract reviewed by multiple developers
âœ… **Security Audit:** Consider professional security audit for significant projects
âœ… **Comprehensive Testing:** All tests pass with high coverage
âœ… **Gas Optimization:** Analyze and optimize gas usage
âœ… **Documentation:** Complete documentation and comments
âœ… **Role Management:** Plan initial role assignments
âœ… **Emergency Procedures:** Document pause and recovery procedures
âœ… **Multi-sig Setup:** Consider multi-signature wallets for admin functions

### Mainnet Deployment Process

**When ready for production:**

```bash
# Deploy to Zilliqa Mainnet (use with extreme caution!)
npx hardhat ignition deploy ignition/modules/ZilliqaAcademyToken.ts --network zilliqaMainnet --parameters '{"ZilliqaAcademyTokenModule": {"initialOwner": "YOUR_PRODUCTION_WALLET_ADDRESS"}}'
```

### Post-Deployment Tasks

**After successful deployment:**

1. **Contract Verification:** Submit source code to block explorer
2. **Role Distribution:** Grant roles to appropriate addresses
3. **Security Monitoring:** Set up monitoring for unusual activity
4. **Documentation:** Update all documentation with contract addresses
5. **Community Announcement:** Announce deployment to your community
6. **Exchange Listings:** Begin process for exchange listings if applicable

## Testing Summary

Your professional token contract now has:

âœ… **Comprehensive unit tests** covering all functions and edge cases
âœ… **Integration tests** simulating real-world usage scenarios
âœ… **Gas optimization analysis** for cost-effective operations
âœ… **Professional deployment** using Hardhat Ignition
âœ… **Verification procedures** for post-deployment validation
âœ… **Interaction scripts** for ongoing contract management

The final module will cover production integration, MetaMask setup, and long-term maintenance best practices for your deployed token!
