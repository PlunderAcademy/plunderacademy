---
id: "dapp-security-lesson-1"
slug: "common-vulnerability-patterns"
module: "advanced-security"
number: "5.12"
title: "Common Vulnerability Patterns Deep Dive"
objective: "Master the most critical smart contract vulnerabilities and learn to identify and prevent them in production code."
practicalTakeaway: "Build exploit-resistant contracts by understanding attack patterns that have drained billions from DeFi protocols."
---

# Common Vulnerability Patterns Deep Dive

## Why this matters now

You've built complete dApps across Islands 1-4, deploying tokens, staking contracts, NFTs, and upgradeable systems. In Island 5's Modules 1-3, you learned to connect wallets, read contract data, and handle transactions in frontend applications. Every line of Solidity you've writtenâ€”and every contract interaction you've integratedâ€”could contain vulnerabilities that attackers actively scan for. The difference between a successful protocol and a $600M hack often comes down to understanding a handful of critical patterns.

This lesson dissects the vulnerabilities that matter most: reentrancy, access control failures, arithmetic issues, and unchecked external calls. You'll see real exploit scenarios, understand why naive fixes fail, and implement battle-tested defenses. By the end, you'll recognize vulnerability patterns instantly in both backend contracts and frontend integration code, and know exactly how to patch them.

## Conceptual foundations for smart contract security

**Definition â€” Reentrancy**: When a contract calls an external address that calls back into the original contract before the first execution completes, potentially manipulating state. **When it's dangerous**: Any function that sends ETH or tokens before updating critical state variables. The attacker exploits the gap between sending value and updating balances.

**Definition â€” Access control bypass**: When privileged functions can be called by unauthorized addresses due to missing or incorrect permission checks. **When it's dangerous**: Admin functions (pausing, minting, upgrading), withdrawal functions, and configuration changes. A single missing `onlyOwner` can compromise the entire protocol.

**Definition â€” Integer overflow/underflow**: When arithmetic operations exceed type boundaries (pre-Solidity 0.8.0) or fail silently, causing unexpected values. **When it's dangerous**: Balance calculations, reward distributions, price computations, and any math involving user input.

**Definition â€” Unchecked external calls**: When low-level calls (`call`, `delegatecall`, `send`) fail silently without checking return values. **When it's dangerous**: ETH transfers, token operations, and cross-contract interactions where failures must be detected and handled.

**Mental model â€” Attack surface analysis**: Every external function is a potential entry point. Every state change is a potential target. Every external call is a trust boundary. Map these surfaces systematically before deploying.

**Anti-pattern â€” Security by obscurity**: Assuming attackers won't find edge cases or that complexity provides protection. **Why it fails**: Automated scanners, bytecode analysis, and economic incentives mean every public contract gets scrutinized. Explicit defenses beat clever tricks.

## Guided code walk-throughs

### 1) Reentrancy: The recursive drain attack

Reentrancy has enabled countless DeFi exploits totaling billions in losses. It occurs when external calls allow attackers to re-enter your contract mid-execution, manipulating state before the original call completes.

#### The vulnerable pattern

```solidity
// VULNERABLE: Classic reentrancy in withdrawal function
contract VulnerableBank {
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // ðŸš¨ VULNERABILITY: External call before state update
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        // âš ï¸ State updated AFTER external call
        balances[msg.sender] -= amount;
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

**Why this is exploitable:**

1. Attacker calls `withdraw(100 ether)`
2. Contract checks balance (âœ“ passes)
3. Contract sends 100 ETH via `call{value: amount}("")`
4. This triggers attacker's `receive()` function
5. Attacker's `receive()` calls `withdraw(100 ether)` again
6. Balance hasn't been updated yet, so check passes again
7. Loop continues until contract is drained
8. Finally, all balance updates execute (too late)

#### The attack contract

```solidity
contract ReentrancyAttacker {
    VulnerableBank public bank;
    uint256 public attackAmount = 1 ether;

    constructor(address _bankAddress) {
        bank = VulnerableBank(_bankAddress);
    }

    // Initial attack trigger
    function attack() external payable {
        require(msg.value >= attackAmount, "Need attack capital");
        bank.deposit{value: attackAmount}();
        bank.withdraw(attackAmount);
    }

    // Reentrancy exploit hook
    receive() external payable {
        if (address(bank).balance >= attackAmount) {
            bank.withdraw(attackAmount);  // Recursive call
        }
    }

    function getStolen() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}
```

**Attack execution:**
1. Attacker deposits 1 ETH
2. Attacker withdraws 1 ETH â†’ triggers `receive()`
3. `receive()` calls withdraw again (balance still shows 1 ETH)
4. Loop drains entire contract balance
5. Each iteration executes before state updates

#### The secure implementation: Checks-Effects-Interactions

```solidity
// SECURE: Follows CEI pattern + ReentrancyGuard
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract SecureBank is ReentrancyGuard {
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external nonReentrant {
        // âœ… CHECKS: Validate conditions first
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // âœ… EFFECTS: Update state BEFORE external calls
        balances[msg.sender] -= amount;
        
        // âœ… INTERACTIONS: External calls last
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

**How this prevents reentrancy:**

1. **Checks-Effects-Interactions (CEI) pattern**: State changes happen before external calls
2. **ReentrancyGuard modifier**: Sets a lock during execution, blocks recursive calls
3. **Balance zeroed first**: Even if reentry occurs, balance check fails

**Key defense principles:**
- Always update state BEFORE external calls
- Use OpenZeppelin's `ReentrancyGuard` for critical functions
- Use `call{value: x}("")` for ETH transfers (forwards all gas and allows proper error handling)
- Test with malicious receiver contracts

#### Testing reentrancy defenses with Hardhat

```javascript
// Hardhat test for reentrancy protection
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Reentrancy Protection", function () {
  let bank, attacker, owner, user;

  beforeEach(async function () {
    [owner, user] = await ethers.getSigners();
    
    // Deploy vulnerable bank for comparison testing
    const VulnerableBank = await ethers.getContractFactory("VulnerableBank");
    const vulnerableBank = await VulnerableBank.deploy();
    
    // Deploy secure bank with ReentrancyGuard
    const SecureBank = await ethers.getContractFactory("SecureBank");
    bank = await SecureBank.deploy();
    
    // Seed both banks with funds from other users
    await bank.deposit({ value: ethers.parseEther("10") });
    await vulnerableBank.deposit({ value: ethers.parseEther("10") });
    
    // Deploy attacker contract targeting the secure bank
    const Attacker = await ethers.getContractFactory("ReentrancyAttacker");
    attacker = await Attacker.deploy(await bank.getAddress());
  });

  it("should prevent reentrancy attack on secure bank", async function () {
    const attackAmount = ethers.parseEther("1");
    
    // Attempt reentrancy attack - should revert with guard error
    await expect(
      attacker.attack({ value: attackAmount })
    ).to.be.revertedWith("ReentrancyGuard: reentrant call");
    
    // Verify bank balance remains intact after failed attack
    expect(await bank.getBalance()).to.equal(ethers.parseEther("10"));
  });

  it("should allow legitimate withdrawals without blocking normal flow", async function () {
    // User deposits funds
    await bank.connect(user).deposit({ value: ethers.parseEther("2") });
    
    // User withdraws normally - should succeed
    await expect(
      bank.connect(user).withdraw(ethers.parseEther("1"))
    ).to.changeEtherBalances(
      [user, bank],
      [ethers.parseEther("1"), ethers.parseEther("-1")]
    );
  });
});
```

#### Testing reentrancy defenses with Foundry (Alternative)

For developers preferring Foundry's faster execution and native Solidity testing:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/SecureBank.sol";
import "../src/ReentrancyAttacker.sol";

contract ReentrancyProtectionTest is Test {
    SecureBank bank;
    ReentrancyAttacker attacker;
    address user;

    function setUp() public {
        user = makeAddr("user");
        bank = new SecureBank();
        
        // Seed bank with funds
        vm.deal(address(bank), 10 ether);
        
        // Deploy attacker contract
        attacker = new ReentrancyAttacker(address(bank));
    }

    function testPreventReentrancyAttack() public {
        uint256 attackAmount = 1 ether;
        vm.deal(address(attacker), attackAmount);
        
        // Attempt attack - should revert
        vm.expectRevert("ReentrancyGuard: reentrant call");
        attacker.attack{value: attackAmount}();
        
        // Bank balance should remain intact
        assertEq(address(bank).balance, 10 ether);
    }

    function testLegitimateWithdrawal() public {
        vm.deal(user, 2 ether);
        
        // User deposits
        vm.prank(user);
        bank.deposit{value: 2 ether}();
        
        // User withdraws
        uint256 balanceBefore = user.balance;
        vm.prank(user);
        bank.withdraw(1 ether);
        
        assertEq(user.balance, balanceBefore + 1 ether);
    }
}
```

**Testing with Foundry:** Run `forge test -vv` to see detailed output of both tests.

### 2) Access control failures: The protocol killer

Access control vulnerabilities allow unauthorized users to execute privileged functions. From minting unlimited tokens to pausing critical operations, these bugs have caused hundreds of millions in losses across DeFi protocols.

#### The vulnerable pattern

```solidity
// VULNERABLE: Missing access control on critical function
contract VulnerableToken {
    address public owner;
    mapping(address => uint256) public balances;
    bool public paused;

    constructor() {
        owner = msg.sender;  // Manual owner assignment (no inheritance)
    }

    function mint(address to, uint256 amount) external {
        // ðŸš¨ VULNERABILITY: No access control check
        balances[to] += amount;
    }

    function pause() external {
        // ðŸš¨ VULNERABILITY: Anyone can pause
        paused = true;
    }

    function updateOwner(address newOwner) external {
        // ðŸš¨ VULNERABILITY: No modifier protection
        require(msg.sender == owner, "Not owner");  // Easy to forget
        owner = newOwner;
    }

    function transfer(address to, uint256 amount) external {
        require(!paused, "Transfers paused");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
```

**Exploitation scenarios:**
1. **Unlimited minting**: Anyone calls `mint()` to create infinite tokens
2. **DoS via pause**: Attacker pauses contract, blocking all transfers
3. **Owner takeover**: If `updateOwner` check is removed during refactor, instant takeover

#### The secure implementation with OpenZeppelin

```solidity
// SECURE: Comprehensive access control with OpenZeppelin v5.x
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract SecureToken is Ownable, Pausable, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {  // v5.x: Explicit initial owner
        // Grant roles to deployer initially
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
    }

    // âœ… SECURE: Role-based access control
    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
        balances[to] += amount;
        emit Minted(to, amount);
    }

    // âœ… SECURE: Separate pauser role
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    // âœ… SECURE: Owner-only with explicit modifier
    function emergencyWithdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    // âœ… SECURE: Pausable transfers
    function transfer(address to, uint256 amount) external whenNotPaused {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }

    // âœ… SECURE: Two-step ownership transfer (built into Ownable2Step)
    // Use Ownable2Step for production to prevent accidental owner loss

    event Minted(address indexed to, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);
}
```

**Defense layers:**
1. **Role-based access control (RBAC)**: Separate roles for different privileges
2. **Explicit modifiers**: `onlyOwner`, `onlyRole()` make permissions impossible to miss
3. **Pausable pattern**: Emergency stop mechanism with role protection
4. **Event logging**: All privileged actions emit events for monitoring
5. **Two-step ownership transfer**: Prevents accidental owner loss (use `Ownable2Step`)

#### Testing access control

```javascript
// Hardhat test for access control
describe("Access Control", function () {
  let token, owner, minter, user, attacker;

  beforeEach(async function () {
    [owner, minter, user, attacker] = await ethers.getSigners();
    
    const SecureToken = await ethers.getContractFactory("SecureToken");
    token = await SecureToken.deploy();
    
    // Grant minter role
    const MINTER_ROLE = await token.MINTER_ROLE();
    await token.grantRole(MINTER_ROLE, minter.address);
  });

  it("should allow minter to mint tokens", async function () {
    await token.connect(minter).mint(user.address, 1000);
    expect(await token.balances(user.address)).to.equal(1000);
  });

  it("should prevent non-minter from minting", async function () {
    await expect(
      token.connect(attacker).mint(attacker.address, 1000)
    ).to.be.revertedWith(/AccessControl: account .* is missing role/);
  });

  it("should allow owner to pause", async function () {
    const PAUSER_ROLE = await token.PAUSER_ROLE();
    await token.grantRole(PAUSER_ROLE, owner.address);
    
    await token.connect(owner).pause();
    expect(await token.paused()).to.be.true;
  });

  it("should prevent transfers when paused", async function () {
    const PAUSER_ROLE = await token.PAUSER_ROLE();
    await token.grantRole(PAUSER_ROLE, owner.address);
    
    // Mint tokens to user
    await token.connect(minter).mint(user.address, 1000);
    
    // Pause contract
    await token.connect(owner).pause();
    
    // Transfer should fail
    await expect(
      token.connect(user).transfer(attacker.address, 100)
    ).to.be.revertedWith("Pausable: paused");
  });
});
```

### 3) Integer overflow/underflow: The silent killer

Before Solidity 0.8.0, integer operations could wrap silently. Even with built-in checks, unsafe casts and unchecked blocks can still cause issues.

#### The vulnerable pattern (pre-0.8.0)

```solidity
// VULNERABLE: Pre-0.8.0 overflow behavior
pragma solidity ^0.7.6;

contract VulnerableVault {
    mapping(address => uint256) public balances;

    function deposit(uint256 amount) external {
        // ðŸš¨ VULNERABILITY: Can overflow
        balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external {
        // ðŸš¨ VULNERABILITY: Can underflow
        balances[msg.sender] -= amount;
        // Transfer logic...
    }

    // Reward calculation vulnerability
    function calculateReward(uint256 stakedAmount, uint256 multiplier) 
        external 
        pure 
        returns (uint256) 
    {
        // ðŸš¨ VULNERABILITY: Multiplication overflow
        return stakedAmount * multiplier;
    }
}
```

**Exploitation:**
- Deposit `type(uint256).max - 100`, then deposit `200` â†’ wraps to `99`
- Withdraw more than balance â†’ underflows to massive number
- Multiply large values â†’ overflow to small reward

#### Modern Solidity with safe math (0.8.0+)

```solidity
// SECURE: Solidity 0.8.0+ has built-in overflow checks
pragma solidity ^0.8.0;

contract ModernVault {
    mapping(address => uint256) public balances;

    function deposit(uint256 amount) external {
        // âœ… SECURE: Automatically reverts on overflow
        balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external {
        // âœ… SECURE: Automatically reverts on underflow
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        // Transfer logic...
    }

    function calculateReward(uint256 stakedAmount, uint256 multiplier) 
        external 
        pure 
        returns (uint256) 
    {
        // âœ… SECURE: Reverts on overflow
        return stakedAmount * multiplier;
    }
}
```

#### Hidden dangers: Unsafe casts and unchecked blocks

```solidity
// STILL VULNERABLE: Unsafe downcasting in 0.8.0+
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/math/SafeCast.sol";

contract CastingDangers {
    using SafeCast for uint256;

    function unsafeCast(uint256 amount) external pure returns (uint8) {
        // ðŸš¨ VULNERABILITY: Silently truncates (300 â†’ 44)
        return uint8(amount);
    }

    function safeCast(uint256 amount) external pure returns (uint8) {
        // âœ… SECURE: Reverts if out of range
        require(amount <= type(uint8).max, "Value too large");
        return uint8(amount);
    }

    // Using OpenZeppelin SafeCast (recommended)
    function safestCast(uint256 amount) external pure returns (uint8) {
        return amount.toUint8();  // Reverts on overflow (using SafeCast library)
    }
}

contract UncheckedDangers {
    function unsafeLoop(uint256[] calldata values) external pure returns (uint256) {
        uint256 sum = 0;
        
        // ðŸš¨ VULNERABILITY: Unchecked block disables overflow protection
        unchecked {
            for (uint256 i = 0; i < values.length; i++) {
                sum += values[i];  // Can overflow silently
            }
        }
        
        return sum;
    }

    function safeLoop(uint256[] calldata values) external pure returns (uint256) {
        uint256 sum = 0;
        
        // âœ… SECURE: Checked arithmetic (default)
        for (uint256 i = 0; i < values.length; i++) {
            sum += values[i];  // Reverts on overflow
        }
        
        return sum;
    }
}
```

**Modern safety guidelines:**
- Solidity 0.8.0+ protects against overflow/underflow by default
- **Still vulnerable**: Downcasting (`uint256` â†’ `uint8`), unchecked blocks
- Use OpenZeppelin's `SafeCast` library for type conversions
- Only use `unchecked` when you've proven overflow is mathematically impossible
- Always validate inputs that could cause overflow in multiplications

### 4) Unchecked external calls: The silent failure

Low-level calls (`call`, `delegatecall`, `send`) return success booleans that many developers ignore.

#### The vulnerable pattern

```solidity
// VULNERABLE: Ignoring return values
contract VulnerablePayments {
    mapping(address => uint256) public pendingWithdrawals;

    function withdraw() external {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No funds");
        
        pendingWithdrawals[msg.sender] = 0;
        
        // ðŸš¨ VULNERABILITY: Ignoring return value
        payable(msg.sender).send(amount);
    }

    function batchPay(address[] calldata recipients, uint256[] calldata amounts) 
        external 
    {
        for (uint256 i = 0; i < recipients.length; i++) {
            // ðŸš¨ VULNERABILITY: Call can fail silently
            payable(recipients[i]).call{value: amounts[i]}("");
            // Continues even if payment failed
        }
    }
}
```

**Why this is dangerous:**
- `send()` forwards 2300 gas (often insufficient) and returns `false` on failure
- `call()` forwards all gas but return value must be checked
- State updates without confirming transfers â†’ accounting errors
- Users lose funds with no indication

#### The secure implementation

```solidity
// SECURE: Always check return values
contract SecurePayments {
    mapping(address => uint256) public pendingWithdrawals;

    // Events (declare at top)
    event PaymentFailed(address indexed recipient, uint256 amount);
    event WithdrawalProcessed(address indexed recipient, uint256 amount);
    event BatchPaymentCompleted(uint256 successCount, uint256 failCount);

    function withdraw() external {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No funds");
        
        pendingWithdrawals[msg.sender] = 0;
        
        // âœ… SECURE: Check return value
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Transfer failed");
        
        emit WithdrawalProcessed(msg.sender, amount);
    }

    function batchPay(address[] calldata recipients, uint256[] calldata amounts) 
        external 
        returns (bool[] memory results)
    {
        require(recipients.length == amounts.length, "Length mismatch");
        results = new bool[](recipients.length);
        
        uint256 successCount = 0;
        uint256 failCount = 0;
        
        for (uint256 i = 0; i < recipients.length; i++) {
            // âœ… SECURE: Track success/failure
            (bool success, ) = payable(recipients[i]).call{value: amounts[i]}("");
            results[i] = success;
            
            if (success) {
                successCount++;
            } else {
                failCount++;
                // âœ… SECURE: Log failures for investigation
                emit PaymentFailed(recipients[i], amounts[i]);
            }
        }
        
        emit BatchPaymentCompleted(successCount, failCount);
        return results;
    }

    // Alternative: Pull payments pattern (safest for user withdrawals)
    function claimPayment() external {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No funds");
        
        pendingWithdrawals[msg.sender] = 0;
        
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        if (!success) {
            // Restore balance if transfer fails
            pendingWithdrawals[msg.sender] = amount;
            revert("Transfer failed");
        }
    }
}
```

**Best practices:**
- Always check return values from `call`, `send`, `transfer`
- Prefer `call{value: x}("")` over `transfer()` (forwards all gas)
- Use pull payments (withdrawal pattern) for user-initiated transfers
- Log failures for monitoring and debugging
- Consider batch operation failures (revert all vs partial success)

## Hands-on with AI Reviewer

The AI Solidity Reviewer at `/reviewer` is trained to detect these exact patterns. Let's practice identifying vulnerabilities.

### Exercise 1: Test the vulnerable bank

Copy this vulnerable contract into the AI Reviewer:

```solidity
pragma solidity ^0.8.0;

contract BankExercise {
    mapping(address => uint256) public balances;
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        balances[msg.sender] -= amount;
    }
    
    function transfer(address to, uint256 amount) external {
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
```

**Expected AI findings:**
- **Critical**: Reentrancy in `withdraw()` (state update after external call)
- **High**: No reentrancy protection on `transfer()` (if combined with other functions)
- **Medium**: Missing events for auditability

**What to look for in the AI report:**
- Severity score (should be 8-10/10 for reentrancy)
- Attack scenario explanation
- Code fix with CEI pattern
- Recommendation to use `ReentrancyGuard`

### Exercise 2: Access control audit

Paste this into the AI Reviewer:

```solidity
pragma solidity ^0.8.0;

contract TokenExercise {
    address public owner;
    mapping(address => uint256) public balances;
    bool public paused;
    
    constructor() {
        owner = msg.sender;
    }
    
    function mint(address to, uint256 amount) external {
        balances[to] += amount;
    }
    
    function pause() external {
        require(msg.sender == owner, "Not owner");
        paused = true;
    }
    
    function transfer(address to, uint256 amount) external {
        require(!paused, "Paused");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
```

**Expected AI findings:**
- **Critical**: Missing access control on `mint()` (unlimited token creation)
- **Medium**: Manual owner check instead of modifier (error-prone)
- **Low**: No events for privileged actions

**Interpretation practice:**
- Does the AI correctly identify the missing access control?
- Does it recommend OpenZeppelin's `Ownable`?
- Does it suggest role-based access control patterns?

### Exercise 3: Combined vulnerabilities

Challenge yourself with this multi-vulnerability contract:

```solidity
pragma solidity ^0.8.0;

contract StakingExercise {
    mapping(address => uint256) public stakes;
    mapping(address => uint256) public rewards;
    
    function stake() external payable {
        stakes[msg.sender] += msg.value;
    }
    
    function calculateReward(address user) public view returns (uint256) {
        return stakes[user] * 1000;  // 1000x multiplier
    }
    
    function claimReward() external {
        uint256 reward = calculateReward(msg.sender);
        rewards[msg.sender] += reward;
        stakes[msg.sender] = 0;
        payable(msg.sender).call{value: reward}("");
    }
    
    function emergencyWithdraw() external {
        uint256 amount = stakes[msg.sender];
        stakes[msg.sender] = 0;
        payable(msg.sender).send(amount);
    }
}
```

**Hidden vulnerabilities** (can you spot them before the AI?):
1. Reentrancy in `claimReward()`
2. Unchecked return value in `emergencyWithdraw()`
3. Potential overflow in `calculateReward()` (large stakes Ã— 1000)
4. No validation that contract has sufficient balance

**How to use AI findings:**
- Compare your analysis to the AI's report
- Note severity scores (do they match your intuition?)
- Review recommended fixes (do they address root causes?)
- Check if AI links to relevant Plunder Academy lessons

### Secure implementation of StakingExercise

Here's the corrected version addressing all four vulnerabilities:

```solidity
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract SecureStaking is ReentrancyGuard {
    IERC20 public immutable stakingToken;
    
    mapping(address => uint256) public stakes;
    mapping(address => uint256) public rewards;
    
    uint256 public constant MAX_MULTIPLIER = 100;  // Prevent overflow
    
    constructor(address _stakingToken) {
        require(_stakingToken != address(0), "Invalid token address");
        stakingToken = IERC20(_stakingToken);
    }
    
    function stake(uint256 amount) external {
        require(amount > 0, "Cannot stake 0");
        stakingToken.transferFrom(msg.sender, address(this), amount);
        stakes[msg.sender] += amount;
    }
    
    function calculateReward(address user) public view returns (uint256) {
        // âœ… SECURE: Use safe multiplication with overflow protection
        uint256 staked = stakes[user];
        require(staked <= type(uint256).max / MAX_MULTIPLIER, "Stake too large");
        return staked * MAX_MULTIPLIER;
    }
    
    function claimReward() external nonReentrant {
        uint256 reward = calculateReward(msg.sender);
        
        // âœ… SECURE: Check contract has sufficient balance
        require(address(this).balance >= reward, "Insufficient contract balance");
        
        // âœ… SECURE: Update state BEFORE external call (CEI pattern)
        rewards[msg.sender] += reward;
        stakes[msg.sender] = 0;
        
        // âœ… SECURE: Check return value
        (bool success, ) = payable(msg.sender).call{value: reward}("");
        require(success, "Transfer failed");
    }
    
    function emergencyWithdraw() external nonReentrant {
        uint256 amount = stakes[msg.sender];
        require(amount > 0, "No stake to withdraw");
        
        // âœ… SECURE: Update state first
        stakes[msg.sender] = 0;
        
        // âœ… SECURE: Use call and check return value
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Transfer failed");
    }
    
    receive() external payable {}  // Allow contract to receive ETH for rewards
}
```

**Compare your fixes:** Did you catch all four vulnerabilities? Did you use ReentrancyGuard, check return values, add overflow protection, and validate balances?

## Real-world case studies

### Nomad Bridge (August 2022): $190M initialization vulnerability

**The vulnerability:** The bridge's Replica contract had an improper initialization that allowed any message to be considered valid.

```solidity
function process(bytes memory _message) public {
    // ðŸš¨ VULNERABILITY: Uninitialized merkle root = 0x00
    // Any message with proof against 0x00 passes validation
    require(acceptableRoot(_message), "!root");
    // ... process withdrawal ...
}
```

**The exploit:** Attackers discovered that the contract's trusted root was set to `0x00` (uninitialized), allowing them to forge arbitrary messages and drain funds. Within hours, copycat attackers joined, draining $190M total.

**The aftermath:** One of the largest bridge hacks in DeFi history. Highlighted the critical importance of proper initialization and access control on bridge contracts.

**Lesson:** Initialize functions must be protected and called exactly once during deployment. Never rely on default values for security-critical parameters.

### Euler Finance (March 2023): $197M donation attack

**The vulnerability:** Euler's health check implementation incorrectly handled donated collateral, allowing attackers to manipulate their debt/collateral ratio.

```solidity
function liquidate(address violator) external {
    // ðŸš¨ VULNERABILITY: Health check uses donated balance
    uint256 collateral = balanceOf(violator);  // Includes donated tokens
    uint256 debt = debtOf(violator);
    require(collateral < debt, "Not liquidatable");
    // ...
}
```

**The exploit:** Attacker took a flash loan, deposited collateral, borrowed against it, then "donated" tokens to themselves to manipulate the health check. This allowed them to mint eTokens without proper backing and drain $197M across multiple assets.

**The aftermath:** One of 2023's largest DeFi hacks. Funds were eventually returned after negotiation. Exposed the risks of complex DeFi composability and the need for rigorous economic attack modeling.

**Lesson:** Access control extends beyond admin functionsâ€”economic invariants must be protected. Never trust balances that can be manipulated via donations or external transfers.

### Poly Network (2021): $611M cross-chain exploit

**The vulnerability:** Insufficient validation of cross-chain message signatures allowed attacker to forge transactions from trusted addresses.

**The aftermath:** Largest DeFi hack ever. Attacker returned funds (surprisingly), but exposed critical cross-chain bridge vulnerabilities.

**Lesson:** External calls to bridges/oracles need rigorous validation. Never trust cross-contract data without verification.

## Common vulnerability checklist

Use this checklist before deploying any contract:

### State-Changing Functions
- [ ] All external calls follow Checks-Effects-Interactions pattern
- [ ] Critical functions use `ReentrancyGuard` modifier
- [ ] No state updates after external calls (except pull patterns)

### Access Control
- [ ] All privileged functions have explicit modifiers (`onlyOwner`, `onlyRole`)
- [ ] Initialize functions are protected or disabled after init
- [ ] Owner/admin addresses are validated (not zero address)
- [ ] Two-step ownership transfer for critical contracts

### Arithmetic & Logic
- [ ] Using Solidity 0.8.0+ for automatic overflow checks
- [ ] All downcasts use `SafeCast` library
- [ ] `unchecked` blocks are justified and documented
- [ ] Division checks for zero denominator

### External Interactions
- [ ] All `call`, `send`, `delegatecall` return values checked
- [ ] Pull payment pattern for user withdrawals
- [ ] Gas limits considered for external calls
- [ ] Fallback/receive functions are minimal or absent

### Input Validation
- [ ] All user inputs validated (amounts, addresses, arrays)
- [ ] Array lengths checked before loops
- [ ] Zero address checks on critical parameters
- [ ] Reasonable bounds on numeric inputs

## Wrap-up and next steps

You now understand the vulnerability patterns that have cost the industry billions. Reentrancy, access control failures, arithmetic errors, and unchecked calls are the foundation of smart contract securityâ€”get these right and you prevent 80% of exploits.

**Critical takeaways:**
1. **Checks-Effects-Interactions** is non-negotiable for functions with external calls
2. **Explicit access control** with OpenZeppelin libraries prevents catastrophic mistakes
3. **Modern Solidity (0.8.0+)** provides safety by default, but know the edge cases
4. **Check all return values** from low-level callsâ€”silent failures drain funds

**Practical next steps:**
1. Audit your existing contracts with these patterns in mind
2. Use the AI Reviewer to scan all code before production deployment
3. Add comprehensive tests for each vulnerability class
4. Implement OpenZeppelin's security contracts (`ReentrancyGuard`, `Ownable`, `Pausable`)

**In the next lesson (ai-auditor-findings-interpretation),** you'll learn to interpret AI auditor reports, understand severity scoring, and prioritize fixes based on exploitability and impact. The AI Reviewer becomes a powerful ally once you can read its findings like a security expert.

**Security is a practice, not a checklist.** Every contract you review, every test you write, every exploit you study builds your threat model. Stay paranoid, test exhaustively, and never assume "it won't happen to me."

