---
id: "dapp-practical-lesson-1"
slug: "intro-to-dapp-development"
module: "dapp-interface-practical"
number: "5.6"
title: "Introduction to dApp Interface Development"
objective: "Understand what you'll build in this module and how frontend Web3 development brings your contracts to life."
practicalTakeaway: "Plan and scaffold a production-ready Web3 frontend that connects to your deployed contracts."
---

# Introduction to dApp Interface Development

## Welcome to the Final Island

Congratulations on making it to Island 5! You've deployed an ERC20 token, built a staking contract with time-based rewards, created an NFT collection with reveal mechanics, and mastered upgradeable contracts with proxy patterns. Now it's time to **bring it all to life** with a Web3 frontend.

In this module, you'll build a **complete dApp interface** from scratch that:
- âœ… **Connects wallets** with RainbowKit (MetaMask, WalletConnect, etc.)
- âœ… **Reads contract data** (ERC20 balances, NFT collections)
- âœ… **Writes to contracts** (token transfers with full transaction lifecycle)
- âœ… **Handles errors gracefully** (user rejections, reverts, network issues)
- âœ… **Manages network state** (Zilliqa testnet enforcement)
- âœ… **Provides great UX** (loading states, success feedback, clear messaging)

By the end, you'll have a **working dApp** that interacts with the contracts you deployed in previous islandsâ€”running locally and ready for production deployment.

## What Makes Web3 Frontends Different?

You've built traditional web apps before, but Web3 introduces new paradigms:

<Web3ArchitectureVisualizer />

<table>
<thead>
<tr>
<th>Concept</th>
<th>Traditional Web App</th>
<th>Web3 dApp</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authentication</strong></td>
<td>Username/password or OAuth</td>
<td>Wallet connection (sign-in with Zilliqa)</td>
</tr>
<tr>
<td><strong>Data source</strong></td>
<td>Backend API (REST/GraphQL)</td>
<td>Blockchain + RPC nodes</td>
</tr>
<tr>
<td><strong>State management</strong></td>
<td>Local state + server sync</td>
<td>Local state + blockchain sync + wallet state</td>
</tr>
<tr>
<td><strong>Write operations</strong></td>
<td>HTTP POST to API</td>
<td>Wallet signature â†’ transaction â†’ wait for confirmation</td>
</tr>
<tr>
<td><strong>Error handling</strong></td>
<td>Network errors, validation</td>
<td>User rejections, reverts, wrong network, gas issues</td>
</tr>
<tr>
<td><strong>Persistence</strong></td>
<td>Database</td>
<td>Immutable blockchain (can't edit, only append)</td>
</tr>
</tbody>
</table>

**Mental model:**
- **Traditional app**: Client â†” Server â†” Database
- **Web3 dApp**: Client â†” Wallet â†” Blockchain (the wallet IS the auth + signing layer)

## What You'll Build

### Token Transfer dApp

A clean, production-ready interface for your ERC20 token with:

**Core features:**
- âœ… **Wallet connection** (RainbowKit button in header)
- âœ… **Network enforcement** (must be on Zilliqa testnet)
- âœ… **Token balance display** (real-time, auto-refreshing)
- âœ… **Transfer interface** (send tokens to any address)
- âœ… **Transaction tracking** (pending â†’ confirming â†’ success)
- âœ… **NFT viewer** (display NFTs owned by connected wallet)
- âœ… **Error handling** (friendly messages for all edge cases)

**User flow:**
1. User visits dApp
2. Clicks "Connect Wallet" â†’ RainbowKit modal appears
3. Selects MetaMask â†’ connects and signs
4. dApp detects network â†’ prompts switch to Zilliqa testnet if needed
5. Shows token balance and NFT collection
6. User enters recipient + amount â†’ clicks "Transfer"
7. MetaMask opens â†’ user confirms transaction
8. dApp shows "Pending..." â†’ then "Success!" when confirmed
9. Balance updates automatically

### Tech Stack

You'll use the same modern Web3 stack as Plunder Academy:

**Frontend framework:**
- Next.js 15 (App Router, React Server Components)
- TypeScript (type-safe contract interactions)
- Tailwind CSS v4 (beautiful, responsive UI)

**Web3 libraries:**
- **wagmi 2.x** - React hooks for Ethereum (useAccount, useReadContract, useWriteContract)
- **viem 2.x** - Low-level Ethereum library (replaces ethers.js, faster & smaller)
- **RainbowKit 2.x** - Wallet connection UI (beautiful, accessible, battle-tested)
- **TanStack Query** - Data fetching & caching (built into wagmi)

**Why these libraries?**
- **wagmi**: Industry standard, excellent TypeScript support, active maintenance
- **viem**: Modern, performant, tree-shakeable (only bundle what you use)
- **RainbowKit**: Best-in-class wallet UX, supports 100+ wallets out of the box
- Matches Plunder Academy's setup â†’ you can reference the source code

## Project Structure

Your dApp will follow this structure (matching Plunder Academy's patterns):

```
my-token-dapp/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ layout.tsx           # Root layout with providers
â”‚   â”‚   â”œâ”€â”€ page.tsx              # Home page
â”‚   â”‚   â””â”€â”€ globals.css           # Tailwind + theme CSS
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ wallet-connect.tsx    # Connect button
â”‚   â”‚   â”œâ”€â”€ network-guard.tsx     # Network enforcement
â”‚   â”‚   â”œâ”€â”€ token-balance.tsx     # Read balance
â”‚   â”‚   â”œâ”€â”€ transfer-form.tsx     # Write transfers
â”‚   â”‚   â””â”€â”€ nft-gallery.tsx       # Display NFTs
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ wagmi.ts              # Wagmi config (chains, transports)
â”‚   â”‚   â””â”€â”€ utils.ts              # Helper functions (cn, etc.)
â”‚   â””â”€â”€ providers.tsx             # Wrap wagmi + RainbowKit + theme
â”œâ”€â”€ .env.local                    # Environment variables
â”œâ”€â”€ package.json                  # Dependencies
â”œâ”€â”€ next.config.ts                # Next.js config
â”œâ”€â”€ tailwind.config.ts            # Tailwind config
â””â”€â”€ tsconfig.json                 # TypeScript config
```

**Key principles:**
- Small, focused components (single responsibility)
- Type-safe contracts (use ABIs with TypeScript)
- Composable UI (reuse NetworkGuard, loading states)
- Clear separation (reads vs writes, UI vs logic)

## Module Roadmap

### Lesson 5.6.1 (This Lesson)
**Introduction to dApp Development**
- What makes Web3 frontends unique
- Module overview and tech stack
- Prerequisites check

### Lesson 5.6.2
**Project Setup & Configuration**
- Scaffold Next.js project
- Install dependencies (wagmi, viem, RainbowKit)
- Configure wagmi for Zilliqa testnet
- Set up environment variables
- Add Tailwind and basic styling
- First run: localhost:3000

### Lesson 5.6.3
**Building Core Components**
- Create providers wrapper (WagmiProvider, RainbowKitProvider, ThemeProvider)
- Build wallet connection button
- Add network guard component
- Create app layout with header/footer
- Test wallet connection flow

### Lesson 5.6.4
**Reading Contract Data**
- Set up contract ABIs
- Build token balance component (useReadContract)
- Create NFT gallery component (read ERC721 balances)
- Add auto-refresh and loading states
- Format and display data

### Lesson 5.6.5
**Writing to Contracts**
- Build transfer form (recipient + amount)
- Implement transfer with useWriteContract
- Track transaction status (useWaitForTransactionReceipt)
- Show pending â†’ confirming â†’ success states
- Handle approval flows

### Lesson 5.6.6
**Polish & Local Testing**
- Add comprehensive error handling
- Improve loading skeletons
- Add success animations
- Test all flows locally
- Prepare for deployment (optional)

## Prerequisites

### âš ï¸ Important: Frontend Development Experience Required

**This module assumes you have experience with modern JavaScript/TypeScript frontend development.** If you're new to React, Next.js, or TypeScript, we strongly recommend learning the basics first before diving into Web3 frontends.

**Required knowledge:**
- âœ… **React fundamentals**: Functional components, hooks (useState, useEffect, useContext), props, conditional rendering
- âœ… **TypeScript basics**: Types, interfaces, type assertions, generics
- âœ… **Next.js App Router**: Pages, layouts, client vs server components, routing
- âœ… **Async JavaScript**: Promises, async/await, error handling
- âœ… **Modern ES6+**: Arrow functions, destructuring, spread operator, template literals

**ðŸ“š Learning Resources (if you need to level up first):**

**React:**
- [Official React Tutorial](https://react.dev/learn) - Start here for React basics
- [React Hooks Guide](https://react.dev/reference/react) - Master useState, useEffect, and more

**TypeScript:**
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html) - Official docs
- [TypeScript for React](https://react-typescript-cheatsheet.netlify.app/) - React-specific patterns

**Next.js:**
- [Next.js Learn Course](https://nextjs.org/learn) - Interactive tutorial (highly recommended!)
- [Next.js App Router Docs](https://nextjs.org/docs/app) - Official documentation
- [Next.js Examples](https://github.com/vercel/next.js/tree/canary/examples) - Real-world code examples

**Suggested timeline:** If you're new to these technologies, spend 1-2 weeks learning the basics before starting this module. It will make the Web3 concepts much easier to grasp!

---

### Blockchain Development Prerequisites

âœ… **Completed Islands 1-4** or have:
- Understanding of Solidity and smart contracts
- Deployed contracts on Zilliqa testnet (ERC20, NFT, or similar)
- Contract addresses and ABIs ready to use

âœ… **Completed Island 5, Lessons 5.1-5.5** (Web3 Frontend Basics)
- Wallet connection patterns
- Reading contract data
- Network management
- Transaction management
- Error handling and events

### Tools & Setup

âœ… **Tools installed:**
- Node.js 18+ and npm (or yarn/pnpm)
- VS Code (or preferred editor)
- MetaMask browser extension
- Zilliqa testnet configured in MetaMask
- Testnet ZIL in your wallet

âœ… **Contract information ready:**
- ERC20 token contract address (from Island 1)
- NFT collection contract address (from Island 3) - optional
- Contract ABIs (JSON files from Hardhat builds)

> **Don't have deployed contracts?** No problem! We'll provide example addresses and ABIs from Zilliqa testnet so you can follow along. You can swap in your own contracts later.

## Key Concepts to Remember

### From Previous Islands:

**Island 1 (ERC20 Token):**
- Contracts have functions (read: `balanceOf`, write: `transfer`)
- Functions have parameters (address, uint256) and return types
- ABIs describe the contract interface
- Events are emitted (Transfer, Approval)

**Island 2 (Staking):**
- Time-based contract state (block.timestamp)
- User-specific data (mapping of addresses to balances)
- Transaction lifecycle: send â†’ pending â†’ mined â†’ confirmed

**Island 3 (NFT Collection):**
- Token IDs (each NFT is unique: #1, #2, #3...)
- Metadata URIs (IPFS links to images/attributes)
- Owner tracking (which wallet owns which tokens)

**Island 4 (Upgradeability):**
- Proxy patterns (storage vs logic separation)
- Careful state management
- Testing before upgrades

### New for Frontend Development:

**Wallet as auth layer:**
- No passwords, just signatures
- User controls private keys (not you!)
- Each action requires user approval

**Asynchronous by default:**
- Blockchain calls are always async
- Wait for confirmations (1-2 seconds on Zilliqa)
- Handle loading states everywhere

**Gas and costs:**
- Reads are free (view functions)
- Writes cost gas (user pays)
- Users can reject transactions

**Network matters:**
- Wrong network = wrong data
- Enforce supported chains
- Guide users to switch

## Real-World Applications

The skills you learn here power:
- **DeFi interfaces** (Uniswap, Aave, Compound)
- **NFT marketplaces** (OpenSea, Rarible, LooksRare)
- **Gaming dApps** (Axie Infinity, Gods Unchained)
- **DAO interfaces** (Snapshot, Tally, Boardroom)
- **Wallet dashboards** (Zerion, Zapper, DeBank)
- **Token explorers** (Etherscan, custom dashboards)

Every Web3 app you've used follows these patterns.

## Development Philosophy

We follow the same principles as the previous islands:

**1. User Experience First**
- Clear feedback at every step
- Never leave users guessing
- Graceful error handling
- Accessible and responsive design

**2. Type Safety**
- TypeScript everywhere
- Typed ABIs for contract interactions
- Catch errors at compile-time, not runtime

**3. Composability**
- Small, reusable components
- Separation of concerns
- Easy to test and maintain

**4. Production Ready**
- Works on mobile wallets (WalletConnect)
- Handles edge cases (network switches, rejections)
- Performance optimized (only fetch what you need)
- Security conscious (never expose private keys)

## What Success Looks Like

By the end of this module, you will:

âœ… **Build a complete dApp** from scratch
- Modern Next.js 15 setup
- Full wallet integration
- Contract reads and writes
- Beautiful, responsive UI

âœ… **Understand the Web3 stack**
- How wagmi hooks work
- When to use viem utilities
- RainbowKit configuration
- Transaction lifecycle management

âœ… **Master common patterns**
- Connection state management
- Network enforcement
- Loading and error states
- Event listening and updates

âœ… **Have a portfolio piece**
- Working dApp running locally
- Clean, maintainable code
- Ready to deploy (Vercel/Netlify)
- Shareable with employers/clients

## Common Questions

**Q: Do I need to know React well?**
A: Basic React knowledge is enough. We'll explain hooks as we go, and you can reference Plunder Academy's source code for examples.

**Q: Can I use this with my existing contracts?**
A: Yes! As long as you have the contract address and ABI, you can connect any contract. We'll show you how.

**Q: Will this work on Ethereum/Polygon/other chains?**
A: Yes! Just change the chain config in wagmi. The patterns are identical across all EVM chains.

**Q: Do I need a backend/server?**
A: No! This is a fully client-side dApp. The blockchain IS your backend. (You can add a backend later for indexing, caching, etc.)

**Q: How much will this cost?**
A: $0! We'll use Zilliqa testnet (free), localhost dev server (free), and the deployment step is optional.

**Q: Can I use JavaScript instead of TypeScript?**
A: You can, but we strongly recommend TypeScript. Contract interactions with types are much safer and catch errors early.

**Q: What about mobile?**
A: RainbowKit handles mobile wallets via WalletConnect automatically. Your dApp will work on mobile browsers with MetaMask mobile, Rainbow, etc.

**Q: How is this different from web2 development?**
A: Main differences: async by default, wallet auth instead of passwords, blockchain as database, gas fees, and users can reject actions.

## Ready to Build?

You've built the contracts. Now let's build the interface that makes them usable!

**Next lesson:** We'll scaffold a fresh Next.js project, install dependencies, and configure wagmi + RainbowKit for Zilliqa testnet. You'll see "Hello World" + wallet connection working in under 15 minutes.

Let's go! ðŸš€

