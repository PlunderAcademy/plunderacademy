---
id: "contract-interactions-lesson-1"
slug: "transaction-management"
module: "contract-interactions-error-handling"
number: "5.4"
title: "Writing to Contracts and Transaction Management"
objective: "Master contract interactions, transaction status monitoring, and gas fee management."
practicalTakeaway: "Build dApps with reliable transaction handling and comprehensive user feedback."
---

# Writing to Contracts and Transaction Management

## Why this matters now

Reading data sets expectations; writing to contracts fulfills them. Transaction flows must be clear: prepare write, request wallet signature, show pending state, confirm success, and handle revert errors. We‚Äôll use wagmi‚Äôs write + receipt hooks to manage the full lifecycle.

<TransactionLifecycleVisualizer />

## Conceptual foundations for Web3 frontend

- **Definition ‚Äî `useWriteContract`**: wagmi hook to call state‚Äëchanging functions. **When to use it**: Mints, transfers, staking‚Äîany write that changes storage.
- **Definition ‚Äî `useWaitForTransactionReceipt`**: Track on‚Äëchain confirmation. **When to use it**: After getting a transaction hash to reflect pending/success/failure.
- **Definition ‚Äî Gas estimation**: Wallet/JSON‚ÄëRPC estimates cost to execute. **When to use it**: Pre‚Äëflight checks; surface costs to users.

## Guided code walk‚Äëthroughs

### 1) Write, track, and report status

Prepare a write, trigger the wallet, and subscribe to receipt updates. Display the hash and a success message upon confirmation; surface revert messages on failure.

```tsx
import { useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { erc20Abi } from "viem"; // Or: import erc20Abi from "@/lib/abis/erc20.json";

export function TransferToken({ token }: { token: `0x${string}` }) {
  const { data: hash, isPending: isSigPending, error: writeError, writeContract } = useWriteContract();
  const { isLoading, isSuccess, isError, error } = useWaitForTransactionReceipt({ hash });

  function submit(recipient: `0x${string}`, amount: bigint) {
    writeContract({ 
      address: token, 
      abi: erc20Abi, 
      functionName: "transfer", 
      args: [recipient, amount] 
    });
  }

  return (
    <div className="space-y-3">
      <button 
        onClick={() => submit("0x0000000000000000000000000000000000000001", 1n)}
        disabled={isSigPending || isLoading}
        className="rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-50"
      >
        Send 1 wei
      </button>
      
      {isSigPending && <p className="text-sm">‚è≥ Waiting for wallet signature‚Ä¶</p>}
      {hash && (
        <p className="text-sm">
          üìù Tx submitted: <span className="font-mono text-xs">{hash}</span>
        </p>
      )}
      {isLoading && <p className="text-sm">‚è≥ Confirming on-chain‚Ä¶</p>}
      {isSuccess && <p className="text-sm text-green-600">‚úÖ Success! Transaction confirmed.</p>}
      {writeError && <p className="text-sm text-red-600">‚ùå Error: {writeError.message}</p>}
      {isError && error && <p className="text-sm text-red-600">‚ùå Transaction reverted: {error.message}</p>}
    </div>
  );
}
```

Takeaway: Separate signature‚Äëpending from chain confirmation; show hash early and final status when confirmed.

### 2) Gas and UX hints

Estimate gas pre‚Äëflight where needed and hint at fees. Keep buttons disabled during pending states to prevent duplicates.

```tsx
// Pseudocode: show disabled button when pending
<button disabled={isSigPending || isLoading}>Mint</button>
```

Takeaway: Pending guards and cost hints reduce user anxiety and duplicate submits.

## Practical exercises

{/* Drag & Drop Code Puzzle */}
<DragDropPuzzle codeBlocks={[
  {"id":"b1","content":"const { data: hash, writeContract } = useWriteContract();","correctPosition":0},
  {"id":"b2","content":"writeContract({ address, abi, functionName: 'mint' });","correctPosition":1},
  {"id":"b3","content":"const { isSuccess } = useWaitForTransactionReceipt({ hash });","correctPosition":2}
]}/>

### Reflection

- What copy will you show for pending vs confirmed? Where will you display the hash?
- Which writes need fee hints up front in your app?

## UX and error handling best practices

- Show signature pending separate from confirmation pending.
- Keep users informed at each stage; include a link to a block explorer when possible.
- Disable duplicate actions while a write is in flight.

## Wrap‚Äëup and next steps

You can execute writes and reflect status cleanly. Next, you‚Äôll add richer error handling and live event updates.
