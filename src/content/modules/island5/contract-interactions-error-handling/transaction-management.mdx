---
id: "contract-interactions-lesson-1"
slug: "transaction-management"
module: "contract-interactions-error-handling"
number: "5.4"
title: "Writing to Contracts and Transaction Management"
objective: "Master contract interactions, transaction status monitoring, and gas fee management."
practicalTakeaway: "Build dApps with reliable transaction handling and comprehensive user feedback."
---

# Writing to Contracts and Transaction Management

## Why this matters now

Reading data sets expectations; writing to contracts fulfills them. Transaction flows must be clear: prepare write, request wallet signature, show pending state, confirm success, and handle revert errors. Weâ€™ll use wagmiâ€™s write + receipt hooks to manage the full lifecycle.

## Conceptual foundations for Web3 frontend

- **Definition â€” `useWriteContract`**: wagmi hook to call stateâ€‘changing functions. **When to use it**: Mints, transfers, stakingâ€”any write that changes storage.
- **Definition â€” `useWaitForTransactionReceipt`**: Track onâ€‘chain confirmation. **When to use it**: After getting a transaction hash to reflect pending/success/failure.
- **Definition â€” Gas estimation**: Wallet/JSONâ€‘RPC estimates cost to execute. **When to use it**: Preâ€‘flight checks; surface costs to users.

## Guided code walkâ€‘throughs

### 1) Write, track, and report status

Prepare a write, trigger the wallet, and subscribe to receipt updates. Display the hash and a success message upon confirmation; surface revert messages on failure.

```tsx
import { useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import erc20Abi from "@/lib/abis/erc20.json";

export function TransferToken({ token }: { token: `0x${string}` }) {
  const { data: hash, isPending: isSigPending, error: writeError, writeContract } = useWriteContract();
  const { isLoading, isSuccess, isError, error } = useWaitForTransactionReceipt({ hash });

  function submit(recipient: `0x${string}`, amount: bigint) {
    writeContract({ address: token, abi: erc20Abi, functionName: "transfer", args: [recipient, amount] });
  }

  return (
    <div>
      <button onClick={() => submit("0x0000000000000000000000000000000000000001", 1n)}>Send 1 wei</button>
      {isSigPending && <p>Waiting for wallet signatureâ€¦</p>}
      {hash && <p>Tx submitted: <span className="font-mono">{hash}</span></p>}
      {isLoading && <p>Confirming on-chainâ€¦</p>}
      {isSuccess && <p className="text-green-600">Success! ðŸŽ‰</p>}
      {writeError && <p className="text-red-600">Write error: {writeError.message}</p>}
      {isError && error && <p className="text-red-600">Reverted: {error.message}</p>}
    </div>
  );
}
```

Takeaway: Separate signatureâ€‘pending from chain confirmation; show hash early and final status when confirmed.

### 2) Gas and UX hints

Estimate gas preâ€‘flight where needed and hint at fees. Keep buttons disabled during pending states to prevent duplicates.

```tsx
// Pseudocode: show disabled button when pending
<button disabled={isSigPending || isLoading}>Mint</button>
```

Takeaway: Pending guards and cost hints reduce user anxiety and duplicate submits.

## Practical exercises

{/* Drag & Drop Code Puzzle */}
<DragDropPuzzle codeBlocks={[
  {"id":"b1","content":"const { data: hash, writeContract } = useWriteContract();","correctPosition":0},
  {"id":"b2","content":"writeContract({ address, abi, functionName: 'mint' });","correctPosition":1},
  {"id":"b3","content":"const { isSuccess } = useWaitForTransactionReceipt({ hash });","correctPosition":2}
]}/>

### Reflection

- What copy will you show for pending vs confirmed? Where will you display the hash?
- Which writes need fee hints up front in your app?

## UX and error handling best practices

- Show signature pending separate from confirmation pending.
- Keep users informed at each stage; include a link to a block explorer when possible.
- Disable duplicate actions while a write is in flight.

## Wrapâ€‘up and next steps

You can execute writes and reflect status cleanly. Next, youâ€™ll add richer error handling and live event updates.
